{"pages":[{"title":"友链","text":"LCJ神仙的博客 欢迎交换友链~","link":"/Links/index.html"},{"title":"关于作者","text":"坐标$Beijing, China$，初二咸鱼$OIer$一枚。常常以$\\text{FST-OIer/LiM_817/LiM-817}$等id到处闲逛。下一步计划是把文化课加强以及去省选打个酱油。$QQ:1504094517$.","link":"/about/index.html"}],"posts":[{"title":"[BZOJ2194] 快速傅里叶之二 题解","text":"题意：求C_k=\\sum_{k}^{n-1}a_ib_{i-k}.$n \\leq 1e5$. 考虑反转数组$a$，生成新数组$a’$.那么C_k=\\sum_{i=k}^{n-1}a'_{n-1-i}b_{i-k},考虑把$i$改成从$0$开始。那么 C_k=\\sum_{i=0}^{n-k-1}a'_{n-k-1-i}b_i.考虑用$\\text{FFT}$计算卷积的标准形式： C'_x=\\sum_{i=0}^{x}A_{x-i}B_i.考虑$x=n-k-1$时的情况： C'_{n-k-1}=\\sum_{i=0}^{n-k-1}a'_{n-k-1-i}b_i.发现$C’$本质上就是将$C$的前$n$个反转了一下，而$C’$是可以直接计算的。于是，可以直接用$\\text{FFT}$计算出$a’$和$b$的卷积$C’$，再反转一下前$n$项，输出前$n$项即可。12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273#include &lt;bits/stdc++.h&gt;#define REP(i , x , y) for(__typeof(y) i = x; i &lt;= y; i++)#define PER(i , y , x) for(__typeof(x) i = y; i &gt;= x; i--)typedef long long LL;typedef long double ld;typedef unsigned long long ULL;/* do not give up ! try your best! Read the meaning clearly! */template &lt; typename T &gt; void Input(T&amp; t) { char c = getchar(); T x = 1; t = 0; while(!isdigit(c)) {if(c == '-') x = -1; c = getchar();} while(isdigit(c)) t = t * 10 + c - '0' , c = getchar();t *= x;}template &lt; typename T , typename... Args &gt; void Input(T&amp; t , Args&amp;... args) {Input(t); Input(args...);}template &lt; typename T &gt; T mul(T x , T y , T _) {x %= _,y %= _;return ((x * y - (T)(((ld)x * y + 0.5) / _) * _) % _ + _) % _;}using namespace std;const int MAXN = 2097152 + 10;const double Pi = acos(-1.0);int a[MAXN] , b[MAXN] , c[MAXN] , n;static complex &lt; double &gt; A[MAXN] , B[MAXN] , C[MAXN];struct FastFourierTransform { complex &lt; double &gt; omega[MAXN] , omegaInverse[MAXN]; void init(int n) { for(int i = 0; i &lt; n; i++) { omega[i] = complex &lt; double &gt; (cos(2 * Pi / n * i) , sin(2 * Pi / n * i)); omegaInverse[i] = conj(omega[i]); } } void Transform(complex &lt; double &gt; *a , const int n , const complex &lt; double &gt; *omega) { int k = 1; while((1 &lt;&lt; k) &lt; n) ++k; for(int i = 0; i &lt; n; i++) { int t = 0; for(int j = 0;j &lt; k; j++) if(i &amp; (1 &lt;&lt; j)) t |= (1 &lt;&lt; (k - 1 - j)); if(i &lt; t) swap(a[i] , a[t]); } for(int l = 2; l &lt;= n; l &lt;&lt;= 1) { int m = (l &gt;&gt; 1); for(complex &lt; double &gt; *p = a; p != a + n; p += l) { for(int i = 0; i &lt; m; i++) { complex &lt; double &gt; k = omega[n / l * i] * p[m + i]; p[m + i] = p[i] - k; p[i] += k; } } } } void DFT(complex &lt; double &gt; *a , int n) { Transform(a , n , omega); } void IDFT(complex &lt; double &gt; *a , int n) { Transform(a , n , omegaInverse); for(int i = 0; i &lt; n; i++) a[i] /= n; }}FFT;int main() { Input(n); for(int i = 0; i &lt; n; i++) Input(a[i] , b[i]); reverse(a , a + n); for(int i = 0; i &lt; n; i++) A[i].real(a[i]) , B[i].real(b[i]); int N = 1; while(N &lt; 2 * n) N &lt;&lt;= 1; FFT.init(N); FFT.DFT(A , N); FFT.DFT(B , N); for(int i = 0; i &lt; N; i++) C[i] = A[i] * B[i]; FFT.IDFT(C , N); for(int i = 0; i &lt; N; i++) c[i] = static_cast &lt; int &gt; (C[i].real() + 0.5); int cnt = 0; for(int i = 0; i &lt; n; i++) printf(\"%d\\n\" , c[n - 1 - i]); return 0;}","link":"/2019/03/09/BZOJ2194-快速傅里叶之二-题解/"},{"title":"CodeForces Round 545(div 2) 题解","text":"跟个sb一样比赛链接今天来改题了。 A题意：找出最长的一段区间使得区间长度是偶数，且区间前一半只有一种数，后一半只有一种数。 $a[i] \\in [1,2], n \\leq 100000$. A solution解：考虑分段。 123举个例子：[1 2 2 1 2 2 2 1 1 2 1]按相同的值分为一段之后就会变成[1 | 2 2 | 1 | 2 2 2 | 1 1 | 2 | 1] 显然目标区间一定会在相邻的两个段里，正确性显然。于是直接计算即可。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546/** * @Author: Mingyu Li * @Date: 2019-03-08T17:07:17+08:00 * @Email: class11limingyu@126.com * @Filename: c1138A.cpp * @Last modified by: Mingyu Li * @Last modified time: 2019-03-09T09:16:10+08:00 */#include &lt;bits/stdc++.h&gt;#define tpname typename#define Go(i , x , y) for(register int i = x; i &lt;= y; i++)#define God(i , y , x) for(register int i = y; i &gt;= x; i--)typedef long long LL;typedef long double ld;typedef unsigned long long ULL;template &lt; tpname T &gt; void sc(T&amp; t) { char c = getchar(); T x = 1; t = 0; while(!isdigit(c)) {if(c == '-') x = -1; c = getchar();} while(isdigit(c)) t = t * 10 + c - '0' , c = getchar();t *= x;}template &lt; tpname T , tpname... Args &gt; void sc(T&amp; t , Args&amp;... args) {sc(t); sc(args...);}template &lt; tpname T &gt; T mul(T x , T y , T _) { x %= _,y %= _; return ((x * y - (T)(((ld)x * y + 0.5) / _) * _) % _ + _) % _;}const int N = 100000 + 10;int pref[3][N] , suf[3][N];int n , ans = 0 , t[N];int main() { sc(n); Go(i,1,n) sc(t[i]); std::vector &lt; int &gt; v; int cnt = 1; Go(i , 2 , n+1) { if(t[i] != t[i - 1]) { v.push_back(cnt); cnt = 0; } cnt++; } Go(i , 0 , (int)v.size() - 2) ans = std::max(ans , std::min(v[i] , v[i + 1]) * 2); std::cout &lt;&lt; ans &lt;&lt; \" \\n\"; return 0;} B题意：给定一张$2$行$n$列的表格$A$.$A[i][j]$代表第$j$个人擅不擅长项目$i$.要求将$n$个人分成2组，每组$n/2$个人。（保证$n$是偶数）并满足第一组擅长项目1的人数=第二组擅长项目2的人数。输出方案。$n \\leq 5000$. B solution解：下文中将默认$(i,j)$为是否擅长项目1与项目2。看起来好像很难下手，但是只需要枚举即可。枚举第一组中$(1,0)$的人数与$(1,1)$的人数。 接着，第一组擅长项目1的人数就确定了，第二组$(1,1)$的人数也确定了，那就可以确定第二组$(0,1)$的人数了。第二组确定了，第一组也能确定。于是第一组的$(0,0)$人数也确定了。第二组随之确定。如果所有人数都合法就输出。如果没有任何一组人数合法，输出$-1$. 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162/** * @Author: Mingyu Li * @Date: 2019-03-08T17:51:24+08:00 * @Email: class11limingyu@126.com * @Filename: c1138B.cpp * @Last modified by: Mingyu Li * @Last modified time: 2019-03-09T10:47:22+08:00 */#include &lt;bits/stdc++.h&gt;#define tpname typename#define Go(i , x , y) for(register int i = x; i &lt;= y; i++)#define God(i , y , x) for(register int i = y; i &gt;= x; i--)typedef long long LL;typedef long double ld;typedef unsigned long long ULL;template &lt; tpname T &gt; void sc(T&amp; t) { char c = getchar(); T x = 1; t = 0; while(!isdigit(c)) {if(c == '-') x = -1; c = getchar();} while(isdigit(c)) t = t * 10 + c - '0' , c = getchar();t *= x;}template &lt; tpname T , tpname... Args &gt; void sc(T&amp; t , Args&amp;... args) {sc(t); sc(args...);}template &lt; tpname T &gt; T mul(T x , T y , T _) { x %= _,y %= _; return ((x * y - (T)(((ld)x * y + 0.5) / _) * _) % _ + _) % _;}int n;std::string a , b;std::vector &lt; int &gt; v00 , v01 , v10 , v11;int main() { v00.clear(); v11.clear(); v01.clear(); v10.clear(); std::cin &gt;&gt; n; std::cin &gt;&gt; a &gt;&gt; b; a = \"%\" + a; b = \"%\" + b; Go(i , 1 , n) { if(a[i] == '1' &amp;&amp; b[i] == '1') v11.push_back(i); else if(a[i] == '0' &amp;&amp; b[i] == '0') v00.push_back(i); else if(a[i] == '0' &amp;&amp; b[i] == '1') v01.push_back(i); else if(a[i] == '1' &amp;&amp; b[i] == '0') v10.push_back(i); } Go(s10 , 0 , (int)(v10.size())) Go(s11 , 0 , (int)(v11.size())) { if(s10 + s11 &gt; n/2) continue; // 选完之后 剩下的s10和s11进入第二组 // 对答案有贡献的只有s11 int g2_s01 = s10 + 2 * s11 - (int)((int)(v11.size())); int g1_s01 = (int)(v01.size()) - g2_s01; if(g2_s01 &gt;= 0 &amp;&amp; g2_s01 &lt;= (int)(v01.size())) { int g1_s00 = n/2 - g1_s01 - s10 - s11; if(g1_s00 &gt;= 0 &amp;&amp; g1_s00 &lt;= (int)(v00.size())) { Go(i , 0 , s11 - 1) std::cout &lt;&lt; v11[i] &lt;&lt; \" \"; Go(i , 0 , s10 - 1) std::cout &lt;&lt; v10[i] &lt;&lt; \" \"; Go(i , 0 , g1_s01 - 1) std::cout &lt;&lt; v01[i] &lt;&lt; \" \"; Go(i , 0 , g1_s00 - 1) std::cout &lt;&lt; v00[i] &lt;&lt; \" \"; puts(\"\"); return 0; } } } puts(\"-1\"); return 0;} C给定一个$n\\times m$大小的表格。要求对于每一个位置$(i,j)$,求出$ans(i,j)$.其中$ans(i,j)$表示将第i行和第j列的某些数更改后使得在满足行内所有数相对大小关系不变，列内所有数相对大小关系不变的情况下，行列内最大值 的最小值。 $n,m \\leq 1000$. 时限2s. C solution解：发现除了$a[i][j]$一个交界点之外，行列之间是独立的。所以，只需要确定$a[i][j]$重新排列之后的排名即可。这玩意很好确定。因为行列之间是独立的，所以答案就是 max(行内比a[i][j]小的数的种数,列内比a[i][j]小的数的种数)+1同理，题目要求最小化最大值。由于行列独立，所以最大值的编号就是 a[i][j]排名+max(行内比a[i][j]大的数的种数,列内比a[i][j]大的数的种数)这个东西可以每行每列一起预处理，复杂度$\\Theta(n^2 log(n))$.12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364/** * @Author: Mingyu Li * @Date: 2019-03-09T10:47:43+08:00 * @Email: class11limingyu@126.com * @Filename: c1138C.cpp * @Last modified by: Mingyu Li * @Last modified time: 2019-03-09T11:57:03+08:00 */#include &lt;bits/stdc++.h&gt;#define tpname typename#define Go(i , x , y) for(register int i = x; i &lt;= y; i++)#define God(i , y , x) for(register int i = y; i &gt;= x; i--)typedef long long LL;typedef long double ld;typedef unsigned long long ULL;template &lt; tpname T &gt; void sc(T&amp; t) { char c = getchar(); T x = 1; t = 0; while(!isdigit(c)) {if(c == '-') x = -1; c = getchar();} while(isdigit(c)) t = t * 10 + c - '0' , c = getchar();t *= x;}template &lt; tpname T , tpname... Args &gt; void sc(T&amp; t , Args&amp;... args) {sc(t); sc(args...);}template &lt; tpname T &gt; T mul(T x , T y , T _) { x %= _,y %= _; return ((x * y - (T)(((ld)x * y + 0.5) / _) * _) % _ + _) % _;}const int N = 1000 + 10;int ans[N][N];int n , m , it;int a[N][N] , b[N];int ans1[N][N] , ans2[N][N] , big1[N][N] , big2[N][N];int p = 0;int main() { sc(n , m); Go(i , 1 , n) Go(j , 1 , m) sc(a[i][j]); Go(i , 1 , n) { p = 0; Go(j , 1 , m) b[++p] = a[i][j]; std::sort(b + 1 , b + p + 1); p = std::unique(b + 1 , b + p + 1) - (b + 1); Go(j , 1 , m) { ans1[i][j] = std::lower_bound(b+1 , b+p+1 , a[i][j]) - b; big1[i][j] = p - ans1[i][j]; } } Go(i , 1 , m) { p = 0; Go(j , 1 , n) b[++p] = a[j][i]; std::sort(b + 1 , b + p + 1); p = std::unique(b + 1 , b + p + 1) - (b + 1); Go(j , 1 , n) { ans2[j][i] = std::lower_bound(b+1 , b+p+1 , a[j][i]) - b; big2[j][i] = p - ans2[j][i]; } } Go(i , 1 , n) { Go(j , 1 , m) printf(\"%d \" , std::max(ans1[i][j] , ans2[i][j]) + std::max(big1[i][j] , big2[i][j])); puts(\"\"); } return 0;}","link":"/2019/03/09/CF545-div-2-题解/"},{"title":"[ZJOI2014]力 题解","text":"题意： 发现Ei如果给出了Fi就很好算，所以目标其实是算Fi.首先我们令$F_j=A_j-B_j$.其中A_j=\\sum_{ij}\\frac{q_iq_j}{(i-j)^2}.考虑将第一个式子变形为 A_j=\\sum_{i=0}^{j-1}\\frac{q_iq_j}{(i-j)^2}.由乘法分配律，可以将$q_j$单拎出来，得： A_j=q_j\\times \\sum_{i=0}^{j-1}\\frac{q_i}{(i-j)^2}.由于$(i-j)^2=(j-i)^2$，所以考虑这样一个函数： g(x)=\\frac{1}{x^2}.然后就会发现可以把 \\frac{q_i}{(i-j)^2}变形为 q_ig(j-i).带回原式，得到：A_j=q_j\\times \\sum_{i=0}^{j-1}q_ig(j-i).不难发现后面的那坨东西类似于多项式乘法，但是少了一项，可以手动将$g(0)=0$.然后…这就是个多项式乘法的典型形式！可以用$\\text{FFT}$解决！同理也可以化简$B_j$. B_j=\\sum_{i=j+1}^{n-1} \\frac{q_iq_j}{(i-j)^2}B_j=q_j\\sum_{i=j+1}^{n} \\frac{q_i}{(i-j)^2}然后突然发现…这东西和$A_j$的计算方法不大一样!咋整？瞬间考虑-&gt;反转q序列！变成 \\sum_{i=0}^{j-1}\\frac{q'_i}{(i-j)^2}.然后把这个式子搞一下，变成 \\sum_{i=0}^{j-1}q'_ig(j-i)发现这个式子本质上就是$A_j$，就能做了。","link":"/2019/03/09/ZJOI2014-力-题解/"},{"title":"Hello World","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","link":"/2019/03/07/hello-world/"},{"title":"你好.","text":"Hello.Hello.markdon$a+b=c$ $c_k=\\sum _{i=0}^{n-1}(\\omega_{n}^{-k})^i\\times y_i.$ lim_{1\\to+\\infty}P(|\\frac{1}{n}\\sum_i^nX_i-\\mu|","link":"/2019/03/07/你好/"},{"title":"FFT详解","text":"用于计算一类朴素卷积问题。 笔者学习的是这份博客内容中可能有很多相同之处，敬请谅解。 现在要计算两个一元$n$次多项式$F(x)$与$G(x)$的乘积，如何计算？前置知识：多项式的表示方法一. 系数表示法对于一个$n$次多项式$F(x)$，它可以被表示成 F(x) = a_nx^n+a_{n-1}x^{n-1}+...+a_1x^1+a_0x^0.更加形式化的来说，它可以表示成 F(x) = \\sum_{i=0}^{n} a_ix^i.举个例子，2次多项式，其中$a_0=1,a_1=2,a_2=1$那么$F(x)=1x^2+2x+1.$这样即可通俗的表示出一个$n$次多项式。二. 点值表示法众所周知，两个点确定一个一次函数，三个点确定一个二次函数。所以，$n+1$个点确定一个一元$n$次多项式。所以我们可以通过$n+1$个点来表示它。那么相乘之后的点值如何计算？比如说两个2次多项式$F(x)=x^2+2x+1$（红色）与$G(x)=3x^2-4x-2$（蓝色），它们的图像如图所示：那么观察图中$x=1$时的情况。此时$F(1)=4,G(1)=-3.$所以，显然，$F(1)\\times G(1)=-12$.也就是说在$Z=FG$这一多项式内，带入$1$，得到的结果是$-12$.等等，好像有哪里不对。如果说$Z=FG$的话，那么Z的次数应该是$2n$.那$Z$需要$2n+1$个点来确定。但是原来只需要$n+1$个点，咋办？很简单，在原来的多项式里每个都多加$n$个点即可。反正多项式已知。这样就可以用点值来进行操作。也就是说先转成点值，再一乘，再转回来，就是计算流程。但是好像还是很慢。那么如何优化呢?复数部分复数，即形如$a+bi$的数，其中$i^2=-1.$ $a$称为实部，$bi$称为虚部。或者说：在一个数轴上（只有x轴），我们可以表示出任何实数。那么，多加一维（y轴），也就是类似于平面直角坐标系一样，我们就可以表示出任意一个复数。所以我们把这个坐标系叫做复平面，其中x轴称为实轴，y轴称为虚轴。复数运算复数相加：实部相加，虚部相加，例如 (a+bi)+(c+di)=(a+c)+(b+d)i.复数相减：同理。 (a+bi)-(c+di)=(a-c)+(b-d)i.复数相乘：像一次多项式一样相乘。 注意$i^2=-1$. (a+bi)(c+di)=ac+(ad+bc)i-bd=(ac-bd)+(ad+bc)i.复数相除：相信大家都学过共轭根式。同样的，复数也有共轭。即：$a+bi$的共轭为$a-bi$。这两个复数卡乘在一起一定是个实数。即 (a+bi)(a-bi)=a^2-(bi)^2=a^2+b^2.所以再除的时候，将分子分母同乘分母的共轭，就可以将分母有理化。即 \\frac{a+bi}{c+di}=\\frac{(a+bi)(c-di)}{c^2+d^2}=\\frac{ac+bd}{c^2+d^2}+\\frac{bc-ad}{c^2+d^2}i.复数逆元： \\frac{1}{a+bi}=\\frac{a}{a^2+b^2}-\\frac{b}{a^2+b^2}i.同样的，复数运算在复平面内也有一定规律可循。考虑在复平面内的两个复数：（借张图） 表示的是复数$(1+4i)$与复数$(3+2i)$相乘所得的结果：$(-5+14i)$。设其中$(5,0)$点为位置$P$，则$\\angle{POC}=\\angle{BOA}.$还有：$\\overline{OB}\\times\\overline{OC}=\\overline{OA}.$第二个证明：勾股定理。先把$i$消掉。$\\overline{OB}^2=a^2+b^2.$ $\\overline{OC}^2=c^2+d^2.$$\\overline{OB}^2\\times \\overline{OC}^2=(a^2+b^2)(c^2+d^2)=a^2c^2+a^2d^2+b^2c^2+b^2d^2.$$\\overline{OA}^2=(ac-bd)^2+(ad+bc)^2=a^2c^2+a^2d^2+b^2c^2+b^2d^2.$得证。我们将复数中，复数向量的长度称为模长，向量与x轴正方向的夹角称为幅角。根据上面的东西：复数相乘时，模长相乘，幅角相加。单位根一个n次的单位根即为方程$x^n=1$的复数解。考虑这样一个图：其中圆上的所有复数模长都是1，这个圆称为单位圆。考虑$|x|$的取值范围：如果$|x|","link":"/2019/03/08/FFT详解/"}],"tags":[{"name":"数学","slug":"数学","link":"/tags/数学/"},{"name":"FFT","slug":"FFT","link":"/tags/FFT/"},{"name":"CodeForces","slug":"CodeForces","link":"/tags/CodeForces/"}],"categories":[{"name":"题解","slug":"题解","link":"/categories/题解/"},{"name":"算法笔记","slug":"算法笔记","link":"/categories/算法笔记/"}]}