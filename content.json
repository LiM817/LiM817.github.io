{"pages":[],"posts":[{"title":"[BZOJ2194] 快速傅里叶之二 题解","text":"题意：求C_k=\\sum_{k}^{n-1}a_ib_{i-k}.$n \\leq 1e5$. 考虑反转数组$a$，生成新数组$a’$.那么C_k=\\sum_{i=k}^{n-1}a'_{n-1-i}b_{i-k},考虑把$i$改成从$0$开始。那么 C_k=\\sum_{i=0}^{n-k-1}a'_{n-k-1-i}b_i.考虑用$\\text{FFT}$计算卷积的标准形式： C'_x=\\sum_{i=0}^{x}A_{x-i}B_i.考虑$x=n-k-1$时的情况： C'_{n-k-1}=\\sum_{i=0}^{n-k-1}a'_{n-k-1-i}b_i.发现$C’$本质上就是将$C$的前$n$个反转了一下，而$C’$是可以直接计算的。于是，可以直接用$\\text{FFT}$计算出$a’$和$b$的卷积$C’$，再反转一下前$n$项，输出前$n$项即可。12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273#include &lt;bits/stdc++.h&gt;#define REP(i , x , y) for(__typeof(y) i = x; i &lt;= y; i++)#define PER(i , y , x) for(__typeof(x) i = y; i &gt;= x; i--)typedef long long LL;typedef long double ld;typedef unsigned long long ULL;/* do not give up ! try your best! Read the meaning clearly! */template &lt; typename T &gt; void Input(T&amp; t) { char c = getchar(); T x = 1; t = 0; while(!isdigit(c)) {if(c == '-') x = -1; c = getchar();} while(isdigit(c)) t = t * 10 + c - '0' , c = getchar();t *= x;}template &lt; typename T , typename... Args &gt; void Input(T&amp; t , Args&amp;... args) {Input(t); Input(args...);}template &lt; typename T &gt; T mul(T x , T y , T _) {x %= _,y %= _;return ((x * y - (T)(((ld)x * y + 0.5) / _) * _) % _ + _) % _;}using namespace std;const int MAXN = 2097152 + 10;const double Pi = acos(-1.0);int a[MAXN] , b[MAXN] , c[MAXN] , n;static complex &lt; double &gt; A[MAXN] , B[MAXN] , C[MAXN];struct FastFourierTransform { complex &lt; double &gt; omega[MAXN] , omegaInverse[MAXN]; void init(int n) { for(int i = 0; i &lt; n; i++) { omega[i] = complex &lt; double &gt; (cos(2 * Pi / n * i) , sin(2 * Pi / n * i)); omegaInverse[i] = conj(omega[i]); } } void Transform(complex &lt; double &gt; *a , const int n , const complex &lt; double &gt; *omega) { int k = 1; while((1 &lt;&lt; k) &lt; n) ++k; for(int i = 0; i &lt; n; i++) { int t = 0; for(int j = 0;j &lt; k; j++) if(i &amp; (1 &lt;&lt; j)) t |= (1 &lt;&lt; (k - 1 - j)); if(i &lt; t) swap(a[i] , a[t]); } for(int l = 2; l &lt;= n; l &lt;&lt;= 1) { int m = (l &gt;&gt; 1); for(complex &lt; double &gt; *p = a; p != a + n; p += l) { for(int i = 0; i &lt; m; i++) { complex &lt; double &gt; k = omega[n / l * i] * p[m + i]; p[m + i] = p[i] - k; p[i] += k; } } } } void DFT(complex &lt; double &gt; *a , int n) { Transform(a , n , omega); } void IDFT(complex &lt; double &gt; *a , int n) { Transform(a , n , omegaInverse); for(int i = 0; i &lt; n; i++) a[i] /= n; }}FFT;int main() { Input(n); for(int i = 0; i &lt; n; i++) Input(a[i] , b[i]); reverse(a , a + n); for(int i = 0; i &lt; n; i++) A[i].real(a[i]) , B[i].real(b[i]); int N = 1; while(N &lt; 2 * n) N &lt;&lt;= 1; FFT.init(N); FFT.DFT(A , N); FFT.DFT(B , N); for(int i = 0; i &lt; N; i++) C[i] = A[i] * B[i]; FFT.IDFT(C , N); for(int i = 0; i &lt; N; i++) c[i] = static_cast &lt; int &gt; (C[i].real() + 0.5); int cnt = 0; for(int i = 0; i &lt; n; i++) printf(\"%d\\n\" , c[n - 1 - i]); return 0;}","link":"/2019/03/09/BZOJ2194-快速傅里叶之二-题解/"},{"title":"你好.","text":"Hello.Hello.markdon$a+b=c$ $c_k=\\sum _{i=0}^{n-1}(\\omega_{n}^{-k})^i\\times y_i.$ lim_{1\\to+\\infty}P(|\\frac{1}{n}\\sum_i^nX_i-\\mu|","link":"/2019/03/07/你好/"},{"title":"Hello World","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","link":"/2019/03/07/hello-world/"},{"title":"[ZJOI2014]力 题解","text":"题意： 发现Ei如果给出了Fi就很好算，所以目标其实是算Fi.首先我们令$F_j=A_j-B_j$.其中A_j=\\sum_{ij}\\frac{q_iq_j}{(i-j)^2}.考虑将第一个式子变形为 A_j=\\sum_{i=0}^{j-1}\\frac{q_iq_j}{(i-j)^2}.由乘法分配律，可以将$q_j$单拎出来，得： A_j=q_j\\times \\sum_{i=0}^{j-1}\\frac{q_i}{(i-j)^2}.由于$(i-j)^2=(j-i)^2$，所以考虑这样一个函数： g(x)=\\frac{1}{x^2}.然后就会发现可以把 \\frac{q_i}{(i-j)^2}变形为 q_ig(j-i).带回原式，得到：A_j=q_j\\times \\sum_{i=0}^{j-1}q_ig(j-i).不难发现后面的那坨东西类似于多项式乘法，但是少了一项，可以手动将$g(0)=0$.然后…这就是个多项式乘法的典型形式！可以用$\\text{FFT}$解决！同理也可以化简$B_j$. B_j=\\sum_{i=j+1}^{n-1} \\frac{q_iq_j}{(i-j)^2}B_j=q_j\\sum_{i=j+1}^{n} \\frac{q_i}{(i-j)^2}然后突然发现…这东西和$A_j$的计算方法不大一样!咋整？瞬间考虑-&gt;反转q序列！变成 \\sum_{i=0}^{j-1}\\frac{q'_i}{(i-j)^2}.然后把这个式子搞一下，变成 \\sum_{i=0}^{j-1}q'_ig(j-i)发现这个式子本质上就是$A_j$，就能做了。","link":"/2019/03/09/ZJOI2014-力-题解/"},{"title":"FFT详解","text":"用于计算一类朴素卷积问题。 笔者学习的是这份博客内容中可能有很多相同之处，敬请谅解。 现在要计算两个一元$n$次多项式$F(x)$与$G(x)$的乘积，如何计算？前置知识：多项式的表示方法一. 系数表示法对于一个$n$次多项式$F(x)$，它可以被表示成 F(x) = a_nx^n+a_{n-1}x^{n-1}+...+a_1x^1+a_0x^0.更加形式化的来说，它可以表示成 F(x) = \\sum_{i=0}^{n} a_ix^i.举个例子，2次多项式，其中$a_0=1,a_1=2,a_2=1$那么$F(x)=1x^2+2x+1.$这样即可通俗的表示出一个$n$次多项式。二. 点值表示法众所周知，两个点确定一个一次函数，三个点确定一个二次函数。所以，$n+1$个点确定一个一元$n$次多项式。所以我们可以通过$n+1$个点来表示它。那么相乘之后的点值如何计算？比如说两个2次多项式$F(x)=x^2+2x+1$（红色）与$G(x)=3x^2-4x-2$（蓝色），它们的图像如图所示：那么观察图中$x=1$时的情况。此时$F(1)=4,G(1)=-3.$所以，显然，$F(1)\\times G(1)=-12$.也就是说在$Z=FG$这一多项式内，带入$1$，得到的结果是$-12$.等等，好像有哪里不对。如果说$Z=FG$的话，那么Z的次数应该是$2n$.那$Z$需要$2n+1$个点来确定。但是原来只需要$n+1$个点，咋办？很简单，在原来的多项式里每个都多加$n$个点即可。反正多项式已知。这样就可以用点值来进行操作。也就是说先转成点值，再一乘，再转回来，就是计算流程。但是好像还是很慢。那么如何优化呢?复数部分复数，即形如$a+bi$的数，其中$i^2=-1.$ $a$称为实部，$bi$称为虚部。或者说：在一个数轴上（只有x轴），我们可以表示出任何实数。那么，多加一维（y轴），也就是类似于平面直角坐标系一样，我们就可以表示出任意一个复数。所以我们把这个坐标系叫做复平面，其中x轴称为实轴，y轴称为虚轴。复数运算复数相加：实部相加，虚部相加，例如 (a+bi)+(c+di)=(a+c)+(b+d)i.复数相减：同理。 (a+bi)-(c+di)=(a-c)+(b-d)i.复数相乘：像一次多项式一样相乘。 注意$i^2=-1$. (a+bi)(c+di)=ac+(ad+bc)i-bd=(ac-bd)+(ad+bc)i.复数相除：相信大家都学过共轭根式。同样的，复数也有共轭。即：$a+bi$的共轭为$a-bi$。这两个复数卡乘在一起一定是个实数。即 (a+bi)(a-bi)=a^2-(bi)^2=a^2+b^2.所以再除的时候，将分子分母同乘分母的共轭，就可以将分母有理化。即 \\frac{a+bi}{c+di}=\\frac{(a+bi)(c-di)}{c^2+d^2}=\\frac{ac+bd}{c^2+d^2}+\\frac{bc-ad}{c^2+d^2}i.复数逆元： \\frac{1}{a+bi}=\\frac{a}{a^2+b^2}-\\frac{b}{a^2+b^2}i.同样的，复数运算在复平面内也有一定规律可循。考虑在复平面内的两个复数：（借张图） 表示的是复数$(1+4i)$与复数$(3+2i)$相乘所得的结果：$(-5+14i)$。设其中$(5,0)$点为位置$P$，则$\\angle{POC}=\\angle{BOA}.$还有：$\\overline{OB}\\times\\overline{OC}=\\overline{OA}.$第二个证明：勾股定理。先把$i$消掉。$\\overline{OB}^2=a^2+b^2.$ $\\overline{OC}^2=c^2+d^2.$$\\overline{OB}^2\\times \\overline{OC}^2=(a^2+b^2)(c^2+d^2)=a^2c^2+a^2d^2+b^2c^2+b^2d^2.$$\\overline{OA}^2=(ac-bd)^2+(ad+bc)^2=a^2c^2+a^2d^2+b^2c^2+b^2d^2.$得证。我们将复数中，复数向量的长度称为模长，向量与x轴正方向的夹角称为幅角。根据上面的东西：复数相乘时，模长相乘，幅角相加。单位根一个n次的单位根即为方程$x^n=1$的复数解。考虑这样一个图：其中圆上的所有复数模长都是1，这个圆称为单位圆。考虑$|x|$的取值范围：如果$|x|","link":"/2019/03/08/FFT详解/"}],"tags":[{"name":"math","slug":"math","link":"/tags/math/"}],"categories":[]}