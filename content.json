{"pages":[{"title":"友链","text":"LCJ神仙的博客Dilute神仙的博客欢迎交换友链~","link":"/Links/index.html"},{"title":"关于作者","text":"坐标$Beijing, China$，初二咸鱼$OIer$一枚。常常以$\\text{FST-OIer/LiM_817/LiM-817}$等id到处闲逛。下一步计划是把文化课加强以及去省选打个酱油。$QQ:1504094517$.","link":"/about/index.html"}],"posts":[{"title":"[BZOJ2194] 快速傅里叶之二 题解","text":"题意：求C_k=\\sum_{k}^{n-1}a_ib_{i-k}.$n \\leq 1e5$. 考虑反转数组$a$，生成新数组$a’$.那么C_k=\\sum_{i=k}^{n-1}a'_{n-1-i}b_{i-k},考虑把$i$改成从$0$开始。那么 C_k=\\sum_{i=0}^{n-k-1}a'_{n-k-1-i}b_i.考虑用$\\text{FFT}$计算卷积的标准形式： C'_x=\\sum_{i=0}^{x}A_{x-i}B_i.考虑$x=n-k-1$时的情况： C'_{n-k-1}=\\sum_{i=0}^{n-k-1}a'_{n-k-1-i}b_i.发现$C’$本质上就是将$C$的前$n$个反转了一下，而$C’$是可以直接计算的。于是，可以直接用$\\text{FFT}$计算出$a’$和$b$的卷积$C’$，再反转一下前$n$项，输出前$n$项即可。12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273#include &lt;bits/stdc++.h&gt;#define REP(i , x , y) for(__typeof(y) i = x; i &lt;= y; i++)#define PER(i , y , x) for(__typeof(x) i = y; i &gt;= x; i--)typedef long long LL;typedef long double ld;typedef unsigned long long ULL;/* do not give up ! try your best! Read the meaning clearly! */template &lt; typename T &gt; void Input(T&amp; t) { char c = getchar(); T x = 1; t = 0; while(!isdigit(c)) {if(c == '-') x = -1; c = getchar();} while(isdigit(c)) t = t * 10 + c - '0' , c = getchar();t *= x;}template &lt; typename T , typename... Args &gt; void Input(T&amp; t , Args&amp;... args) {Input(t); Input(args...);}template &lt; typename T &gt; T mul(T x , T y , T _) {x %= _,y %= _;return ((x * y - (T)(((ld)x * y + 0.5) / _) * _) % _ + _) % _;}using namespace std;const int MAXN = 2097152 + 10;const double Pi = acos(-1.0);int a[MAXN] , b[MAXN] , c[MAXN] , n;static complex &lt; double &gt; A[MAXN] , B[MAXN] , C[MAXN];struct FastFourierTransform { complex &lt; double &gt; omega[MAXN] , omegaInverse[MAXN]; void init(int n) { for(int i = 0; i &lt; n; i++) { omega[i] = complex &lt; double &gt; (cos(2 * Pi / n * i) , sin(2 * Pi / n * i)); omegaInverse[i] = conj(omega[i]); } } void Transform(complex &lt; double &gt; *a , const int n , const complex &lt; double &gt; *omega) { int k = 1; while((1 &lt;&lt; k) &lt; n) ++k; for(int i = 0; i &lt; n; i++) { int t = 0; for(int j = 0;j &lt; k; j++) if(i &amp; (1 &lt;&lt; j)) t |= (1 &lt;&lt; (k - 1 - j)); if(i &lt; t) swap(a[i] , a[t]); } for(int l = 2; l &lt;= n; l &lt;&lt;= 1) { int m = (l &gt;&gt; 1); for(complex &lt; double &gt; *p = a; p != a + n; p += l) { for(int i = 0; i &lt; m; i++) { complex &lt; double &gt; k = omega[n / l * i] * p[m + i]; p[m + i] = p[i] - k; p[i] += k; } } } } void DFT(complex &lt; double &gt; *a , int n) { Transform(a , n , omega); } void IDFT(complex &lt; double &gt; *a , int n) { Transform(a , n , omegaInverse); for(int i = 0; i &lt; n; i++) a[i] /= n; }}FFT;int main() { Input(n); for(int i = 0; i &lt; n; i++) Input(a[i] , b[i]); reverse(a , a + n); for(int i = 0; i &lt; n; i++) A[i].real(a[i]) , B[i].real(b[i]); int N = 1; while(N &lt; 2 * n) N &lt;&lt;= 1; FFT.init(N); FFT.DFT(A , N); FFT.DFT(B , N); for(int i = 0; i &lt; N; i++) C[i] = A[i] * B[i]; FFT.IDFT(C , N); for(int i = 0; i &lt; N; i++) c[i] = static_cast &lt; int &gt; (C[i].real() + 0.5); int cnt = 0; for(int i = 0; i &lt; n; i++) printf(\"%d\\n\" , c[n - 1 - i]); return 0;}","link":"/2019/03/09/BZOJ2194-快速傅里叶之二-题解/"},{"title":"[CF1131D]Gourmet Choice 题解","text":"题意：有两组食物，分别有$n$个和$m$个。给定$n\\times m$的一个表格，其中$a[i][j]$表示第一组第$i$个食物和第二组第$j$个食物的美味度大小关系。请问是否能给出一组美味度方案。如果有，请给出美味度最大值最小的方案。如果没有，请输出No. 先膜LCJ本题如果数据出小一点就是差分约束系统的裸题。但是到了现在的数据大小，差分约束无法承受，所以考虑用并查集+拓扑排序解决。把=的食物用并查集并起来。然后对于&gt;和&lt;的情况，如果这俩元素在一个联通块里，显然不能构造。否则，如果$a[i][j]= ‘&lt;’$就从$i$的连通块向$j$连一条边，反之亦然。然后对联通块跑拓扑排序即可。注意有环也不能构造。正确性很显然：对于$v$，如果被删成了入度$=0$，那么上一次它只需要满足$u$的限制即可。故$value[v] = value[u] + 1$.123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109/** * @Author: Mingyu Li * @Date: 2019-03-09T22:42:11+08:00 * @Email: class11limingyu@126.com * @Filename: c1131D.cpp * @Last modified by: Mingyu Li * @Last modified time: 2019-03-10T06:53:10+08:00 */#include &lt;bits/stdc++.h&gt;#define tpname typename#define Go(i , x , y) for(register int i = x; i &lt;= y; i++)#define God(i , y , x) for(register int i = y; i &gt;= x; i--)typedef long long LL;typedef long double ld;typedef unsigned long long ULL;template &lt; tpname T &gt; void sc(T&amp; t) { char c = getchar(); T x = 1; t = 0; while(!isdigit(c)) {if(c == '-') x = -1; c = getchar();} while(isdigit(c)) t = t * 10 + c - '0' , c = getchar();t *= x;}template &lt; tpname T , tpname... Args &gt; void sc(T&amp; t , Args&amp;... args) {sc(t); sc(args...);}template &lt; tpname T &gt; T mul(T x , T y , T _) { x %= _,y %= _; return ((x * y - (T)(((ld)x * y + 0.5) / _) * _) % _ + _) % _;}const int N = 1000 + 5;int f[N + N];int find(int x) { return x == f[x] ? f[x] : f[x] = find(f[x]);}std::vector &lt;int&gt; v[N + N] , Graph[N + N];std::map &lt;std::pair&lt;int,int&gt;,int&gt; alr;char a[N][N];int n , m;int merge(int u , int v) { f[find(u)] = find(v);}int rf;int degree[N + N] , ans[N + N];void Link(int u , int v) { if(u == v) { rf = 1; return ; } if(alr[{u , v}]) return ; alr[{u , v}] = 1; Graph[u].push_back(v); ++degree[v];}int main() { sc(n , m); Go(i , 1 , n) scanf(\"%s\" , (a[i] + 1)); Go(i , 1 , n+m) f[i] = i; Go(i , 1 , n) Go(j , 1 , m) if(a[i][j] == '=') merge(i , n+j); std::vector &lt;int&gt; v1; Go(i , 1 , n+m) v[find(i)].push_back(i) , v1.push_back(find(i)); Go(i , 1 , n) Go(j , 1 , m) { if(a[i][j] == '&lt;') Link(find(i) , find(n+j)); else if(a[i][j] == '&gt;') Link(find(n+j) , find(i)); } if(rf) { puts(\"No\"); return 0; } std::queue &lt;std::pair &lt;int , int&gt; &gt; Q; sort(v1.begin() , v1.end()); int m1 = unique(v1.begin() , v1.end()) - v1.begin(); std::vector &lt;int&gt; v2; Go(i , 0 , m1-1) if(!degree[v1[i]]) { Q.push({v1[i] , 1}); v2.push_back(v1[i]); for(auto fix : v[v1[i]]) ans[fix] = 1; } while(!Q.empty()) { std::pair &lt; int , int &gt; x = Q.front(); Q.pop(); int u = x.first , va = x.second; for(auto vv : Graph[u]) { degree[vv]--; if(!degree[vv]) { degree[vv] = 0; Q.push({vv , va + 1}); v2.push_back(vv); } } } Go(i , 0 , v2.size() - 1) { for(auto fix : v[v2[i]]) ans[fix] = i + 1; } int ans1 = 0; Go(i , 1 , n+m) ans1 += (degree[find(i)] == 0); //std::cerr &lt;&lt; \"\\n\"; if(ans1 != n+m) { puts(\"No\"); return 0; } std::cout &lt;&lt; \"Yes\\n\"; Go(i , 1 , n) std::cout &lt;&lt; ans[i] &lt;&lt; \" \"; std::cout &lt;&lt; \"\\n\"; Go(i , 1 , m) std::cout &lt;&lt; ans[n + i] &lt;&lt; \" \"; std::cout &lt;&lt; \"\\n\"; return 0;}","link":"/2019/03/10/CF1131D-Gourmet-Choice-题解/"},{"title":"[Baltic2004]Friends 题解","text":"题意：对于一个字符串$s$,复制一遍之后得到$e$，在$e$的任何位置插入一个字符形成$u$。给定$u$，求字符串$s$. 字符串哈希。 考虑尝试每一个字符，尝试一下去除这个字符之后剩下的字符串是否能成功分成两部分。 用字符串哈希自带的“拼凑”功能即可。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168#pragma GCC optimize(\"2\")#include &lt;bits/stdc++.h&gt;#define PI 3.14159265#define PQ priority_queue#define lowbit(x) ((x) &amp; (-x))#define rep(i , x , y) for(int (i) = (x) ; (i) &lt;= (y) ; ++i)#define per(i , x , y) for(int (i) = (x) ; (i) &gt;= (y) ; --i)//#define lmy#ifdef lmy #define DEBUG printf(\"Passing [%s] in LINE %d...\\n\" , __FUNCTION__ , __LINE__)#endiftypedef long long ll;typedef unsigned long long ull;using namespace std;inline void read(int &amp;x) { int f = 1;x = 0;char ch = getchar(); while(ch &lt; '0' || ch &gt; '9') {if(ch == '-') f = -1; ch = getchar();} while(ch &gt;= '0' &amp;&amp; ch &lt;= '9') {x = x * 10 + ch - '0'; ch = getchar();} x *= f;}inline void readll(ll &amp;x) { ll f = 1;x = 0;char ch = getchar(); while(ch &lt; '0' || ch &gt; '9') {if(ch == '-') f = -1; ch = getchar();} while(ch &gt;= '0' &amp;&amp; ch &lt;= '9') {x = x * 10 + ch - '0'; ch = getchar();} x *= f;}inline void print(int x) { if (x &lt; 0) putchar('-'), x = -x;if (x &gt; 9) print(x / 10);putchar(x % 10 + 48);}inline void printll(ll x) { if (x &lt; 0) putchar('-'), x = -x;if (x &gt; 9) print(x / 10);putchar(x % 10 + 48);}const int MaxN = 2000000 + 5;const ull bse = 13331;char a[MaxN];int n;ull Pw[MaxN] , Hsh[MaxN];vector &lt;int&gt; p;void HshPre() { Pw[0] = 1; rep(i , 1 , n + 1) Pw[i] = Pw[i - 1] * bse; rep(i , 1 , n) { Hsh[i] = Hsh[i - 1] * bse + (ull)(a[i]); }}ull HshValue(int l , int r) { return Hsh[r] - Hsh[l - 1] * Pw[r - l + 1];}ull Merge(int l , int r , int ql , int qr) { // BaoZheng l , r &lt; ql , qr ull HshValue1 = HshValue(l , r) , HshValue2 = HshValue(ql , qr); return HshValue1 * Pw[qr - ql + 1] + HshValue2;}bool Chksame(int l , int r , int ql , int qr) { return HshValue(l , r) == HshValue(ql , qr);}set &lt;ull&gt; obtain;void solve() { cin &gt;&gt; n; scanf(\"%s\" , (a + 1)); //n = strlen(a + 1); if(!(n % 2)) { puts(\"NOT POSSIBLE\"); return ; } HshPre(); rep(i , 1 , n) { if(i == 1) { if(Chksame(2 , (n + 1) / 2 , (n + 1) / 2 + 1 , n) &amp;&amp; !obtain . count(HshValue(2 , (n + 1) / 2))) { // DEBUG; p . push_back(i); obtain . insert(HshValue(2 , (n + 1) / 2)); } } else if(i == n) { if(Chksame(1 , n / 2 , n / 2 + 1 , n - 1) &amp;&amp; !obtain . count(HshValue(1 , n / 2))) { //DEBUG; p . push_back(i); obtain . insert(HshValue(1 , n / 2)); } } else if(i == (n + 1) / 2) { if(Chksame(1 , n / 2 , n - (n / 2) + 1 , n) &amp;&amp; !obtain . count(HshValue(1 , n / 2))) { p . push_back(i) , obtain . insert(HshValue(1 , n / 2)); } } else if(i &gt; (n + 1) / 2) { int l = 1 , r = n / 2; int pl = r + 1 , pr = i - 1; int ppl = i + 1 , ppr = n; ull V = Merge(pl , pr , ppl , ppr); if(V == HshValue(l , r) &amp;&amp; !obtain . count(HshValue(l , r))) { p . push_back(i); obtain . insert(HshValue(l , r)); } } else if(i &lt; (n + 1) / 2) { int l = n - (n / 2) + 1 , r = n; int pl = 1 , pr = i - 1; int ppl = i + 1 , ppr = l - 1; ull V = Merge(pl , pr , ppl , ppr); //if(i == 3) cout &lt;&lt; V &lt;&lt; \"DBG , \" &lt;&lt; HshValue(l , r) &lt;&lt; \" Done\\n\"; if(V == HshValue(l , r) &amp;&amp; !obtain . count(HshValue(l , r))) { p . push_back(i); obtain . insert(HshValue(l , r)); } } } if(p . size() == 0) { puts(\"NOT POSSIBLE\"); return ; } else if(p . size() == 1) { int _ = p[0]; if(_ == 1) { rep(i , (n + 1) / 2 + 1 , n) putchar(a[i]); return ; } else if(_ == n) { rep(i , 1 , n / 2) putchar(a[i]); return ; } else if(_ == (n + 1) / 2) { rep(i , 1 , n / 2) putchar(a[i]); return ; } else if(_ &gt; (n + 1) / 2) { rep(i , 1 , n / 2) putchar(a[i]); return ; } else if(_ &lt; (n + 1) / 2) { rep(i , (n + 1) / 2 + 1 , n) putchar(a[i]); return ; } return ; } else if(p . size() &gt; 1) { puts(\"NOT UNIQUE\"); return ; }}int main(){ #ifdef lmy int nol_cl = clock(); #endif solve(); // did you forget to undefine Lmy ? #ifdef lmy printf(\"\\nTime: %dms\\n\", int((clock() - nol_cl) / (double)CLOCKS_PER_SEC * 1000)); #endif return 0;}","link":"/2019/03/10/Baltic2004-Friends-题解/"},{"title":"[SCOI2009]windy数 题解","text":"数位dp模板题。 $dp[t][p]$表示还剩$t$位，上一位填的是$p$的方案数。那么转移就是$dp[t][p] = \\sum dp[t-1][q], abs(p-q) \\geq 2$.这里采用dls的可读性极高的写法。举个例子，如果我们要计算$[1,3323]$的答案，那么先把$[1,999]$的答案整段算完。然后剩下的一位一位卡着算就行了。具体见代码，如果实在不懂可以画图理解。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869/** * @Author: Mingyu Li * @Date: 2019-03-10T09:32:31+08:00 * @Email: class11limingyu@126.com * @Filename: [SCOI2009]windy数.cpp * @Last modified by: Mingyu Li * @Last modified time: 2019-03-10T10:19:58+08:00 */#include &lt;bits/stdc++.h&gt;#define tpname typename#define Go(i , x , y) for(register int i = x; i &lt;= y; i++)#define God(i , y , x) for(register int i = y; i &gt;= x; i--)typedef long long LL;typedef long double ld;typedef unsigned long long ULL;template &lt; tpname T &gt; void sc(T&amp; t) { char c = getchar(); T x = 1; t = 0; while(!isdigit(c)) {if(c == '-') x = -1; c = getchar();} while(isdigit(c)) t = t * 10 + c - '0' , c = getchar();t *= x;}template &lt; tpname T , tpname... Args &gt; void sc(T&amp; t , Args&amp;... args) {sc(t); sc(args...);}template &lt; tpname T &gt; T mul(T x , T y , T _) { x %= _,y %= _; return ((x * y - (T)(((ld)x * y + 0.5) / _) * _) % _ + _) % _;}int d[20] , l , r;int dp[20][20];int F(int k , int p) { if(dp[k][p] != -1) return dp[k][p]; if(k == 0) return dp[k][p] = 1; int ans = 0; Go(q , 0 , 9) { if(abs(p - q) &gt;= 2) ans += F(k-1 , q); } return dp[k][p] = ans;}int cal(int x) { int m = 0; while(x) { d[m] = x%10; x /= 10; m++; } int ans = 0; God(i , m-1 , 1) { Go(j , 1 , 9) ans += F(i-1 , j); // 整段 } int pre = -100; God(i , m-1 , 0) { Go(j , (i == m-1) ? 1 : 0 , d[i] - 1) { // 卡着边界 if(abs(pre - j) &gt;= 2) ans += F(i , j); } if(abs(pre - d[i]) &lt; 2) break; pre = d[i]; // 钦定一位之后继续 } return ans;}int main() { memset(dp , -1 , sizeof(dp)); std::cin &gt;&gt; l &gt;&gt; r; // cal 计算的是开区间 std::cout &lt;&lt; cal(r+1) - cal(l) &lt;&lt; std::endl; return 0;}","link":"/2019/03/10/SCOI2009-windy数-题解/"},{"title":"[ZJOI2014]力 题解","text":"题意： 发现Ei如果给出了Fi就很好算，所以目标其实是算Fi.首先我们令$F_j=A_j-B_j$.其中A_j=\\sum_{ij}\\frac{q_iq_j}{(i-j)^2}.考虑将第一个式子变形为 A_j=\\sum_{i=0}^{j-1}\\frac{q_iq_j}{(i-j)^2}.由乘法分配律，可以将$q_j$单拎出来，得： A_j=q_j\\times \\sum_{i=0}^{j-1}\\frac{q_i}{(i-j)^2}.由于$(i-j)^2=(j-i)^2$，所以考虑这样一个函数： g(x)=\\frac{1}{x^2}.然后就会发现可以把 \\frac{q_i}{(i-j)^2}变形为 q_ig(j-i).带回原式，得到：A_j=q_j\\times \\sum_{i=0}^{j-1}q_ig(j-i).不难发现后面的那坨东西类似于多项式乘法，但是少了一项，可以手动将$g(0)=0$.然后…这就是个多项式乘法的典型形式！可以用$\\text{FFT}$解决！同理也可以化简$B_j$. B_j=\\sum_{i=j+1}^{n-1} \\frac{q_iq_j}{(i-j)^2}B_j=q_j\\sum_{i=j+1}^{n} \\frac{q_i}{(i-j)^2}然后突然发现…这东西和$A_j$的计算方法不大一样!咋整？瞬间考虑-&gt;反转q序列！变成 \\sum_{i=0}^{j-1}\\frac{q'_i}{(i-j)^2}.然后把这个式子搞一下，变成 \\sum_{i=0}^{j-1}q'_ig(j-i)发现这个式子本质上就是$A_j$，就能做了。","link":"/2019/03/09/ZJOI2014-力-题解/"},{"title":"[SCOI2010]传送带 题解","text":"比较神的一道题，以前没有接触过三分套三分… 介绍一下我的做法。 首先，碰见这种题，第一眼一般都不知道从何下手。这时候观察题目的性质，发现所走的路径一定是$A\\Rightarrow X\\Rightarrow Y\\Rightarrow D$，其中$X\\in [A,B],Y\\in[C,D].$所以很容易想到一个暴力算法：把每一对$[x,y]$都枚举一遍即可。但是这样的时间复杂度太高了，所以需要考虑别的办法。 在手算模拟之后，可以发现$[x,y]$的枚举都是有规律性的，是一个类似函数的变化。所以考虑三分。 那么怎么三分呢？ 考虑问题的简化版。给你一个点，一条线段，求到哪个点最快，各种定义依据原问题的定义。 这时候很简单，很明显就是一个函数，可以三分。 那么会发现，如果这个函数有单调性，那么问题的简化版也一定具有单调性。也就是说解也是有单调性的。 所以我们可以先三分$X$,再三分$Y$，最后选择一个最优解即可。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788#pragma GCC optimize(\"O2\")#include &lt;bits/stdc++.h&gt;#define PI 3.14159265#define DO_NOT_USE_SCANF ios::sync_with_stdio(0)#define PQ priority_queue#define lowbit(x) ((x) &amp; (-x))#define lmy#ifdef lmy #define DEBUG printf(\"Passing [%s] in LINE %d...\\n\" , __FUNCTION__ , __LINE__)#endiftypedef long long ll;typedef unsigned long long ull;using namespace std;inline void read(int &amp;x) { int f = 1;x = 0;char ch = getchar(); while(ch &lt; '0' || ch &gt; '9') {if(ch == '-') f = -1; ch = getchar();} while(ch &gt;= '0' &amp;&amp; ch &lt;= '9') {x = x * 10 + ch - '0'; ch = getchar();} x *= f;}inline void readll(ll &amp;x) { ll f = 1;x = 0;char ch = getchar(); while(ch &lt; '0' || ch &gt; '9') {if(ch == '-') f = -1; ch = getchar();} while(ch &gt;= '0' &amp;&amp; ch &lt;= '9') {x = x * 10 + ch - '0'; ch = getchar();} x *= f;}struct Point { double x , y;};Point a , b , c , d;double p , q , r;const double eps = 1e-6;double dist(Point a , Point b) { return sqrt((a . x - b . x) * (a . x - b . x) + (a . y - b . y) * (a . y - b . y));}double f(Point x , Point y) { return dist(a , x) / p + dist(x , y) / r + dist(y , d) / q;}double task(Point x) { Point l = c , r = d; while(dist(l , r) &gt; eps) { Point delta = (Point){(r . x - l . x) / 3 , (r . y - l . y) / 3}; Point lmid = (Point){l . x + delta . x , l . y + delta . y}; Point rmid = (Point){r . x - delta . x , r . y - delta . y}; if(f(x , rmid) - f(x , lmid) &gt; eps) r = rmid; else l = lmid; } return f(x , l);}void solve() { scanf(\"%lf%lf%lf%lf\" , &amp;a . x , &amp;a . y , &amp;b . x , &amp;b . y); scanf(\"%lf%lf%lf%lf\" , &amp;c . x , &amp;c . y , &amp;d . x , &amp;d . y); scanf(\"%lf%lf%lf\" , &amp;p , &amp;q , &amp;r); Point l = a , r = b; while(dist(l , r) &gt; eps) { Point delta = (Point){(r . x - l . x) / 3 , (r . y - l . y) / 3}; Point lmid = (Point){l . x + delta . x , l . y + delta . y}; Point rmid = (Point){r . x - delta . x , r . y - delta . y}; if(task(rmid) - task(lmid) &gt; eps) r = rmid; else l = lmid; } cout &lt;&lt; fixed &lt;&lt; setprecision(2) &lt;&lt; task(l) &lt;&lt; endl; return;}int main(){ #ifdef lmy int nol_cl = clock(); #endif solve(); // did you forget to undefine Lmy ? #ifdef lmy printf(\"\\nTime: %dms\\n\", int((clock() - nol_cl) / (double)CLOCKS_PER_SEC * 1000)); #endif return 0;}","link":"/2019/03/10/SCOI2010-传送带-题解/"},{"title":"Hello World","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","link":"/2019/03/07/hello-world/"},{"title":"你好.","text":"Hello.Hello.markdon$a+b=c$ $c_k=\\sum _{i=0}^{n-1}(\\omega_{n}^{-k})^i\\times y_i.$ lim_{1\\to+\\infty}P(|\\frac{1}{n}\\sum_i^nX_i-\\mu|","link":"/2019/03/07/你好/"},{"title":"[清华集训2015]Light Bulb 题解","text":"可以观察题目中隐含的单调性来解决本题。 观察到可以把图中的$L$分成两部分：一部分是投影到地上的，而另一部分是投影到墙上的。 位置离墙越近，地上的投影就会变短，同时墙上的投影也会变长。 但是本题的答案并不是一个一次函数，因为一开始墙上的投影一段时间内都为$0$（影子太短），所以并不能直接一次函数求解。 所以可以直接正常三分，函数直接快速维护一下即可。 复杂度约等于$\\Theta(Tlogd)$ ? （不会证，算了…） 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172#pragma GCC optimize(\"O2\")#include &lt;bits/stdc++.h&gt;#define PI 3.14159265#define DO_NOT_USE_SCANF ios::sync_with_stdio(0)#define PQ priority_queue#define lowbit(x) ((x) &amp; (-x))//#define lmy#ifdef lmy #define DEBUG printf(\"Passing [%s] in LINE %d...\\n\" , __FUNCTION__ , __LINE__)#endiftypedef long long ll;typedef unsigned long long ull;using namespace std;inline void read(int &amp;x) { int f = 1;x = 0;char ch = getchar(); while(ch &lt; '0' || ch &gt; '9') {if(ch == '-') f = -1; ch = getchar();} while(ch &gt;= '0' &amp;&amp; ch &lt;= '9') {x = x * 10 + ch - '0'; ch = getchar();} x *= f;}inline void readll(ll &amp;x) { ll f = 1;x = 0;char ch = getchar(); while(ch &lt; '0' || ch &gt; '9') {if(ch == '-') f = -1; ch = getchar();} while(ch &gt;= '0' &amp;&amp; ch &lt;= '9') {x = x * 10 + ch - '0'; ch = getchar();} x *= f;}double H , h , D;const double eps = 1e-7;double f(double mid) { double straight = mid / (H - h) * h; if(straight + mid - D &gt; eps) { straight = D - mid; } // h - delta * (straight / mid) // delta : H - h double delta = H - h; double up = h - delta * (straight / mid); if(0 - up &gt; eps) up = 0; return straight + up;}void solve() { scanf(\"%lf%lf%lf\" , &amp;H , &amp;h , &amp;D); double l = 0 , r = D; while(r - l &gt; eps) { double lmid = l + (r - l) / 3 , rmid = r - (r - l) / 3; if(f(rmid) - f(lmid) &gt; eps) l = lmid; else r = rmid; } cout &lt;&lt; fixed &lt;&lt; setprecision(3) &lt;&lt; f(l) &lt;&lt; endl; return;}int main(){ #ifdef lmy int nol_cl = clock(); #endif int T; read(T); while(T--) { solve(); } // did you forget to undefine Lmy ? #ifdef lmy printf(\"\\nTime: %dms\\n\", int((clock() - nol_cl) / (double)CLOCKS_PER_SEC * 1000)); #endif return 0;}","link":"/2019/03/10/清华集训2015-Light-Bulb-题解/"},{"title":"FFT详解","text":"用于计算一类朴素卷积问题。 笔者学习的是这份博客内容中可能有很多相同之处，敬请谅解。 现在要计算两个一元$n$次多项式$F(x)$与$G(x)$的乘积，如何计算？前置知识：多项式的表示方法一. 系数表示法对于一个$n$次多项式$F(x)$，它可以被表示成 F(x) = a_nx^n+a_{n-1}x^{n-1}+...+a_1x^1+a_0x^0.更加形式化的来说，它可以表示成 F(x) = \\sum_{i=0}^{n} a_ix^i.举个例子，2次多项式，其中$a_0=1,a_1=2,a_2=1$那么$F(x)=1x^2+2x+1.$这样即可通俗的表示出一个$n$次多项式。二. 点值表示法众所周知，两个点确定一个一次函数，三个点确定一个二次函数。所以，$n+1$个点确定一个一元$n$次多项式。所以我们可以通过$n+1$个点来表示它。那么相乘之后的点值如何计算？比如说两个2次多项式$F(x)=x^2+2x+1$（红色）与$G(x)=3x^2-4x-2$（蓝色），它们的图像如图所示：那么观察图中$x=1$时的情况。此时$F(1)=4,G(1)=-3.$所以，显然，$F(1)\\times G(1)=-12$.也就是说在$Z=FG$这一多项式内，带入$1$，得到的结果是$-12$.等等，好像有哪里不对。如果说$Z=FG$的话，那么Z的次数应该是$2n$.那$Z$需要$2n+1$个点来确定。但是原来只需要$n+1$个点，咋办？很简单，在原来的多项式里每个都多加$n$个点即可。反正多项式已知。这样就可以用点值来进行操作。也就是说先转成点值，再一乘，再转回来，就是计算流程。但是好像还是很慢。那么如何优化呢?复数部分复数，即形如$a+bi$的数，其中$i^2=-1.$ $a$称为实部，$bi$称为虚部。或者说：在一个数轴上（只有x轴），我们可以表示出任何实数。那么，多加一维（y轴），也就是类似于平面直角坐标系一样，我们就可以表示出任意一个复数。所以我们把这个坐标系叫做复平面，其中x轴称为实轴，y轴称为虚轴。复数运算复数相加：实部相加，虚部相加，例如 (a+bi)+(c+di)=(a+c)+(b+d)i.复数相减：同理。 (a+bi)-(c+di)=(a-c)+(b-d)i.复数相乘：像一次多项式一样相乘。 注意$i^2=-1$. (a+bi)(c+di)=ac+(ad+bc)i-bd=(ac-bd)+(ad+bc)i.复数相除：相信大家都学过共轭根式。同样的，复数也有共轭。即：$a+bi$的共轭为$a-bi$。这两个复数卡乘在一起一定是个实数。即 (a+bi)(a-bi)=a^2-(bi)^2=a^2+b^2.所以再除的时候，将分子分母同乘分母的共轭，就可以将分母有理化。即 \\frac{a+bi}{c+di}=\\frac{(a+bi)(c-di)}{c^2+d^2}=\\frac{ac+bd}{c^2+d^2}+\\frac{bc-ad}{c^2+d^2}i.复数逆元： \\frac{1}{a+bi}=\\frac{a}{a^2+b^2}-\\frac{b}{a^2+b^2}i.同样的，复数运算在复平面内也有一定规律可循。考虑在复平面内的两个复数：（借张图） 表示的是复数$(1+4i)$与复数$(3+2i)$相乘所得的结果：$(-5+14i)$。设其中$(5,0)$点为位置$P$，则$\\angle{POC}=\\angle{BOA}.$还有：$\\overline{OB}\\times\\overline{OC}=\\overline{OA}.$第二个证明：勾股定理。先把$i$消掉。$\\overline{OB}^2=a^2+b^2.$ $\\overline{OC}^2=c^2+d^2.$$\\overline{OB}^2\\times \\overline{OC}^2=(a^2+b^2)(c^2+d^2)=a^2c^2+a^2d^2+b^2c^2+b^2d^2.$$\\overline{OA}^2=(ac-bd)^2+(ad+bc)^2=a^2c^2+a^2d^2+b^2c^2+b^2d^2.$得证。我们将复数中，复数向量的长度称为模长，向量与x轴正方向的夹角称为幅角。根据上面的东西：复数相乘时，模长相乘，幅角相加。单位根一个n次的单位根即为方程$x^n=1$的复数解。考虑这样一个图：其中圆上的所有复数模长都是1，这个圆称为单位圆。考虑$|x|$的取值范围：如果$|x|","link":"/2019/03/08/FFT详解/"},{"title":"CodeForces Round 545(div 2) 题解","text":"跟个sb一样比赛链接今天来改题了。 A题意：找出最长的一段区间使得区间长度是偶数，且区间前一半只有一种数，后一半只有一种数。 $a[i] \\in [1,2], n \\leq 100000$. A solution解：考虑分段。 123举个例子：[1 2 2 1 2 2 2 1 1 2 1]按相同的值分为一段之后就会变成[1 | 2 2 | 1 | 2 2 2 | 1 1 | 2 | 1] 显然目标区间一定会在相邻的两个段里，正确性显然。于是直接计算即可。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546/** * @Author: Mingyu Li * @Date: 2019-03-08T17:07:17+08:00 * @Email: class11limingyu@126.com * @Filename: c1138A.cpp * @Last modified by: Mingyu Li * @Last modified time: 2019-03-09T09:16:10+08:00 */#include &lt;bits/stdc++.h&gt;#define tpname typename#define Go(i , x , y) for(register int i = x; i &lt;= y; i++)#define God(i , y , x) for(register int i = y; i &gt;= x; i--)typedef long long LL;typedef long double ld;typedef unsigned long long ULL;template &lt; tpname T &gt; void sc(T&amp; t) { char c = getchar(); T x = 1; t = 0; while(!isdigit(c)) {if(c == '-') x = -1; c = getchar();} while(isdigit(c)) t = t * 10 + c - '0' , c = getchar();t *= x;}template &lt; tpname T , tpname... Args &gt; void sc(T&amp; t , Args&amp;... args) {sc(t); sc(args...);}template &lt; tpname T &gt; T mul(T x , T y , T _) { x %= _,y %= _; return ((x * y - (T)(((ld)x * y + 0.5) / _) * _) % _ + _) % _;}const int N = 100000 + 10;int pref[3][N] , suf[3][N];int n , ans = 0 , t[N];int main() { sc(n); Go(i,1,n) sc(t[i]); std::vector &lt; int &gt; v; int cnt = 1; Go(i , 2 , n+1) { if(t[i] != t[i - 1]) { v.push_back(cnt); cnt = 0; } cnt++; } Go(i , 0 , (int)v.size() - 2) ans = std::max(ans , std::min(v[i] , v[i + 1]) * 2); std::cout &lt;&lt; ans &lt;&lt; \" \\n\"; return 0;} B题意：给定一张$2$行$n$列的表格$A$.$A[i][j]$代表第$j$个人擅不擅长项目$i$.要求将$n$个人分成2组，每组$n/2$个人。（保证$n$是偶数）并满足第一组擅长项目1的人数=第二组擅长项目2的人数。输出方案。$n \\leq 5000$. B solution解：下文中将默认$(i,j)$为是否擅长项目1与项目2。看起来好像很难下手，但是只需要枚举即可。枚举第一组中$(1,0)$的人数与$(1,1)$的人数。 接着，第一组擅长项目1的人数就确定了，第二组$(1,1)$的人数也确定了，那就可以确定第二组$(0,1)$的人数了。第二组确定了，第一组也能确定。于是第一组的$(0,0)$人数也确定了。第二组随之确定。如果所有人数都合法就输出。如果没有任何一组人数合法，输出$-1$. 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162/** * @Author: Mingyu Li * @Date: 2019-03-08T17:51:24+08:00 * @Email: class11limingyu@126.com * @Filename: c1138B.cpp * @Last modified by: Mingyu Li * @Last modified time: 2019-03-09T10:47:22+08:00 */#include &lt;bits/stdc++.h&gt;#define tpname typename#define Go(i , x , y) for(register int i = x; i &lt;= y; i++)#define God(i , y , x) for(register int i = y; i &gt;= x; i--)typedef long long LL;typedef long double ld;typedef unsigned long long ULL;template &lt; tpname T &gt; void sc(T&amp; t) { char c = getchar(); T x = 1; t = 0; while(!isdigit(c)) {if(c == '-') x = -1; c = getchar();} while(isdigit(c)) t = t * 10 + c - '0' , c = getchar();t *= x;}template &lt; tpname T , tpname... Args &gt; void sc(T&amp; t , Args&amp;... args) {sc(t); sc(args...);}template &lt; tpname T &gt; T mul(T x , T y , T _) { x %= _,y %= _; return ((x * y - (T)(((ld)x * y + 0.5) / _) * _) % _ + _) % _;}int n;std::string a , b;std::vector &lt; int &gt; v00 , v01 , v10 , v11;int main() { v00.clear(); v11.clear(); v01.clear(); v10.clear(); std::cin &gt;&gt; n; std::cin &gt;&gt; a &gt;&gt; b; a = \"%\" + a; b = \"%\" + b; Go(i , 1 , n) { if(a[i] == '1' &amp;&amp; b[i] == '1') v11.push_back(i); else if(a[i] == '0' &amp;&amp; b[i] == '0') v00.push_back(i); else if(a[i] == '0' &amp;&amp; b[i] == '1') v01.push_back(i); else if(a[i] == '1' &amp;&amp; b[i] == '0') v10.push_back(i); } Go(s10 , 0 , (int)(v10.size())) Go(s11 , 0 , (int)(v11.size())) { if(s10 + s11 &gt; n/2) continue; // 选完之后 剩下的s10和s11进入第二组 // 对答案有贡献的只有s11 int g2_s01 = s10 + 2 * s11 - (int)((int)(v11.size())); int g1_s01 = (int)(v01.size()) - g2_s01; if(g2_s01 &gt;= 0 &amp;&amp; g2_s01 &lt;= (int)(v01.size())) { int g1_s00 = n/2 - g1_s01 - s10 - s11; if(g1_s00 &gt;= 0 &amp;&amp; g1_s00 &lt;= (int)(v00.size())) { Go(i , 0 , s11 - 1) std::cout &lt;&lt; v11[i] &lt;&lt; \" \"; Go(i , 0 , s10 - 1) std::cout &lt;&lt; v10[i] &lt;&lt; \" \"; Go(i , 0 , g1_s01 - 1) std::cout &lt;&lt; v01[i] &lt;&lt; \" \"; Go(i , 0 , g1_s00 - 1) std::cout &lt;&lt; v00[i] &lt;&lt; \" \"; puts(\"\"); return 0; } } } puts(\"-1\"); return 0;} C给定一个$n\\times m$大小的表格。要求对于每一个位置$(i,j)$,求出$ans(i,j)$.其中$ans(i,j)$表示将第i行和第j列的某些数更改后使得在满足行内所有数相对大小关系不变，列内所有数相对大小关系不变的情况下，行列内最大值 的最小值。 $n,m \\leq 1000$. 时限2s. C solution解：发现除了$a[i][j]$一个交界点之外，行列之间是独立的。所以，只需要确定$a[i][j]$重新排列之后的排名即可。这玩意很好确定。因为行列之间是独立的，所以答案就是 max(行内比a[i][j]小的数的种数,列内比a[i][j]小的数的种数)+1同理，题目要求最小化最大值。由于行列独立，所以最大值的编号就是 a[i][j]排名+max(行内比a[i][j]大的数的种数,列内比a[i][j]大的数的种数)这个东西可以每行每列一起预处理，复杂度$\\Theta(n^2 log(n))$.12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364/** * @Author: Mingyu Li * @Date: 2019-03-09T10:47:43+08:00 * @Email: class11limingyu@126.com * @Filename: c1138C.cpp * @Last modified by: Mingyu Li * @Last modified time: 2019-03-09T11:57:03+08:00 */#include &lt;bits/stdc++.h&gt;#define tpname typename#define Go(i , x , y) for(register int i = x; i &lt;= y; i++)#define God(i , y , x) for(register int i = y; i &gt;= x; i--)typedef long long LL;typedef long double ld;typedef unsigned long long ULL;template &lt; tpname T &gt; void sc(T&amp; t) { char c = getchar(); T x = 1; t = 0; while(!isdigit(c)) {if(c == '-') x = -1; c = getchar();} while(isdigit(c)) t = t * 10 + c - '0' , c = getchar();t *= x;}template &lt; tpname T , tpname... Args &gt; void sc(T&amp; t , Args&amp;... args) {sc(t); sc(args...);}template &lt; tpname T &gt; T mul(T x , T y , T _) { x %= _,y %= _; return ((x * y - (T)(((ld)x * y + 0.5) / _) * _) % _ + _) % _;}const int N = 1000 + 10;int ans[N][N];int n , m , it;int a[N][N] , b[N];int ans1[N][N] , ans2[N][N] , big1[N][N] , big2[N][N];int p = 0;int main() { sc(n , m); Go(i , 1 , n) Go(j , 1 , m) sc(a[i][j]); Go(i , 1 , n) { p = 0; Go(j , 1 , m) b[++p] = a[i][j]; std::sort(b + 1 , b + p + 1); p = std::unique(b + 1 , b + p + 1) - (b + 1); Go(j , 1 , m) { ans1[i][j] = std::lower_bound(b+1 , b+p+1 , a[i][j]) - b; big1[i][j] = p - ans1[i][j]; } } Go(i , 1 , m) { p = 0; Go(j , 1 , n) b[++p] = a[j][i]; std::sort(b + 1 , b + p + 1); p = std::unique(b + 1 , b + p + 1) - (b + 1); Go(j , 1 , n) { ans2[j][i] = std::lower_bound(b+1 , b+p+1 , a[j][i]) - b; big2[j][i] = p - ans2[j][i]; } } Go(i , 1 , n) { Go(j , 1 , m) printf(\"%d \" , std::max(ans1[i][j] , ans2[i][j]) + std::max(big1[i][j] , big2[i][j])); puts(\"\"); } return 0;} D给定只包含01的字符串$s$和$t$，重排列$s$字符串使得$t$在其中作为子串出现的次数最多。 $|s|,|t| \\leq 500000$. D solution首先考虑最优解一定长成什么样子——一定是一个t串加很多个小节，每加一个小节就会多产生一个$t$子串。有了这部转化就很简单了。容易发现这个小节即为长度为$|t|-border(t)$的$t$串后缀。能输出多少份输出多少份。$border$用$KMP$或$Hash$维护都可以（注意$Hash$被卡） 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990/** * @Author: Mingyu Li * @Date: 2019-03-09T12:54:42+08:00 * @Email: class11limingyu@126.com * @Filename: c1138D.cpp * @Last modified by: Mingyu Li * @Last modified time: 2019-03-09T22:14:16+08:00 */#include &lt;bits/stdc++.h&gt;#define tpname typename#define Go(i , x , y) for(register int i = x; i &lt;= y; i++)#define God(i , y , x) for(register int i = y; i &gt;= x; i--)typedef long long LL;typedef long double ld;typedef unsigned long long ULL;template &lt; tpname T &gt; void sc(T&amp; t) { char c = getchar(); T x = 1; t = 0; while(!isdigit(c)) {if(c == '-') x = -1; c = getchar();} while(isdigit(c)) t = t * 10 + c - '0' , c = getchar();t *= x;}template &lt; tpname T , tpname... Args &gt; void sc(T&amp; t , Args&amp;... args) {sc(t); sc(args...);}template &lt; tpname T &gt; T mul(T x , T y , T _) { x %= _,y %= _; return ((x * y - (T)(((ld)x * y + 0.5) / _) * _) % _ + _) % _;}const int N = 500000 + 5;const ULL P1 = 13331;const ULL P2 = 19260817;const ULL MOD1 = 314159;const ULL MOD2 = (1000000007);ULL Hash1[N] , Hash2[N] , pw1[N] , pw2[N];int cnt[2] , cnt1[2] , n , m;char a[N + 5] , b[N + 5];void Prework() { pw1[0] = pw2[0] = 1; Go(i , 1 , n) pw1[i] = pw1[i - 1] * P1 % MOD1 , pw2[i] = pw2[i - 1] * P2 % MOD2; Go(i , 1 , n) { Hash1[i] = (Hash1[i - 1] * P1 % MOD1 + b[i]) % MOD1; Hash2[i] = (Hash2[i - 1] * P2 % MOD2 + b[i]) % MOD2; }}bool same(int l1, int r1, int l2, int r2) { return ((Hash2[r2] + MOD2 - Hash2[l2 - 1] * pw2[r2 - l2 + 1] % MOD2) % MOD2 == (Hash2[r1] + MOD2 - Hash2[l1 - 1] * pw2[r1 - l1 + 1] % MOD2) % MOD2 &amp;&amp; (Hash1[r2] + MOD1 - Hash1[l2 - 1] * pw1[r2 - l2 + 1] % MOD1) % MOD1 == (Hash1[r1] + MOD1 - Hash1[l1 - 1] * pw1[r1 - l1 + 1] % MOD1) % MOD1);}int LCP() { int ans = 0; Go(i , 1 , n-1) { if(same(1 , i , n-i+1 , n)) ans = i; } return ans;}int main() { scanf(\"%s\" , (a + 1)); scanf(\"%s\" , (b + 1)); m = strlen(a + 1) , n = strlen(b + 1); Prework(); Go(i , 1 , m) cnt[a[i] - '0']++; Go(i , 1 , n) cnt1[b[i] - '0']++; int fill = n - LCP(); if(cnt[0] &lt; cnt1[0] || cnt[1] &lt; cnt1[1]) { Go(i , 1 , m) putchar(a[i]); puts(\"\"); return 0; } cnt[0] -= cnt1[0] , cnt[1] -= cnt1[1]; cnt1[0] = cnt1[1] = 0; Go(i , n - fill + 1 , n) ++cnt1[b[i] - '0']; Go(i , 1 , n) putchar(b[i]); Go(i , 1 , 2147483647) { bool f = 1; Go(j , n - fill + 1 , n) { if(!cnt[b[j] - '0']) { f = 0; break; } putchar(b[j]); cnt[b[j] - '0']--; } if(!f) break; } if(cnt[1]) Go(i , 1 , cnt[1]) putchar('1'); if(cnt[0]) Go(i , 1 , cnt[0]) putchar('0'); return 0;}","link":"/2019/03/09/CF545-div-2-题解/"}],"tags":[{"name":"数学","slug":"数学","link":"/tags/数学/"},{"name":"FFT","slug":"FFT","link":"/tags/FFT/"},{"name":"并查集","slug":"并查集","link":"/tags/并查集/"},{"name":"拓扑排序","slug":"拓扑排序","link":"/tags/拓扑排序/"},{"name":"Hash","slug":"Hash","link":"/tags/Hash/"},{"name":"三分法","slug":"三分法","link":"/tags/三分法/"},{"name":"CodeForces","slug":"CodeForces","link":"/tags/CodeForces/"},{"name":"数位dp","slug":"数位dp","link":"/tags/数位dp/"}],"categories":[{"name":"题解","slug":"题解","link":"/categories/题解/"},{"name":"算法笔记","slug":"算法笔记","link":"/categories/算法笔记/"}]}