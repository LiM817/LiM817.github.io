{"pages":[{"title":"关于作者","text":"坐标$Beijing, China$，初二咸鱼$OIer$一枚。常常以$\\text{FST-OIer/LiM_817/LiM-817}$等id到处闲逛。下一步计划是把文化课加强以及去省选打个酱油。$QQ:1504094517$.","link":"/about/index.html"},{"title":"友链","text":"LCJ神仙的博客Dilute神仙的博客欢迎交换友链~","link":"/Links/index.html"}],"posts":[{"title":"[BZOJ2194] 快速傅里叶之二 题解","text":"题意：求C_k=\\sum_{k}^{n-1}a_ib_{i-k}.$n \\leq 1e5$. 考虑反转数组$a$，生成新数组$a’$.那么C_k=\\sum_{i=k}^{n-1}a'_{n-1-i}b_{i-k},考虑把$i$改成从$0$开始。那么 C_k=\\sum_{i=0}^{n-k-1}a'_{n-k-1-i}b_i.考虑用$\\text{FFT}$计算卷积的标准形式： C'_x=\\sum_{i=0}^{x}A_{x-i}B_i.考虑$x=n-k-1$时的情况： C'_{n-k-1}=\\sum_{i=0}^{n-k-1}a'_{n-k-1-i}b_i.发现$C’$本质上就是将$C$的前$n$个反转了一下，而$C’$是可以直接计算的。于是，可以直接用$\\text{FFT}$计算出$a’$和$b$的卷积$C’$，再反转一下前$n$项，输出前$n$项即可。12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273#include &lt;bits/stdc++.h&gt;#define REP(i , x , y) for(__typeof(y) i = x; i &lt;= y; i++)#define PER(i , y , x) for(__typeof(x) i = y; i &gt;= x; i--)typedef long long LL;typedef long double ld;typedef unsigned long long ULL;/* do not give up ! try your best! Read the meaning clearly! */template &lt; typename T &gt; void Input(T&amp; t) { char c = getchar(); T x = 1; t = 0; while(!isdigit(c)) {if(c == '-') x = -1; c = getchar();} while(isdigit(c)) t = t * 10 + c - '0' , c = getchar();t *= x;}template &lt; typename T , typename... Args &gt; void Input(T&amp; t , Args&amp;... args) {Input(t); Input(args...);}template &lt; typename T &gt; T mul(T x , T y , T _) {x %= _,y %= _;return ((x * y - (T)(((ld)x * y + 0.5) / _) * _) % _ + _) % _;}using namespace std;const int MAXN = 2097152 + 10;const double Pi = acos(-1.0);int a[MAXN] , b[MAXN] , c[MAXN] , n;static complex &lt; double &gt; A[MAXN] , B[MAXN] , C[MAXN];struct FastFourierTransform { complex &lt; double &gt; omega[MAXN] , omegaInverse[MAXN]; void init(int n) { for(int i = 0; i &lt; n; i++) { omega[i] = complex &lt; double &gt; (cos(2 * Pi / n * i) , sin(2 * Pi / n * i)); omegaInverse[i] = conj(omega[i]); } } void Transform(complex &lt; double &gt; *a , const int n , const complex &lt; double &gt; *omega) { int k = 1; while((1 &lt;&lt; k) &lt; n) ++k; for(int i = 0; i &lt; n; i++) { int t = 0; for(int j = 0;j &lt; k; j++) if(i &amp; (1 &lt;&lt; j)) t |= (1 &lt;&lt; (k - 1 - j)); if(i &lt; t) swap(a[i] , a[t]); } for(int l = 2; l &lt;= n; l &lt;&lt;= 1) { int m = (l &gt;&gt; 1); for(complex &lt; double &gt; *p = a; p != a + n; p += l) { for(int i = 0; i &lt; m; i++) { complex &lt; double &gt; k = omega[n / l * i] * p[m + i]; p[m + i] = p[i] - k; p[i] += k; } } } } void DFT(complex &lt; double &gt; *a , int n) { Transform(a , n , omega); } void IDFT(complex &lt; double &gt; *a , int n) { Transform(a , n , omegaInverse); for(int i = 0; i &lt; n; i++) a[i] /= n; }}FFT;int main() { Input(n); for(int i = 0; i &lt; n; i++) Input(a[i] , b[i]); reverse(a , a + n); for(int i = 0; i &lt; n; i++) A[i].real(a[i]) , B[i].real(b[i]); int N = 1; while(N &lt; 2 * n) N &lt;&lt;= 1; FFT.init(N); FFT.DFT(A , N); FFT.DFT(B , N); for(int i = 0; i &lt; N; i++) C[i] = A[i] * B[i]; FFT.IDFT(C , N); for(int i = 0; i &lt; N; i++) c[i] = static_cast &lt; int &gt; (C[i].real() + 0.5); int cnt = 0; for(int i = 0; i &lt; n; i++) printf(\"%d\\n\" , c[n - 1 - i]); return 0;}","link":"/2019/03/09/BZOJ2194-快速傅里叶之二-题解/"},{"title":"[BJWC2018]第k大斜率 题解","text":"还依稀记得半年前的一次模拟赛，这个题我用暴力拿了50分。旧题重做，现在来谈谈我的做法。 这种问题有个很套路的转化方式——假定一个答案，然后二分答案。比如对于假定的答案$k$，如果$(i,j) (x_i&lt;x_j)$连线斜率$\\geq k$： \\frac{y_j-y_i}{x_j-x_i} \\geq ky_j-y_i\\geq k(x_j - x_i)y_j-y_i\\geq kx_j-kx_iy_j-kx_j-(y_i-kx_i)\\geq0y_j-kx_j\\geq (y_i-kx_i)设$f(i)=y_i-kx_i$，则可以变为$f(i)\\leq f(j)$.结合上面的$x_i&lt;x_j$，不难发现就是一个二维偏序：先按$f$排序，之后树状数组按$x$ query即可。 但是我刚开始竟然忘了二维偏序怎么写12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061/** * @Author: Mingyu Li * @Date: 2019-04-04T17:44:49+08:00 * @Last modified by: Mingyu Li * @Last modified time: 2019-04-04T20:25:23+08:00 */#include &lt;bits/stdc++.h&gt;#define go(i , x , y) for(register int i = x; i &lt;= y; i++)#define god(i , y , x) for(register int i = y; i &gt;= x; i--)using namespace std;#define ll long long#define fi first#define se secondconst int N = 100000 + 5;struct Node { ll x, y, rwx, ans;}a[N];int n,m; ll k;ll b[N] , c[N];bool cmp(const Node&amp; u, const Node&amp;v) { return u.ans == v.ans ? u.rwx &lt; v.rwx : u.ans &lt; v.ans;}int query(int x) { int ans = 0; for(;x; x -= (x &amp; -x)) ans += c[x]; return ans;}int upd(int x , int val) { for(; x&lt;= m; x += (x &amp; -x)) c[x] += val;}bool check(int mid) { go(i,1,n) a[i].ans = a[i].y - 1ll * mid * a[i].x; sort(a+1,a+n+1,cmp); memset(c,0,sizeof(c)); ll sum = 0; go(i,1,n) { sum += query(a[i].rwx - 1); upd(a[i].rwx , 1); } return sum &gt;= k;}int main() { scanf(\"%d%lld\", &amp;n, &amp;k); go(i,1,n) { scanf(\"%lld%lld\", &amp;a[i].x, &amp;a[i].y); b[i] = a[i].x; } sort(b+1, b+n+1); m = unique(b+1,b+n+1) - (b+1); go(i,1,n) a[i].rwx = lower_bound(b+1,b+m+1,a[i].x) - b; int l = -(int)(2e8), r = (int)(2e8) , ans = 0; while(l &lt;= r) { int mid = (l + r) &gt;&gt; 1; if(check(mid)) ans = mid , l = mid + 1; else r = mid - 1; } cout &lt;&lt; ans &lt;&lt; endl; return 0;}","link":"/2019/04/04/BJWC2018-第k大斜率-题解/"},{"title":"CF Round #446 改题","text":"在机房vp了一番div1，就做了一个题， 于是这篇文章就用来改题了。链接：Here A题目：给定一个数列$a$，共$n$项，求最多修改一项的值（必须修改成整数）之后数列中最长严格上升子段的最大长度。 显然，修改比不修改要优，起码不会劣于原来的答案。那么枚举修改哪一项，向两边延申，这部分可以用前缀/后缀和来解决。注意细节，就做完了。 1234567891011121314151617181920212223242526272829303132/** * @Author: Mingyu Li * @Date: 2019-03-26T17:39:28+08:00 * @Last modified by: Mingyu Li * @Last modified time: 2019-03-26T17:42:17+08:00 */#include &lt;bits/stdc++.h&gt;#define Go(i , x , y) for(register int i = x; i &lt;= y; i++)#define God(i , y , x) for(register int i = y; i &gt;= x; i--)const int N = 100000 + 5;int n , a[N];int pre[N] , suf[N];int main() { scanf(\"%d\" , &amp;n); Go(i , 1 , n) scanf(\"%d\" , &amp;a[i]); Go(i , 1 , n) pre[i] = a[i] &gt; a[i - 1] ? pre[i-1] + 1 : 1; God(i , n , 1) suf[i] = (a[i] &lt; a[i + 1]) ? suf[i + 1] + 1 : 1; int max = std::min(2 , n); Go(i , 1 , n) { // for each ai max = std::max(max , pre[i - 1] + 1); max = std::max(max , suf[i + 1] + 1); if(a[i + 1] - a[i - 1] &lt;= 1 &amp;&amp; i != n &amp;&amp; i != 1) continue; if(i == n) max = std::max(max , pre[i - 1] + 1); else if(i == 1) max = std::max(max , suf[i + 1] + 1); else max = std::max(max , pre[i - 1] + suf[i + 1] + 1); } std::cout &lt;&lt; max &lt;&lt; std::endl; return 0;} B题目：给定$n\\times m$的矩阵，每次可以将一行或一列所有数$-p$，代价是没减之前一行/一列的和。要求做k次，求最大代价。 解法比较有意思。考虑只能每次消一行/一列怎么做$\\rightarrow$是可以愉快的优先队列贪心的。那本质上如果限制了消$i$次行，那一定消了$k-i$次列。答案就是$ansrow[i] + anscol[i] + ?$ $ansrow$和$anscol$都比较好算，重点在于$?$是什么。不难发现，这部分其实就是行列相交的部分，这部分$p$都没有被算上，所以$?=i(k-i)p$. 然后暴力枚举i,就做完了。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354/** * @Author: Mingyu Li * @Date: 2019-03-27T18:56:35+08:00 * @Last modified by: Mingyu Li * @Last modified time: 2019-03-27T20:03:55+08:00 */#include &lt;bits/stdc++.h&gt;#define int long long#define Go(i , x , y) for(register int i = x; i &lt;= y; i++)#define God(i , y , x) for(register int i = y; i &gt;= x; i--)const int N = 1000 + 10;int n , m , a[N][N] , k , p , ansrow[N*N] , anscol[N*N];std::priority_queue &lt;int&gt; q1;signed main() { scanf(\"%I64d%I64d%I64d%I64d\" , &amp;n , &amp;m , &amp;k , &amp;p); Go(i , 1 , n) Go(j , 1 , m) scanf(\"%I64d\" , &amp;a[i][j]); Go(i , 1 , n) { int sum = 0; Go(j , 1 , m) sum += a[i][j]; q1.push(sum); } Go(i , 1 , k) { int x = q1.top(); q1.pop(); ansrow[i] = ansrow[i - 1] + x; q1.push(x - m * p); } while(!q1.empty()) q1.pop(); Go(j , 1 , m) { int sum = 0; Go(i , 1 , n) sum += a[i][j]; q1.push(sum); } Go(i , 1 , k) { int x = q1.top(); q1.pop(); anscol[i] = anscol[i - 1] + x; q1.push(x - n * p); } int ans = LLONG_MIN; Go(i , 0 , k) { int a = i , b = k - i; int total = a * b * p; ans = std::max(ans , ansrow[i] + anscol[k - i] - total); } std::cout &lt;&lt; ans &lt;&lt; std::endl; return 0;}","link":"/2019/03/27/CF-Round-446-改题/"},{"title":"[Baltic2004]Friends 题解","text":"题意：对于一个字符串$s$,复制一遍之后得到$e$，在$e$的任何位置插入一个字符形成$u$。给定$u$，求字符串$s$. 字符串哈希。 考虑尝试每一个字符，尝试一下去除这个字符之后剩下的字符串是否能成功分成两部分。 用字符串哈希自带的“拼凑”功能即可。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168#pragma GCC optimize(\"2\")#include &lt;bits/stdc++.h&gt;#define PI 3.14159265#define PQ priority_queue#define lowbit(x) ((x) &amp; (-x))#define rep(i , x , y) for(int (i) = (x) ; (i) &lt;= (y) ; ++i)#define per(i , x , y) for(int (i) = (x) ; (i) &gt;= (y) ; --i)//#define lmy#ifdef lmy #define DEBUG printf(\"Passing [%s] in LINE %d...\\n\" , __FUNCTION__ , __LINE__)#endiftypedef long long ll;typedef unsigned long long ull;using namespace std;inline void read(int &amp;x) { int f = 1;x = 0;char ch = getchar(); while(ch &lt; '0' || ch &gt; '9') {if(ch == '-') f = -1; ch = getchar();} while(ch &gt;= '0' &amp;&amp; ch &lt;= '9') {x = x * 10 + ch - '0'; ch = getchar();} x *= f;}inline void readll(ll &amp;x) { ll f = 1;x = 0;char ch = getchar(); while(ch &lt; '0' || ch &gt; '9') {if(ch == '-') f = -1; ch = getchar();} while(ch &gt;= '0' &amp;&amp; ch &lt;= '9') {x = x * 10 + ch - '0'; ch = getchar();} x *= f;}inline void print(int x) { if (x &lt; 0) putchar('-'), x = -x;if (x &gt; 9) print(x / 10);putchar(x % 10 + 48);}inline void printll(ll x) { if (x &lt; 0) putchar('-'), x = -x;if (x &gt; 9) print(x / 10);putchar(x % 10 + 48);}const int MaxN = 2000000 + 5;const ull bse = 13331;char a[MaxN];int n;ull Pw[MaxN] , Hsh[MaxN];vector &lt;int&gt; p;void HshPre() { Pw[0] = 1; rep(i , 1 , n + 1) Pw[i] = Pw[i - 1] * bse; rep(i , 1 , n) { Hsh[i] = Hsh[i - 1] * bse + (ull)(a[i]); }}ull HshValue(int l , int r) { return Hsh[r] - Hsh[l - 1] * Pw[r - l + 1];}ull Merge(int l , int r , int ql , int qr) { // BaoZheng l , r &lt; ql , qr ull HshValue1 = HshValue(l , r) , HshValue2 = HshValue(ql , qr); return HshValue1 * Pw[qr - ql + 1] + HshValue2;}bool Chksame(int l , int r , int ql , int qr) { return HshValue(l , r) == HshValue(ql , qr);}set &lt;ull&gt; obtain;void solve() { cin &gt;&gt; n; scanf(\"%s\" , (a + 1)); //n = strlen(a + 1); if(!(n % 2)) { puts(\"NOT POSSIBLE\"); return ; } HshPre(); rep(i , 1 , n) { if(i == 1) { if(Chksame(2 , (n + 1) / 2 , (n + 1) / 2 + 1 , n) &amp;&amp; !obtain . count(HshValue(2 , (n + 1) / 2))) { // DEBUG; p . push_back(i); obtain . insert(HshValue(2 , (n + 1) / 2)); } } else if(i == n) { if(Chksame(1 , n / 2 , n / 2 + 1 , n - 1) &amp;&amp; !obtain . count(HshValue(1 , n / 2))) { //DEBUG; p . push_back(i); obtain . insert(HshValue(1 , n / 2)); } } else if(i == (n + 1) / 2) { if(Chksame(1 , n / 2 , n - (n / 2) + 1 , n) &amp;&amp; !obtain . count(HshValue(1 , n / 2))) { p . push_back(i) , obtain . insert(HshValue(1 , n / 2)); } } else if(i &gt; (n + 1) / 2) { int l = 1 , r = n / 2; int pl = r + 1 , pr = i - 1; int ppl = i + 1 , ppr = n; ull V = Merge(pl , pr , ppl , ppr); if(V == HshValue(l , r) &amp;&amp; !obtain . count(HshValue(l , r))) { p . push_back(i); obtain . insert(HshValue(l , r)); } } else if(i &lt; (n + 1) / 2) { int l = n - (n / 2) + 1 , r = n; int pl = 1 , pr = i - 1; int ppl = i + 1 , ppr = l - 1; ull V = Merge(pl , pr , ppl , ppr); //if(i == 3) cout &lt;&lt; V &lt;&lt; \"DBG , \" &lt;&lt; HshValue(l , r) &lt;&lt; \" Done\\n\"; if(V == HshValue(l , r) &amp;&amp; !obtain . count(HshValue(l , r))) { p . push_back(i); obtain . insert(HshValue(l , r)); } } } if(p . size() == 0) { puts(\"NOT POSSIBLE\"); return ; } else if(p . size() == 1) { int _ = p[0]; if(_ == 1) { rep(i , (n + 1) / 2 + 1 , n) putchar(a[i]); return ; } else if(_ == n) { rep(i , 1 , n / 2) putchar(a[i]); return ; } else if(_ == (n + 1) / 2) { rep(i , 1 , n / 2) putchar(a[i]); return ; } else if(_ &gt; (n + 1) / 2) { rep(i , 1 , n / 2) putchar(a[i]); return ; } else if(_ &lt; (n + 1) / 2) { rep(i , (n + 1) / 2 + 1 , n) putchar(a[i]); return ; } return ; } else if(p . size() &gt; 1) { puts(\"NOT UNIQUE\"); return ; }}int main(){ #ifdef lmy int nol_cl = clock(); #endif solve(); // did you forget to undefine Lmy ? #ifdef lmy printf(\"\\nTime: %dms\\n\", int((clock() - nol_cl) / (double)CLOCKS_PER_SEC * 1000)); #endif return 0;}","link":"/2019/03/10/Baltic2004-Friends-题解/"},{"title":"DP水题练习","text":"readmore… c189A:直接dp 注意要赋成极小值c698A:瞎dpc987C:跟dp没啥关系…直接强制j枚举i,k就行了c414B:很妙的一个题。需要转为“刷表”法来解决，这样复杂度就会由调和级数变成nklogn.c1005D:边dp边更新 利用前缀和%3来判断","link":"/2019/03/30/DP水题练习/"},{"title":"[CF628D]Magic Numbers 题解","text":"比较友好的数位$dp$练手题。 设$dp(i,j,k=0/1)$表示还剩$i$位，前几位表示的数$\\equiv\\text{ j (mod m)}$，此位是否为偶数位的数的个数。 如果$k=0$，那么这一位一定不能是$d$。否则一定得是$d$。大力转移即可。边界：$dp(0,0,0/1)=1$. 特别注意本题并不需要高精$+1$操作，只需要特判$b$一个数即可。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596/** * @Author: Mingyu Li * @Date: 2019-03-10T15:39:26+08:00 * @Email: class11limingyu@126.com * @Filename: cf628D.cpp * @Last modified by: Mingyu Li * @Last modified time: 2019-03-10T20:44:04+08:00 */#include &lt;bits/stdc++.h&gt;#define tpname typename#define Go(i , x , y) for(register int i = x; i &lt;= y; i++)#define God(i , y , x) for(register int i = y; i &gt;= x; i--)typedef long long LL;typedef long double ld;typedef unsigned long long ULL;template &lt; tpname T &gt; void sc(T&amp; t) { char c = getchar(); T x = 1; t = 0; while(!isdigit(c)) {if(c == '-') x = -1; c = getchar();} while(isdigit(c)) t = t * 10 + c - '0' , c = getchar();t *= x;}template &lt; tpname T , tpname... Args &gt; void sc(T&amp; t , Args&amp;... args) {sc(t); sc(args...);}template &lt; tpname T &gt; T mul(T x , T y , T _) { x %= _,y %= _; return ((x * y - (T)(((ld)x * y + 0.5) / _) * _) % _ + _) % _;}const int N = 2000 + 5;const int mod = (int)(1e9 + 7);int m , D , p;std::string a,b;int d[2000];// f[i][j][k]:// 还剩i位 前几位组成的数%m = j 是否是偶数位int dp[N][N][2];int f(int i , int j ,int k) { if(dp[i][j][k] != -1) return dp[i][j][k]; if(i == 0) return dp[i][j][k] = j%m == 0 ? 1 : 0; int ans = 0; Go(x , 0 , 9) { if(k == 1 &amp;&amp; x != D) continue; if(k == 0 &amp;&amp; x == D) continue; ans = (ans + f(i-1 , (j*10 + x)%m , k^1)) % mod; } return dp[i][j][k] = ans;}int cal(std::string x) { p = 0; while(!x.empty()) { d[p++] = x.back() - '0'; x.pop_back(); } int op=0 , ans=0; God(i , p-1 , 1) { Go(j , 1 , 9) { if(j == D) continue; ans = (ans + f(i-1 , j%m , 1)) % mod; } } op = 0; int lst = 0; God(i , p-1 , 0) { Go(j , (i == p-1) ? 1 : 0 , d[i] - 1) { if(op == 1 &amp;&amp; j != D) continue; if(op == 0 &amp;&amp; j == D) continue; ans = (ans + f(i , (lst * 10 + j) % m , op^1)) % mod; } if(op == 1 &amp;&amp; d[i] != D) break; if(op == 0 &amp;&amp; d[i] == D) break; op = 1 - op; lst = (lst * 10 + d[i]) % m; } return ans;}int main() { memset(dp , -1 , sizeof(dp)); sc(m , D); std::cin &gt;&gt; a &gt;&gt; b; int ans = (cal(b) - cal(a) + mod) % mod; bool f = 1 , op = 0; int m1 = 0; Go(i , 0 , (int)(b.size()) - 1) { if(op == 0 &amp;&amp; b[i]-'0'== D) f = 0; if(op == 1 &amp;&amp; b[i]-'0' != D) f = 0; op = op^1; } for(char x : b) m1 = (m1 * 10 + x - '0')%m; ans += (f &amp; (m1 == 0)); ans %= mod; std::cout &lt;&lt; ans &lt;&lt; std::endl; return 0;}","link":"/2019/03/11/CF628D-Magic-Numbers-题解/"},{"title":"[CF55D]Beautiful Number 题解","text":"数位dp进阶题。 如果一个数能被它的所有数位整除，那么他一定可以被那些数位的$LCM$整除。发现$1-9$的$LCM$是$2520$，所以这些数位的$LCM$一定是$2520$的约数，正确性显然。于是就有：如果这个数$mod\\ 2520$能被数位的$LCM$整除，那么这个数同样也能。所以设计状态为：$dp[i][j][k]$为还剩i位没填，之前几位形成的数$mod\\ 2520 = j$，之前所有数位$LCM$为$k$的数的个数。 转移就直接转移就行了。同时发现空间会爆炸，压缩一下$k$就可以了。 计算请参照我的另一篇博客：SCOI2009 windy数。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130/** * @Author: Mingyu Li * @Date: 2019-03-10T10:20:16+08:00 * @Email: class11limingyu@126.com * @Filename: CF55D.cpp * @Last modified by: Mingyu Li * @Last modified time: 2019-03-10T13:12:06+08:00 */#include &lt;bits/stdc++.h&gt;#define tpname typename#pragma GCC optimize(\"O2\")#pragma GCC optimize(\"Ofast\")#pragma GCC optimize(\"inline\")#pragma GCC optimize(\"-fgcse\")#pragma GCC optimize(\"-fgcse-lm\")#pragma GCC optimize(\"-fipa-sra\")#pragma GCC optimize(\"-ftree-pre\")#pragma GCC optimize(\"-ftree-vrp\")#pragma GCC optimize(\"-fpeephole2\")#pragma GCC optimize(\"-ffast-math\")#pragma GCC optimize(\"-fsched-spec\")#pragma GCC optimize(\"unroll-loops\")#pragma GCC optimize(\"-falign-jumps\")#pragma GCC optimize(\"-falign-loops\")#pragma GCC optimize(\"-falign-labels\")#pragma GCC optimize(\"-fdevirtualize\")#pragma GCC optimize(\"-fcaller-saves\")#pragma GCC optimize(\"-fcrossjumping\")#pragma GCC optimize(\"-fthread-jumps\")#pragma GCC optimize(\"-funroll-loops\")#pragma GCC optimize(\"-fwhole-program\")#pragma GCC optimize(\"-freorder-blocks\")#pragma GCC optimize(\"-fschedule-insns\")#pragma GCC optimize(\"inline-functions\")#pragma GCC optimize(\"-ftree-tail-merge\")#pragma GCC optimize(\"-fschedule-insns2\")#pragma GCC optimize(\"-fstrict-aliasing\")#pragma GCC optimize(\"-fstrict-overflow\")#pragma GCC optimize(\"-falign-functions\")#pragma GCC optimize(\"-fcse-skip-blocks\")#pragma GCC optimize(\"-fcse-follow-jumps\")#pragma GCC optimize(\"-fsched-interblock\")#pragma GCC optimize(\"-fpartial-inlining\")#pragma GCC optimize(\"no-stack-protector\")#pragma GCC optimize(\"-freorder-functions\")#pragma GCC optimize(\"-findirect-inlining\")#pragma GCC optimize(\"-frerun-cse-after-loop\")#pragma GCC optimize(\"inline-small-functions\")#pragma GCC optimize(\"-finline-small-functions\")#pragma GCC optimize(\"-ftree-switch-conversion\")#pragma GCC optimize(\"-foptimize-sibling-calls\")#pragma GCC optimize(\"-fexpensive-optimizations\")#pragma GCC optimize(\"-funsafe-loop-optimizations\")#pragma GCC optimize(\"inline-functions-called-once\")#pragma GCC optimize(\"-fdelete-null-pointer-checks\")#define Go(i , x , y) for(register int i = x; i &lt;= y; i++)#define God(i , y , x) for(register int i = y; i &gt;= x; i--)typedef long long LL;typedef long double ld;typedef unsigned long long ULL;template &lt; tpname T &gt; void sc(T&amp; t) { char c = getchar(); T x = 1; t = 0; while(!isdigit(c)) {if(c == '-') x = -1; c = getchar();} while(isdigit(c)) t = t * 10 + c - '0' , c = getchar();t *= x;}template &lt; tpname T , tpname... Args &gt; void sc(T&amp; t , Args&amp;... args) {sc(t); sc(args...);}template &lt; tpname T &gt; T mul(T x , T y , T _) { x %= _,y %= _; return ((x * y - (T)(((ld)x * y + 0.5) / _) * _) % _ + _) % _;}LL t;LL l , r , m , d[25];LL dp[20][2525][55];LL num[2525];LL ca1l(LL x) { return x &lt; 2520 ? x : x - (x / 2520) * 2520;}// dp[x][y][z]: 还剩x位 前面数%2520 = y 前面所有数lcm=zLL lcm(LL x , LL y) { if(x &lt; y) std::swap(x,y); return !y ? x : x/std::__gcd(x,y)*y;}LL F(LL x , LL y , LL z) { if(dp[x][y][num[z]] != -1) return dp[x][y][num[z]]; if(x == 0) return dp[x][y][num[z]] = (z == 0 || (y / z) * z == y) ? 1 : 0; LL ans = 0; Go(q , 0 , 9) { ans += F(x-1 , ca1l((y * 10 + q)) , lcm(z , q)); } return dp[x][y][num[z]] = ans;}LL cal(LL x) { m = 0; while(x) { d[m++] = x%10; x /= 10; } LL ans = 0; Go(i , 1 , m-1) { Go(j , 1 , 9) ans += F(i-1 , j , j); } LL times=0 , lc=1; God(i , m-1 , 0) { Go(j , (i == m-1) ? 1 : 0 , d[i]-1) { ans += F(i ,ca1l(times * 10 + j) , lcm(lc , j)); } times = ca1l(times * 10 + d[i]); lc = lcm(lc , d[i]); } return ans;}int main() { memset(dp , -1 , sizeof(dp)); std::cin &gt;&gt; t; num[0] = 1; int cnt = 1; Go(i , 1 , 2520) if(2520 % i == 0) num[i] = ++cnt; while(t--) { std::cin &gt;&gt; l &gt;&gt; r; std::cout &lt;&lt; cal(r+1) - cal(l) &lt;&lt; std::endl; } return 0;}","link":"/2019/03/10/CF55D-Beautiful-Number-题解/"},{"title":"[CF1131D]Gourmet Choice 题解","text":"题意：有两组食物，分别有$n$个和$m$个。给定$n\\times m$的一个表格，其中$a[i][j]$表示第一组第$i$个食物和第二组第$j$个食物的美味度大小关系。请问是否能给出一组美味度方案。如果有，请给出美味度最大值最小的方案。如果没有，请输出No. 先膜LCJ本题如果数据出小一点就是差分约束系统的裸题。但是到了现在的数据大小，差分约束无法承受，所以考虑用并查集+拓扑排序解决。把=的食物用并查集并起来。然后对于&gt;和&lt;的情况，如果这俩元素在一个联通块里，显然不能构造。否则，如果$a[i][j]= ‘&lt;’$就从$i$的连通块向$j$连一条边，反之亦然。然后对联通块跑拓扑排序即可。注意有环也不能构造。正确性很显然：对于$v$，如果被删成了入度$=0$，那么上一次它只需要满足$u$的限制即可。故$value[v] = value[u] + 1$.123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109/** * @Author: Mingyu Li * @Date: 2019-03-09T22:42:11+08:00 * @Email: class11limingyu@126.com * @Filename: c1131D.cpp * @Last modified by: Mingyu Li * @Last modified time: 2019-03-10T06:53:10+08:00 */#include &lt;bits/stdc++.h&gt;#define tpname typename#define Go(i , x , y) for(register int i = x; i &lt;= y; i++)#define God(i , y , x) for(register int i = y; i &gt;= x; i--)typedef long long LL;typedef long double ld;typedef unsigned long long ULL;template &lt; tpname T &gt; void sc(T&amp; t) { char c = getchar(); T x = 1; t = 0; while(!isdigit(c)) {if(c == '-') x = -1; c = getchar();} while(isdigit(c)) t = t * 10 + c - '0' , c = getchar();t *= x;}template &lt; tpname T , tpname... Args &gt; void sc(T&amp; t , Args&amp;... args) {sc(t); sc(args...);}template &lt; tpname T &gt; T mul(T x , T y , T _) { x %= _,y %= _; return ((x * y - (T)(((ld)x * y + 0.5) / _) * _) % _ + _) % _;}const int N = 1000 + 5;int f[N + N];int find(int x) { return x == f[x] ? f[x] : f[x] = find(f[x]);}std::vector &lt;int&gt; v[N + N] , Graph[N + N];std::map &lt;std::pair&lt;int,int&gt;,int&gt; alr;char a[N][N];int n , m;int merge(int u , int v) { f[find(u)] = find(v);}int rf;int degree[N + N] , ans[N + N];void Link(int u , int v) { if(u == v) { rf = 1; return ; } if(alr[{u , v}]) return ; alr[{u , v}] = 1; Graph[u].push_back(v); ++degree[v];}int main() { sc(n , m); Go(i , 1 , n) scanf(\"%s\" , (a[i] + 1)); Go(i , 1 , n+m) f[i] = i; Go(i , 1 , n) Go(j , 1 , m) if(a[i][j] == '=') merge(i , n+j); std::vector &lt;int&gt; v1; Go(i , 1 , n+m) v[find(i)].push_back(i) , v1.push_back(find(i)); Go(i , 1 , n) Go(j , 1 , m) { if(a[i][j] == '&lt;') Link(find(i) , find(n+j)); else if(a[i][j] == '&gt;') Link(find(n+j) , find(i)); } if(rf) { puts(\"No\"); return 0; } std::queue &lt;std::pair &lt;int , int&gt; &gt; Q; sort(v1.begin() , v1.end()); int m1 = unique(v1.begin() , v1.end()) - v1.begin(); std::vector &lt;int&gt; v2; Go(i , 0 , m1-1) if(!degree[v1[i]]) { Q.push({v1[i] , 1}); v2.push_back(v1[i]); for(auto fix : v[v1[i]]) ans[fix] = 1; } while(!Q.empty()) { std::pair &lt; int , int &gt; x = Q.front(); Q.pop(); int u = x.first , va = x.second; for(auto vv : Graph[u]) { degree[vv]--; if(!degree[vv]) { degree[vv] = 0; Q.push({vv , va + 1}); v2.push_back(vv); } } } Go(i , 0 , v2.size() - 1) { for(auto fix : v[v2[i]]) ans[fix] = i + 1; } int ans1 = 0; Go(i , 1 , n+m) ans1 += (degree[find(i)] == 0); //std::cerr &lt;&lt; \"\\n\"; if(ans1 != n+m) { puts(\"No\"); return 0; } std::cout &lt;&lt; \"Yes\\n\"; Go(i , 1 , n) std::cout &lt;&lt; ans[i] &lt;&lt; \" \"; std::cout &lt;&lt; \"\\n\"; Go(i , 1 , m) std::cout &lt;&lt; ans[n + i] &lt;&lt; \" \"; std::cout &lt;&lt; \"\\n\"; return 0;}","link":"/2019/03/10/CF1131D-Gourmet-Choice-题解/"},{"title":"KMP&exKMP详解","text":"终于补掉了KMP经久不衰的坑（雾来写一下吧w KMP可以用来解决一类字符串匹配问题。例如b串在a串中出现的次数。那么具体是怎么实现的呢？通过“大跳”——next数组来实现。这里先说一下next的定义：$next[i]$表示$b[1…i]$中最长的相同前后缀（border）的长度。特别的，$next[1]=0$.举个例子！ $b : “ABA”$ 那么拿$next[3]$举例：$b[1…3]$中最长相同的前后缀为$A$，长度为$1$，故$next[3]=1$. 怎么求出$next$数组呢？我会哈希！显然，哈希也可以直接解决字符串匹配问题。那么既然是个算法，就一定有比$hash$巧妙的办法。 考虑把$next$数组按照类似于$dp$的方式递推转移（见下图）。 我们发现，计算$next[i]$本质上就是找到最长的两段红色序列，使得红色序列相等且下一个黄色也相等。 通俗的说，就是找一段$b[1…x]$，使得$b[1…x] = b[(x-1)-x+1 … (x-1)]$的同时还满足$b[x+1] = b[i]$. 然后有个很显然的东西：一个串的border的border一定是原串的border. 所以就往回一直跳就完事了。 1234567fail[1] = 0;for(int i = 2;i &lt;= lb;i++){ int j = fail[i - 1]; while(j &amp;&amp; b[j + 1] != b[i]) j = fail[j]; if(b[j + 1] == b[i]) fail[i] = j + 1; else fail[i] = 0;} 那么如何用next数组优化找字符串呢？ 考虑用一个指针$j$，指向目前匹配完了$b[j]$.再次画图： 然后我发现我们通过固定i挪动j的位置，就可以合理匹配！ 具体的，就是保证b串不回滚。由于我们已经匹配完了j个，那么跳个border一定还能匹配，就像这样： 不停的跳，直到匹配或者确定不能匹配为止。 上代码：12345678910for(int i = 1 , j = 0;i &lt;= la;i++){ while(j &amp;&amp; b[j + 1] != a[i]) j = fail[j]; if(b[j + 1] == a[i]){ j++; } if(j == lb){ ++res; j = fail[j]; // mark1 }} 特别注意，有些题里找子串可以重复，有些题不能。如果不能的话，就把$mark1$处改成$j=0$. （重新开始） 那么KMP板子就写完了。附上luogu模板题代码：1234567891011121314151617181920212223242526272829303132333435363738394041#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstdlib&gt;//#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;set&gt;#include &lt;map&gt;#include &lt;vector&gt;#define pb push_backusing namespace std;const int MAXN = 1000000 + 10;char a[MAXN] , b[MAXN];static int fail[MAXN];int main(){ scanf(\"%s%s\" , (a + 1) , (b + 1)); int la = strlen(a + 1); int lb = strlen(b + 1); fail[1] = 0; for(int i = 2;i &lt;= lb;i++){ int j = fail[i - 1]; while(j &amp;&amp; b[j + 1] != b[i]) j = fail[j]; if(b[j + 1] == b[i]) fail[i] = j + 1; else fail[i] = 0; } for(int i = 1 , j = 0;i &lt;= la;i++){ while(j &amp;&amp; b[j + 1] != a[i]) j = fail[j]; if(b[j + 1] == a[i]){ j++; } if(j == lb){ cout &lt;&lt; i - lb + 1 &lt;&lt; \"\\n\"; j = fail[j]; } } for(int i = 1;i &lt;= lb;i++) cout &lt;&lt; fail[i] &lt;&lt; \" \"; return 0;} exkmp好像可以直接用哈希+二分水过去…不学了（雾","link":"/2019/03/15/KMP-exKMP详解/"},{"title":"[HDU2089]不要62 题解","text":"数位dp. 设$dp(i,j)$为还差$i$位，上一位为$j$的方案数。 限制不能填4或者不能填相邻的62就完事了。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263/** * @Author: Mingyu Li * @Date: 2019-03-14T13:44:58+08:00 * @Email: class11limingyu@126.com * @Filename: HDU2089.cpp * @Last modified by: Mingyu Li * @Last modified time: 2019-03-14T14:02:19+08:00 */#include &lt;bits/stdc++.h&gt;#define Go(i , x , y) for(register int i = x; i &lt;= y; i++)#define God(i , y , x) for(register int i = y; i &gt;= x; i--)typedef long long LL;template &lt; typename T &gt; void sc(T&amp; t) { char c = getchar(); T x = 1; t = 0; while(!isdigit(c)) {if(c == '-') x = -1; c = getchar();} while(isdigit(c)) t = t * 10 + c - '0' , c = getchar();t *= x;}template &lt; typename T , typename... Args &gt; void sc(T&amp; t , Args&amp;... args) {sc(t); sc(args...);}LL dp[20][11] , d[20];// dp(i,j) : 还差i位 上一位是x，接下来不同的数的个数LL f(LL i , LL j) { if(dp[i][j] != -1) return dp[i][j]; if(!i) return dp[i][j] = 1; else { LL ans = 0; Go(digit , 0 , 9) if(digit != 4 &amp;&amp; !(j == 6 &amp;&amp; digit == 2)) ans += f(i-1 , digit); return dp[i][j] = ans; }}LL calc(LL x) { int m = 0; while(x) { d[m++] = x%10; x/=10; } LL ans = 0; Go(i , 1 , m-1) { Go(j , 1 , 9) if(j != 4) ans += f(i-1 , j); }// std::cerr &lt;&lt;\"%% \" &lt;&lt; ans &lt;&lt; std::endl; int last = 0; God(i , m-1 , 0) { Go(j , (i == m-1) ? 1 : 0 , d[i]-1) if(j != 4 &amp;&amp; !(last == 6 &amp;&amp; j == 2)) ans += f(i , j); if(d[i] == 4) break; if(last == 6 &amp;&amp; d[i] == 2) break; last = d[i]; } return ans;}int main() { memset(dp , -1 , sizeof(dp)); LL l , r; while(1) { sc(l , r); if(!l &amp;&amp; !r) return 0; //std::cout &lt;&lt; calc(l) &lt;&lt; std::endl; std::cout &lt;&lt; calc(r+1) - calc(l) &lt;&lt; std::endl; } return 0;}","link":"/2019/03/14/HDU2089-不要62-题解/"},{"title":"[HNOI2011]XOR和路径 题解","text":"运用高斯消元来$dp$. XOR的期望比较难算。我们可以针对每一位算出期望，再加起来。于是，我们只需要算出第i位是1的概率，在$\\times 2^i$，加起来即可。怎么$dp$？设$dp[u]$表示从$u$到$n$点时第$i$位为1的概率。那么考虑所有u连向的节点v，即可转移： dp[u]=\\sum_{(u\\rightarrow v)\\in E\\ and\\ w\\ bitand \\ bit ==1}\\frac{(1-dp[v])}{dg[u]}+\\sum_{(u\\rightarrow v)\\in E\\ and\\ w\\ bitand \\ bit ==0}\\frac{(dp[v])}{dg[u]}含义是，$u$到$v$概率乘上对应$v$的概率，再加起来即可。同样的，使用高斯消元解$dp$数组。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081/** * @Author: Mingyu Li * @Date: 2019-03-19T20:22:18+08:00 * @Last modified by: Mingyu Li * @Last modified time: 2019-03-19T21:23:07+08:00 */#include &lt;bits/stdc++.h&gt;#define Go(i , x , y) for(register int i = x; i &lt;= y; i++)#define God(i , y , x) for(register int i = y; i &gt;= x; i--)const int N = 100 + 5;// dp[u] : u点 第i位为1的概率// dp[u] = \\sum_{(u , v) &amp; bit} (1 - dp[v]) * (1 / deg[u]) + \\sum_{u , v &amp; bit == 0} dp[v] * (1 / deg[u])// dp[u] = (1 / deg[u]) ...// \\sum_{u , v &amp; bit} -1 = -deg[u]dp[u] + \\sum_{(u , v) &amp; bit} -dp[v] + \\sum_{u , v &amp; bit == 0} dp[v]// deg[u]dp[u] = \\sum_{(u , v) &amp; bit} (1 - dp[v]) + \\sum_{u , v &amp; bit == 0} dp[v]void chkmax(int&amp; a , int b) {a = std::max(a, b);}// dp[n] = 0int n, m, mx , dg[N];std::vector &lt;std::pair &lt;int,int&gt; &gt; G[N];double g[N][N];void Build(int bit) { memset(g , 0 , sizeof(g)); g[n][n] = 1; Go(i , 1 , n-1) { g[i][i] = -dg[i]; for(int j = 0; j &lt; (int)(G[i].size()); j++) { int v = G[i][j].first , w = G[i][j].second; if(w&amp;bit) { g[i][n+1]--, g[i][v]--; } else g[i][v]++; } }}void Gauss() { Go(i , 1 , n) { int now = i; Go(j , i+1 , n) if(fabs(g[now][i]) &lt; fabs(g[j][i])) now = j; Go(j , 1 , n+1) std::swap(g[now][j] , g[i][j]); Go(j , i+1 , n+1) g[i][j] /= g[i][i]; g[i][i] = 1; Go(j , i+1 , n) { Go(k , i+1 , n+1) { g[j][k] -= g[j][i] * g[i][k]; } g[j][i] = 0; } } God(i , n , 1) { Go(j , i+1 , n) g[i][n+1] -= g[i][j] * g[j][n+1]; g[i][n+1] /= g[i][i]; g[i][i] = 1; }}int main() { scanf(\"%d%d\" , &amp;n , &amp;m); Go(i , 1 , m) { int u , v , w; scanf(\"%d%d%d\" , &amp;u , &amp;v , &amp;w); G[u].push_back({v, w}); ++dg[u]; if(u == v) continue; G[v].push_back({u , w}); ++dg[v]; chkmax(mx , w); // 自环 } double ans = 0; for(int bit = 1; bit &lt;= mx; bit &lt;&lt;= 1) { Build(bit); Gauss(); ans += g[1][n+1] * bit; } std::cout &lt;&lt; std::fixed &lt;&lt; std::setprecision(3) &lt;&lt; ans &lt;&lt; std::endl; return 0;}","link":"/2019/03/20/HNOI2011-XOR和路径-题解/"},{"title":"[JSOI2008]球形空间产生器 题解","text":"第一道应用高斯消元的题目。题目本质上就是对于$n$个给定点$a$和圆心$x$，有如下关系： \\sum_{i=1}^{n}(a_i - x_i)^2 = R^2让你求$x$. 使用高斯消元解决。考虑相邻给出的两个点$a_i$和$b_i$，有： \\begin{cases} \\sum\\limits_{i=1}^{n}(a_i - x_i)^2 = R^2&①\\\\ \\\\ \\sum\\limits_{i=1}^{n}(b_i - x_i)^2 = R^2&②\\\\ \\end{cases}①-②:\\sum_{i=1}^{n}(a_i^2-2a_ix_i-b_i^2+2b_ix_i)=0.移项+提取公因式： \\sum_{i=1}^{n}[2x_i(a_i-b_i)]=\\sum_{i=1}^{n}(a_i^2-b_i^2).右边已知（可以当作常数），左边是一个关于$x$的$n$元方程组。于是就可以愉快套板子了。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364/** * @Author: Mingyu Li * @Date: 2019-03-17T11:46:23+08:00 * @Email: class11limingyu@126.com * @Filename: P4035.cpp * @Last modified by: Mingyu Li * @Last modified time: 2019-03-17T14:30:02+08:00 */#include &lt;bits/stdc++.h&gt;#define Go(i , x , y) for(register int i = x; i &lt;= y; i++)#define God(i , y , x) for(register int i = y; i &gt;= x; i--)typedef long long LL;template &lt; typename T &gt; void sc(T&amp; t) { char c = getchar(); T x = 1; t = 0; while(!isdigit(c)) {if(c == '-') x = -1; c = getchar();} while(isdigit(c)) t = t * 10 + c - '0' , c = getchar();t *= x;}template &lt; typename T , typename... Args &gt; void sc(T&amp; t , Args&amp;... args) {sc(t); sc(args...);}const int N = 105;int n;double g[N][N] , p[N][N];void Gauss() { Go(i , 1 , n) { int now = i; Go(j , i+1 , n) if(fabs(g[now][i]) &lt; fabs(g[j][i])) now = j; Go(j , 1 , n+1) std::swap(g[i][j] , g[now][j]); Go(j , i+1 , n+1) g[i][j] /= g[i][i]; g[i][i] = 1; Go(j , i+1 , n) { Go(k , i+1 , n+1) g[j][k] -= g[j][i] * g[i][k]; g[j][i] = 0; } } God(i , n , 1) { Go(j , i+1 , n) g[i][n+1] -= g[i][j] * g[j][n+1]; g[i][n+1] /= g[i][i]; g[i][i] = 1; }}int main() { sc(n); Go(i , 1 , n+1) Go(j , 1 , n) scanf(\"%lf\" , &amp;p[i][j]); Go(i , 1 , n) { Go(j , 1 , n) { double times = 2 * (p[i][j] - p[i+1][j]); g[i][j] = times; g[i][n+1] += (p[i][j] * p[i][j] - p[i+1][j] * p[i+1][j]); } } Gauss(); Go(i , 1 , n) std::cout &lt;&lt; std::fixed &lt;&lt; std::setprecision(3) &lt;&lt; g[i][n+1] &lt;&lt; \" \"; std::cout &lt;&lt; \"\\n\"; return 0;}","link":"/2019/03/17/JSOI2008-球形空间产生器-题解/"},{"title":"[POI2009]Radio Transmission 题解","text":"虽然是个hash裸题但是KMP的做法也很妙~ 答案就是$n-next[n]$.为啥？考虑画图。 考虑根据$n-next[n]$的长度分段。 不难通过一一对应以及$border$的定义证明。 然后就完事了。12345678910111213141516171819202122232425262728293031323334/** * @Author: Mingyu Li * @Date: 2019-03-16T09:53:21+08:00 * @Email: class11limingyu@126.com * @Filename: P4391.cpp * @Last modified by: Mingyu Li * @Last modified time: 2019-03-16T09:55:56+08:00 */#include &lt;bits/stdc++.h&gt;#define Go(i , x , y) for(register int i = x; i &lt;= y; i++)#define God(i , y , x) for(register int i = y; i &gt;= x; i--)typedef long long LL;template &lt; typename T &gt; void sc(T&amp; t) { char c = getchar(); T x = 1; t = 0; while(!isdigit(c)) {if(c == '-') x = -1; c = getchar();} while(isdigit(c)) t = t * 10 + c - '0' , c = getchar();t *= x;}template &lt; typename T , typename... Args &gt; void sc(T&amp; t , Args&amp;... args) {sc(t); sc(args...);}const int N = 1000000 + 5;char a[N];int n , Next[N];int main() { sc(n); scanf(\"%s\" , (a+1)); Next[1] = 0; Go(i,2,n) { int j = Next[i-1]; while(j &amp;&amp; a[j+1] != a[i]) j = Next[j]; if(a[j+1] == a[i]) Next[i] = j+1; else Next[i] = 0; } std::cout &lt;&lt; n - Next[n] &lt;&lt; \"\\n\"; return 0;}","link":"/2019/03/16/POI2009-Radio-Transmission-题解/"},{"title":"[SCOI2009]windy数 题解","text":"数位dp模板题。 $dp[t][p]$表示还剩$t$位，上一位填的是$p$的方案数。那么转移就是$dp[t][p] = \\sum dp[t-1][q], abs(p-q) \\geq 2$.这里采用dls的可读性极高的写法。举个例子，如果我们要计算$[1,3323]$的答案，那么先把$[1,999]$的答案整段算完。然后剩下的一位一位卡着算就行了。具体见代码，如果实在不懂可以画图理解。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869/** * @Author: Mingyu Li * @Date: 2019-03-10T09:32:31+08:00 * @Email: class11limingyu@126.com * @Filename: [SCOI2009]windy数.cpp * @Last modified by: Mingyu Li * @Last modified time: 2019-03-10T10:19:58+08:00 */#include &lt;bits/stdc++.h&gt;#define tpname typename#define Go(i , x , y) for(register int i = x; i &lt;= y; i++)#define God(i , y , x) for(register int i = y; i &gt;= x; i--)typedef long long LL;typedef long double ld;typedef unsigned long long ULL;template &lt; tpname T &gt; void sc(T&amp; t) { char c = getchar(); T x = 1; t = 0; while(!isdigit(c)) {if(c == '-') x = -1; c = getchar();} while(isdigit(c)) t = t * 10 + c - '0' , c = getchar();t *= x;}template &lt; tpname T , tpname... Args &gt; void sc(T&amp; t , Args&amp;... args) {sc(t); sc(args...);}template &lt; tpname T &gt; T mul(T x , T y , T _) { x %= _,y %= _; return ((x * y - (T)(((ld)x * y + 0.5) / _) * _) % _ + _) % _;}int d[20] , l , r;int dp[20][20];int F(int k , int p) { if(dp[k][p] != -1) return dp[k][p]; if(k == 0) return dp[k][p] = 1; int ans = 0; Go(q , 0 , 9) { if(abs(p - q) &gt;= 2) ans += F(k-1 , q); } return dp[k][p] = ans;}int cal(int x) { int m = 0; while(x) { d[m] = x%10; x /= 10; m++; } int ans = 0; God(i , m-1 , 1) { Go(j , 1 , 9) ans += F(i-1 , j); // 整段 } int pre = -100; God(i , m-1 , 0) { Go(j , (i == m-1) ? 1 : 0 , d[i] - 1) { // 卡着边界 if(abs(pre - j) &gt;= 2) ans += F(i , j); } if(abs(pre - d[i]) &lt; 2) break; pre = d[i]; // 钦定一位之后继续 } return ans;}int main() { memset(dp , -1 , sizeof(dp)); std::cin &gt;&gt; l &gt;&gt; r; // cal 计算的是开区间 std::cout &lt;&lt; cal(r+1) - cal(l) &lt;&lt; std::endl; return 0;}","link":"/2019/03/10/SCOI2009-windy数-题解/"},{"title":"[POI2006]OKR-Periods of Words 题解","text":"妙啊+1. 一般题目会让你求最小周期，这个让你求最大周期，咋办？就是不停的跳$next$，直到不能跳了为止。红色部分为不能继续跳的$next$部分。不难通过一一对应及$border$的性质证明。 加个记忆化，这个题就做完了。 123456789101112131415161718192021222324252627282930313233343536373839404142/** * @Author: Mingyu Li * @Date: 2019-03-16T23:00:02+08:00 * @Email: class11limingyu@126.com * @Filename: P3435.cpp * @Last modified by: Mingyu Li * @Last modified time: 2019-03-16T23:10:37+08:00 */#include &lt;bits/stdc++.h&gt;#define Go(i , x , y) for(register int i = x; i &lt;= y; i++)#define God(i , y , x) for(register int i = y; i &gt;= x; i--)typedef long long LL;template &lt; typename T &gt; void sc(T&amp; t) { char c = getchar(); T x = 1; t = 0; while(!isdigit(c)) {if(c == '-') x = -1; c = getchar();} while(isdigit(c)) t = t * 10 + c - '0' , c = getchar();t *= x;}template &lt; typename T , typename... Args &gt; void sc(T&amp; t , Args&amp;... args) {sc(t); sc(args...);}const int N = 1000000 + 10;int next[N] , n;char c[N];int main() { sc(n);scanf(\"%s\" , (c + 1)); next[1] = 0; Go(i , 2 , n) { int j = next[i-1]; while(j &amp;&amp; c[i] != c[j + 1]) j = next[j]; if(c[i] == c[j+1]) next[i] = j+1; else next[i] = 0; } LL ans = 0; Go(i , 2 , n) { int j = i; while(next[j]) j = next[j]; if(next[i]) next[i] = j; ans += 1ll * (i - j); } std::cout &lt;&lt; ans &lt;&lt; \"\\n\"; return 0;}","link":"/2019/03/17/POI2006-OKR-Periods-of-Words-题解/"},{"title":"[NOI2014]动物园 题解","text":"妙啊 考虑一个简化的问题：如果没有前后缀不能相交的限制怎么办？这个问题可以轻易的用$KMP+DP$解决。具体的，就是$dp[i]=dp[next[i]]+1$. 特别注意$dp[1]=1$. 那么解决了这个简化版的问题之后，原问题就可以转化为求一个最长的$a[1…i]$的border的dp值，同时前后缀border不相交。（也就是说$|border|\\leq i/2$） 显然暴力往回跳$next$不太现实。那咋办？很简单，你咋维护$next$的就咋维护这个。保证$j$的总操作次数不超过一个特定的极限即可。（具体看代码吧） 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152/** * @Author: Mingyu Li * @Date: 2019-03-16T16:11:25+08:00 * @Email: class11limingyu@126.com * @Filename: P2375.cpp * @Last modified by: Mingyu Li * @Last modified time: 2019-03-16T20:44:23+08:00 */#include &lt;bits/stdc++.h&gt;#define Go(i , x , y) for(register int i = x; i &lt;= y; i++)#define God(i , y , x) for(register int i = y; i &gt;= x; i--)typedef long long LL;template &lt; typename T &gt; void sc(T&amp; t) { char c = getchar(); T x = 1; t = 0; while(!isdigit(c)) {if(c == '-') x = -1; c = getchar();} while(isdigit(c)) t = t * 10 + c - '0' , c = getchar();t *= x;}template &lt; typename T , typename... Args &gt; void sc(T&amp; t , Args&amp;... args) {sc(t); sc(args...);}const int N = 1000000 + 5;char a[N];int t , next[N] , cnt[N] , ans[N];int main() { sc(t); while(t--) { memset(next , 0 , sizeof(next)); memset(cnt , 0 , sizeof(cnt)); memset(ans , 0 , sizeof(ans)); scanf(\"%s\" , (a+1)); int n = strlen(a+1); LL mult = 1; next[1] = 0 , ans[1] = 1; Go(i , 2 , n) { int j = next[i-1]; while(j &amp;&amp; a[j+1] != a[i]) j = next[j]; if(a[j+1] == a[i]) next[i] = j+1 , j++; else next[i] = 0; ans[i] = ans[j] + 1; } //Go(i , 1 , n) std::cerr &lt;&lt; ans[i] &lt;&lt; \" \"; //std::cerr &lt;&lt; \"\\n\"; for(int i=2 , j=0; i &lt;= n; i++) { while(j &amp;&amp; a[j+1] != a[i]) j = next[j]; if(a[j+1] == a[i]) ++j; while((j &lt;&lt; 1) &gt; i) j = next[j]; mult = mult * (ans[j] + 1) % (LL)(1e9 + 7); } printf(\"%lld\\n\" , mult); } return 0;}","link":"/2019/03/16/NOI2014-动物园-题解/"},{"title":"[USACO10HOL]DOtP 题解","text":"第一道应用高斯消元来解$dp$数组的题，感觉很妙。这玩意没法$dp$…考虑套路的转化$dp$类型。也就是$dp$出每个点期望经过次数，然后$\\times (p/q)$就是概率。咋$dp$？设$dp[u]$为$u$点的期望经过次数。有： dp[u]=[\\sum_{(v,u) \\in E}(1-p/q)\\times(1/deg[v])\\times dp[v]] + [u == 1]含义是，从$v$转移到$u$.由于$dp[v]$为$v$的期望经过次数，那么每次经过它都有$(1-p/q)\\times(1/deg[v])$的概率成功到达$u$，那么单方面$v$对$dp[u]$的贡献就如上面公式所示了。 由于期望的线性性，可以直接加起来。 由于无向图上的$dp$顺序十分混乱，可以把$dp[1…n]$当作$n$个未知数，把转移方程当作方程，$gauss$消元$solve$一下即可。 （特别注意：由于$1$点一开始就经过了一次，真正$dp$出来之后$dp[1]$要比原始数值多$1$，需要在高斯消元方程组中体现一下） 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465/** * @Author: Mingyu Li * @Date: 2019-03-18T21:37:38+08:00 * @Last modified by: Mingyu Li * @Last modified time: 2019-03-18T21:40:36+08:00 */#include &lt;bits/stdc++.h&gt;#define Go(i , x , y) for(register int i = x; i &lt;= y; i++)#define God(i , y , x) for(register int i = y; i &gt;= x; i--)// 设f[u] : 访问节点u的期望次数// f[u] = \\sum(1 - p / q) * f[v]// 则显然有ans[u] = f[u] * (p/q)// 特判1位置// 列出来n个方程 高斯消元求f// 最后乘个(p/q)const int N = 300 + 10;int n , m , p , q , u , v , deg[N];double g[N][N];bool w[N][N];void Gauss() { Go(i , 1 , n) { int now = i; Go(j , i+1 , n) if(fabs(g[now][i]) &lt; fabs(g[j][i])) now = j; Go(j , 1 , n+1) std::swap(g[i][j] , g[now][j]); Go(j , i+1 , n+1) g[i][j] /= g[i][i]; g[i][i] = 1; Go(j , i+1 , n) { Go(k , i+1 , n+1) { g[j][k] -= g[j][i] * g[i][k]; } g[j][i] = 0; } }// 构建上三角矩阵 God(i , n , 1) { Go(j , i+1 , n) g[i][n+1] -= g[i][j] * g[j][n+1]; g[i][n+1] /= g[i][i]; g[i][i] = 1; }}int main() { scanf(\"%d%d%d%d\", &amp;n, &amp;m, &amp;p, &amp;q); double weight = (1.0 * p) / (1.0 * q); Go(i, 1, m) { scanf(\"%d%d\", &amp;u, &amp;v); w[u][v] = 1; w[v][u] = 1; ++deg[u]; ++deg[v]; } // 构建高斯消元方程组 Go(i, 1, n) { g[i][i] = -1; // ..... - f[u] + ...... = 0 Go(j, 1, n) if(w[i][j] == 1) g[i][j] += (1.0 - weight) * (1.0 / (double)(deg[j])); } g[1][n + 1] = -1; Gauss(); Go(i , 1 , n) std::cout &lt;&lt; std::fixed &lt;&lt; std::setprecision(9) &lt;&lt; g[i][n+1] * weight &lt;&lt; \"\\n\"; return 0;}","link":"/2019/03/18/USACO10HOL-DOtP-题解/"},{"title":"[ZJOI2014]力 题解","text":"题意： 发现Ei如果给出了Fi就很好算，所以目标其实是算Fi.首先我们令$F_j=A_j-B_j$.其中A_j=\\sum_{ij}\\frac{q_iq_j}{(i-j)^2}.考虑将第一个式子变形为 A_j=\\sum_{i=0}^{j-1}\\frac{q_iq_j}{(i-j)^2}.由乘法分配律，可以将$q_j$单拎出来，得： A_j=q_j\\times \\sum_{i=0}^{j-1}\\frac{q_i}{(i-j)^2}.由于$(i-j)^2=(j-i)^2$，所以考虑这样一个函数： g(x)=\\frac{1}{x^2}.然后就会发现可以把 \\frac{q_i}{(i-j)^2}变形为 q_ig(j-i).带回原式，得到：A_j=q_j\\times \\sum_{i=0}^{j-1}q_ig(j-i).不难发现后面的那坨东西类似于多项式乘法，但是少了一项，可以手动将$g(0)=0$.然后…这就是个多项式乘法的典型形式！可以用$\\text{FFT}$解决！同理也可以化简$B_j$. B_j=\\sum_{i=j+1}^{n-1} \\frac{q_iq_j}{(i-j)^2}B_j=q_j\\sum_{i=j+1}^{n} \\frac{q_i}{(i-j)^2}然后突然发现…这东西和$A_j$的计算方法不大一样!咋整？瞬间考虑-&gt;反转q序列！变成 \\sum_{i=0}^{j-1}\\frac{q'_i}{(i-j)^2}.然后把这个式子搞一下，变成 \\sum_{i=0}^{j-1}q'_ig(j-i)发现这个式子本质上就是$A_j$，就能做了。","link":"/2019/03/09/ZJOI2014-力-题解/"},{"title":"[SCOI2010]传送带 题解","text":"比较神的一道题，以前没有接触过三分套三分… 介绍一下我的做法。 首先，碰见这种题，第一眼一般都不知道从何下手。这时候观察题目的性质，发现所走的路径一定是$A\\Rightarrow X\\Rightarrow Y\\Rightarrow D$，其中$X\\in [A,B],Y\\in[C,D].$所以很容易想到一个暴力算法：把每一对$[x,y]$都枚举一遍即可。但是这样的时间复杂度太高了，所以需要考虑别的办法。 在手算模拟之后，可以发现$[x,y]$的枚举都是有规律性的，是一个类似函数的变化。所以考虑三分。 那么怎么三分呢？ 考虑问题的简化版。给你一个点，一条线段，求到哪个点最快，各种定义依据原问题的定义。 这时候很简单，很明显就是一个函数，可以三分。 那么会发现，如果这个函数有单调性，那么问题的简化版也一定具有单调性。也就是说解也是有单调性的。 所以我们可以先三分$X$,再三分$Y$，最后选择一个最优解即可。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788#pragma GCC optimize(\"O2\")#include &lt;bits/stdc++.h&gt;#define PI 3.14159265#define DO_NOT_USE_SCANF ios::sync_with_stdio(0)#define PQ priority_queue#define lowbit(x) ((x) &amp; (-x))#define lmy#ifdef lmy #define DEBUG printf(\"Passing [%s] in LINE %d...\\n\" , __FUNCTION__ , __LINE__)#endiftypedef long long ll;typedef unsigned long long ull;using namespace std;inline void read(int &amp;x) { int f = 1;x = 0;char ch = getchar(); while(ch &lt; '0' || ch &gt; '9') {if(ch == '-') f = -1; ch = getchar();} while(ch &gt;= '0' &amp;&amp; ch &lt;= '9') {x = x * 10 + ch - '0'; ch = getchar();} x *= f;}inline void readll(ll &amp;x) { ll f = 1;x = 0;char ch = getchar(); while(ch &lt; '0' || ch &gt; '9') {if(ch == '-') f = -1; ch = getchar();} while(ch &gt;= '0' &amp;&amp; ch &lt;= '9') {x = x * 10 + ch - '0'; ch = getchar();} x *= f;}struct Point { double x , y;};Point a , b , c , d;double p , q , r;const double eps = 1e-6;double dist(Point a , Point b) { return sqrt((a . x - b . x) * (a . x - b . x) + (a . y - b . y) * (a . y - b . y));}double f(Point x , Point y) { return dist(a , x) / p + dist(x , y) / r + dist(y , d) / q;}double task(Point x) { Point l = c , r = d; while(dist(l , r) &gt; eps) { Point delta = (Point){(r . x - l . x) / 3 , (r . y - l . y) / 3}; Point lmid = (Point){l . x + delta . x , l . y + delta . y}; Point rmid = (Point){r . x - delta . x , r . y - delta . y}; if(f(x , rmid) - f(x , lmid) &gt; eps) r = rmid; else l = lmid; } return f(x , l);}void solve() { scanf(\"%lf%lf%lf%lf\" , &amp;a . x , &amp;a . y , &amp;b . x , &amp;b . y); scanf(\"%lf%lf%lf%lf\" , &amp;c . x , &amp;c . y , &amp;d . x , &amp;d . y); scanf(\"%lf%lf%lf\" , &amp;p , &amp;q , &amp;r); Point l = a , r = b; while(dist(l , r) &gt; eps) { Point delta = (Point){(r . x - l . x) / 3 , (r . y - l . y) / 3}; Point lmid = (Point){l . x + delta . x , l . y + delta . y}; Point rmid = (Point){r . x - delta . x , r . y - delta . y}; if(task(rmid) - task(lmid) &gt; eps) r = rmid; else l = lmid; } cout &lt;&lt; fixed &lt;&lt; setprecision(2) &lt;&lt; task(l) &lt;&lt; endl; return;}int main(){ #ifdef lmy int nol_cl = clock(); #endif solve(); // did you forget to undefine Lmy ? #ifdef lmy printf(\"\\nTime: %dms\\n\", int((clock() - nol_cl) / (double)CLOCKS_PER_SEC * 1000)); #endif return 0;}","link":"/2019/03/10/SCOI2010-传送带-题解/"},{"title":"省选基础数论整理","text":"众所周知，$\\text{LiM}$数学不好。这篇文章用于总结一堆数论算法。 $\\text{Primality Test}$单个$\\mathcal{O(\\sqrt{n}):}$由于因数成对出现，找有没有$\\leq \\sqrt{n}$的因子即可判断。 12345bool isprime(int n) { for(int i = 2; i * i &lt;= n; i++) if(n % i == 0) return 0; return 1;} $\\mathcal{O(nlogn):}\\text{Normal Sieve}$123456void sieve() { notprime[1] = 1; for(int i = 2; i &lt;= n; i++) { for(int j = i + i; j &lt;= n; j++) notprime[j] = 1; }} 复杂度由调和级数证明。$\\mathcal{O(nloglogn):}\\text{Eratothene Sieve}$只筛素数。反正根据素数分布来看大概是$\\mathcal{O(nloglogn)}$的，具体不会证（雾 1234567void sieve() { notprime[1] = 1; for(int i = 2; i &lt;= n; i++) { if(!notprime[i]) for(int j = 2; i*j &lt;= n; j++) notprime[i*j] = 1; }} $\\mathcal{O(n):}\\text{Euler Sieve}$保证每个数都只能被最小的质因子筛到一次，所以复杂度是对的。还可以用于筛一些积性函数。123456789void sieve() { for(int i = 2; i &lt;= n; i++) { if(!!np[i]) prime[++tot] = i; for(int j = 1; j &lt;= tot &amp;&amp; i * prime[j] &lt;= n; j++) { np[i * prime[j]] = 1; if(i % prime[j] == 0) break; } }} 只筛一次的证明：观察这一行：1if(i % prime[j] == 0) break; 考虑这样做代表着什么。显然， $i$ 可以表示成$k\\times prime[j].$ 如果不$break$，那么筛下一个 $prime$ 的时候：就有 $i\\times prime[j+1] = k\\times prime[j]\\times prime[j+1]$ 违背了只被最小质因子筛的规定。 $\\mathcal{O(klogn):}\\text{Miller Rabin}$ 理论背景：费马小定理。$设p \\in prime，a$是整数，且$(a,p)=1$，就有$a^{p-1}\\equiv 1\\mod p$证明：还是举个例子吧。比如说$p=13,a=3$.那么对于$[1,p-1]$之间的整数（也就是$1,2,3…p-1$），我们同乘一个$a$，变成$a,2a,…(p-1)a$。我们发现乘完之后，整数中没有一个$\\mod p=0$（$(a,p)=1$），也没有两个$\\mod p$相等（基本性质）。所以模完之后一定是$[1…p-1]$的一个排列。也就是 a\\times 2a\\times...\\times (p-1)a\\equiv (p-1)!\\pmod p提出来$a$：$a^{p-1}\\times(p-1)!\\equiv (p-1)!\\pmod p$提出来$(p-1)!$：$a^{p-1}\\equiv 1\\pmod p)$.得证。 那么发现上面那个式子同乘$a$就是$a^p\\equiv a\\pmod p$。这个式子在$p$是素数时一定有，但是有这个式子不代表$p$一定是素数。 因此引入二次探测。首先证明一个东西：$x^2\\equiv 1\\pmod p$，且$x ≠ (p-1)\\pmod p$，$x ≠ 1\\mod p$，那么这个$p$一定是合数。 证明：$x^2\\equiv 1\\pmod p$$x^2 - 1\\equiv 0\\pmod p$$(x+1)(x-1)\\equiv 0\\pmod p$ 由于$p$是质数，那么如果他俩乘起来模$p$等于$0$，那么要么$(x+1)\\equiv 0\\pmod p \\rightarrow x=p-1\\pmod p$要么$(x-1)\\equiv 0\\pmod p \\rightarrow x=1\\pmod p$然后，我们发现，费马小定理里头给出的有关$p$的式子是$a^{p-1}\\equiv 1\\pmod p$。于是可以将$p-1$分解为$2^k\\times t$，然后先计算出来$a^t\\mod p$，再不断地将$t$翻倍。其中，如果有一次满足$a^{(2t)}\\equiv 1\\pmod p$且$a^t ≠ \\pm 1\\pmod p$，那就一定是合数。 不难发现每次翻倍最多翻log次，所以复杂度是对的。123456789101112131415161718192021222324252627282930313233343536373839404142434445/** * @Author: Mingyu Li * @Date: 2019-03-24T22:33:04+08:00 * @Last modified by: Mingyu Li * @Last modified time: 2019-03-29T21:02:44+08:00 */#include &lt;bits/stdc++.h&gt;#define Go(i , x , y) for(register int i = x; i &lt;= y; i++)#define God(i , y , x) for(register int i = y; i &gt;= x; i--)#define ll long longll n , m;ll primelist[8] = {2 , 3 , 7 , 13 , 41 , 59 , 97};ll quickt(ll u , ll p , ll t) { if(!p) return 1%t; ll half = quickt(u , p/2 , t); if(p % 2) return half * half % t * u % t; else return half * half % t;}bool Miller_Rabin(ll x) { if(x == 1) return 0; ll div = x-1 , cnt = 0; while(!(div % 2)) div &gt;&gt;= 1 , ++cnt; Go(i , 0 , 6) { if(x == primelist[i]) return 1; ll fst = quickt(primelist[i] , div , x); Go(i , 1 , cnt){ ll scd = fst * fst % x; if(scd == 1 &amp;&amp; !(fst == 1%x || fst == (x-1)%x)) return 0; fst = scd; } if(fst != 1) return 0; } return 1;}int main() { ll n , m; scanf(\"%lld%lld\" , &amp;n , &amp;m); while(m--) { ll x; scanf(\"%lld\" , &amp;x); puts(Miller_Rabin(x) ? \"Yes\":\"No\"); } return 0;} $\\text{GCD}$下面有关于GCD的东西都会提一下。 $\\text{GCD}$求法如果$k|a,k|b$，那一定有$k|max(a,b)\\bmod min(a,b)$，正确性可以画图来证。这就是辗转相除法的原理：$gcd(a,b) = gcd(b , a\\bmod b)$，边界为$gcd(x , 0) = x$每次模一下数量级减少至少一倍，所以复杂度是$\\mathcal{O(logn)}$.1int gcd(int a , int b) {return !b ? a : gcd(b , a%b);} 当然，$C++$中自带的$\\text{std::__gcd(a,b)}$也可以做到这一点，不过$NOIp$好像用不了。 $\\text{ExGCD}$ $\\text{Multiplicative Function}$注意：接下来仅仅谈论数论函数，即定义域仅在正整数域的函数。对于函数$f$：如果对于任何的$(x,y) = 1,f(x)\\times f(y) = f(xy)$，则称$f$函数为积性函数。如果没有$(x,y)=1$的限制，即对于所有正整数对都满足如上条件，则称$f$函数为完全积性函数。 $\\text{Phi’s Function}$$\\varphi(n)$表示$\\leq n$且与$n$互质的数的个数。公式化的描述，$\\varphi(n)=\\sum_{i=1}^{n}[(i,n)==1]$怎么计算？$\\mathcal{O(\\sqrt n)}:\\text{Brute Force}$考虑容斥。我们发现一个数的$\\varphi$一定只跟其质因子有关。于是就可以写出一个式子： \\varphi(n) = n - (n / p_1) - (n / p_2) - ...+ (n / (p1 \\times p2)) + ...\\varphi(n) = n(1 - p_1)(1 - p_2)...(1 - p_n)（其实就是硬拆上面那个式子得到的）然后就可以枚举质因子硬乘就可以了。 1234567891011ll phi(ll n) { ll ans = n; for(ll i = 2; i * i &lt;= n; i++) { if(n % i == 0) { while(n % i == 0) n /= i; ans = ans / i * (i - 1); } } if(n &gt; 1) ans = ans / n * (n - 1); return ans;} $\\text{Linear Sieve}$考虑硬拆式子。重温$\\text{Euler Sieve}$的过程，就是找$n$的最小质因子$p_1$将其用$p_1 \\times (n / p_1)$筛掉。先设$n’ = n / p_1$，再分两种情况讨论：$①:n’$有$p_1$这一因子。意味着唯一分解中$k_1 &gt; 1$那么显然，$n’$有着$n$的所有质因子。所以 \\begin{aligned} \\varphi(n)&= n \\prod\\limits_{i = 1} ^ {n} \\frac{p_i - 1}{p_i} \\\\ &= p_1 \\times n' \\prod\\limits_{i = 1} ^ {n} \\frac{p_i - 1}{p_i} \\\\ &= p_1 \\times \\varphi(n') \\\\ \\end{aligned}$②:n’$没有$p_1$这一因子。意味着唯一分解中$k_1 = 1$ \\begin{aligned} \\varphi(n)&= n \\prod_{i = 1} ^ {n} \\frac{p_i - 1}{p_i} \\\\ &= p_1 \\times n' \\times \\frac{p_1-1}{p_1} \\prod\\limits_{i = 2} ^ {n} \\frac{p_i - 1}{p_i} \\\\ &= (p_1-1) \\times \\varphi(n') \\\\ \\end{aligned}（其实也证明了欧拉函数是积性函数）愉快的筛就好了。注意任何积性函数都有$f(1) = 1$.123456789101112131415void Euler_Sieve(int x) { np[1] = 1; phi[1] = 1; Go(i , 2 , x) { if(!np[i]) prime[++cnt] = i , phi[i] = i - 1; for(int j = 1; j &lt;= cnt &amp;&amp; i * prime[j] &lt;= x; j++) { np[i * prime[j]] = 1; if(i % prime[j]) phi[i * prime[j]] = phi[i] * (prime[j] - 1); else { phi[i * prime[j]] = prime[j] * phi[i]; break; } } }}","link":"/2019/03/23/省选基础数论整理/"},{"title":"[ZJOI2010]数字计数 题解","text":"wr硬着头皮写了一发竟然过了？ 谈一谈我的做法。 思路：数位dp+分类讨论。 考虑分成一个一个位考虑。加上前缀和思想，本题就转化成了“$1-x$中$y$出现的个数”。 再分个类，考虑限定数位在每一个数中必须出现的个数，那么本题就又转化成了“$1-x$中$y$出现$z$次的数的个数”。 这玩意是个简单到不能再简单的数位dp模型了。可以直接套模型求解。 那么本题就完美解决了。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172/** * @Author: Mingyu Li * @Date: 2019-03-11T12:13:29+08:00 * @Email: class11limingyu@126.com * @Filename: [ZJOI2010]数字计数.cpp * @Last modified by: Mingyu Li * @Last modified time: 2019-03-13T19:36:56+08:00 */#include &lt;bits/stdc++.h&gt;#define tpname typename#define int long long#define Go(i , x , y) for(register int i = x; i &lt;= y; i++)#define God(i , y , x) for(register int i = y; i &gt;= x; i--)typedef long long LL;typedef long double ld;typedef unsigned long long ULL;template &lt; tpname T &gt; void sc(T&amp; t) { char c = getchar(); T x = 1; t = 0; while(!isdigit(c)) {if(c == '-') x = -1; c = getchar();} while(isdigit(c)) t = t * 10 + c - '0' , c = getchar();t *= x;}template &lt; tpname T , tpname... Args &gt; void sc(T&amp; t , Args&amp;... args) {sc(t); sc(args...);}template &lt; tpname T &gt; T mul(T x , T y , T _) { x %= _,y %= _; return ((x * y - (T)(((ld)x * y + 0.5) / _) * _) % _ + _) % _;}const int N = 20;LL dp[N][N] , d[N];// 啥意思?// dp[i][j] : 填了i位 共填了j个有效数字 接下来\"能动\"的数个数int l , r , sup;LL f(LL x, LL y) { if(dp[x][y] != -1) return dp[x][y]; if(x == 0) return dp[x][y] = y == sup ? 1 : 0; else return dp[x][y] = 9 * f(x-1 , y) + f(x-1 , y+1);}LL cal(LL D , LL digit) { memset(dp , -1 , sizeof(dp)); int m=0; while(D) { d[m++] = D%10; D /= 10; } int ans = 0; Go(occur , 0 , 13) { sup = occur; memset(dp , -1 , sizeof(dp)); Go(i , 1 , m-1) { Go(j , 1 , 9) { ans += occur * f(i-1 , (j == digit)); } } } Go(occur , 0 , 13) { sup = occur; memset(dp , -1 , sizeof(dp)); int pref = 0; God(i , m-1 , 0) { Go(j , (i == m-1) ? 1 : 0 , d[i] - 1) { ans += occur * f(i , pref + (j == digit)); } pref += (d[i] == digit); if(pref &gt; occur) break; } } return ans;}signed main() { std::cin &gt;&gt; l &gt;&gt; r; for(int i = 0; i &lt;= 9; i++) std::cout &lt;&lt; cal(r+1 , i) - cal(l , i) &lt;&lt; \" \"; return 0;}","link":"/2019/03/13/ZJOI2010-数字计数-题解/"},{"title":"Hello World","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","link":"/2019/03/07/hello-world/"},{"title":"[清华集训2015]Light Bulb 题解","text":"可以观察题目中隐含的单调性来解决本题。 观察到可以把图中的$L$分成两部分：一部分是投影到地上的，而另一部分是投影到墙上的。 位置离墙越近，地上的投影就会变短，同时墙上的投影也会变长。 但是本题的答案并不是一个一次函数，因为一开始墙上的投影一段时间内都为$0$（影子太短），所以并不能直接一次函数求解。 所以可以直接正常三分，函数直接快速维护一下即可。 复杂度约等于$\\Theta(Tlogd)$ ? （不会证，算了…） 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172#pragma GCC optimize(\"O2\")#include &lt;bits/stdc++.h&gt;#define PI 3.14159265#define DO_NOT_USE_SCANF ios::sync_with_stdio(0)#define PQ priority_queue#define lowbit(x) ((x) &amp; (-x))//#define lmy#ifdef lmy #define DEBUG printf(\"Passing [%s] in LINE %d...\\n\" , __FUNCTION__ , __LINE__)#endiftypedef long long ll;typedef unsigned long long ull;using namespace std;inline void read(int &amp;x) { int f = 1;x = 0;char ch = getchar(); while(ch &lt; '0' || ch &gt; '9') {if(ch == '-') f = -1; ch = getchar();} while(ch &gt;= '0' &amp;&amp; ch &lt;= '9') {x = x * 10 + ch - '0'; ch = getchar();} x *= f;}inline void readll(ll &amp;x) { ll f = 1;x = 0;char ch = getchar(); while(ch &lt; '0' || ch &gt; '9') {if(ch == '-') f = -1; ch = getchar();} while(ch &gt;= '0' &amp;&amp; ch &lt;= '9') {x = x * 10 + ch - '0'; ch = getchar();} x *= f;}double H , h , D;const double eps = 1e-7;double f(double mid) { double straight = mid / (H - h) * h; if(straight + mid - D &gt; eps) { straight = D - mid; } // h - delta * (straight / mid) // delta : H - h double delta = H - h; double up = h - delta * (straight / mid); if(0 - up &gt; eps) up = 0; return straight + up;}void solve() { scanf(\"%lf%lf%lf\" , &amp;H , &amp;h , &amp;D); double l = 0 , r = D; while(r - l &gt; eps) { double lmid = l + (r - l) / 3 , rmid = r - (r - l) / 3; if(f(rmid) - f(lmid) &gt; eps) l = lmid; else r = rmid; } cout &lt;&lt; fixed &lt;&lt; setprecision(3) &lt;&lt; f(l) &lt;&lt; endl; return;}int main(){ #ifdef lmy int nol_cl = clock(); #endif int T; read(T); while(T--) { solve(); } // did you forget to undefine Lmy ? #ifdef lmy printf(\"\\nTime: %dms\\n\", int((clock() - nol_cl) / (double)CLOCKS_PER_SEC * 1000)); #endif return 0;}","link":"/2019/03/10/清华集训2015-Light-Bulb-题解/"},{"title":"你好.","text":"Hello.Hello.markdon$a+b=c$ $c_k=\\sum _{i=0}^{n-1}(\\omega_{n}^{-k})^i\\times y_i.$ lim_{1\\to+\\infty}P(|\\frac{1}{n}\\sum_i^nX_i-\\mu|","link":"/2019/03/07/你好/"},{"title":"省选字符串算法总结","text":"众做周知，$\\text{LiM}$字符串没学好。所以这里会用来整理一些知名字符串算法。 $\\mathcal{KMP}$$\\text{Old Link}$这里不写了…还有一堆$fail$数组的妙用。 $\\mathcal{AC自动机}$在$\\text{Trie}$上跑$\\text{KMP}$.建立$trie$图然后暴跳（123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263/** * @Author: Mingyu Li * @Date: 2019-03-31T13:59:13+08:00 * @Last modified by: Mingyu Li * @Last modified time: 2019-03-31T14:07:19+08:00 */#include &lt;bits/stdc++.h&gt;#define Go(i , x , y) for(register int i = x; i &lt;= y; i++)#define God(i , y , x) for(register int i = y; i &gt;= x; i--)using namespace std;const int N = 500000 + 5;struct AC_automaton { int trie[N][26] , val[N] , fail[N] , cnt; void insert(char *s) { int l = strlen(s); int now = 0; for(int i = 0; i &lt; l; i++) { if(trie[now][s[i] - 'a'] == 0) trie[now][s[i] - 'a'] = ++cnt; now = trie[now][s[i] - 'a']; } ++val[now]; } void Build() { queue&lt;int&gt; q; Go(i, 0, 25) if(trie[0][i]) q.push(trie[0][i]), fail[trie[0][i]] = 0; while(!q.empty()) { int u = q.front(); q.pop(); Go(i, 0, 25) { if(trie[u][i]) fail[trie[u][i]] = trie[fail[u]][i], q.push(trie[u][i]); else trie[u][i] = trie[fail[u]][i]; } } } int Query(char* t) { int ans = 0; int l = strlen(t); int now = 0; for(int i = 0; i &lt; l; i++) { now = trie[now][t[i] - 'a']; for(int t = now; t &amp;&amp; ~val[t]; t = fail[t]) ans += val[t] , val[t] = -1; } return ans; }}AC;int n;char s[N&lt;&lt;1];int main() { scanf(\"%d\" , &amp;n); Go(i, 1, n) { scanf(\"%s\" , s); AC.insert(s); } AC.Build(); scanf(\"%s\" , s); cout &lt;&lt; AC.Query(s) &lt;&lt; endl; return 0;}","link":"/2019/03/31/省选字符串算法总结/"},{"title":"高斯消元 详解","text":"高斯消元是解决一类线性多元方程组的利器。 举个例子，如果让你求解如下的方程，你该怎么办？ \\begin{cases} 2x+y+z=1&①\\\\ 6x+2y+z=-1&②\\\\ -2x+2y+z=7&③\\\\ \\end{cases}正常人的思路差不多就是加减消元/代入消元，最后解出来所有答案。下面我们来模拟一下正常人的解题过程： $(-3)\\times①+②:0x - y - 2z = -4$$①+③:0x + 3y + 2z = 8$ 所以有 \\begin{cases} 2x + y + z=1&①\\\\ 0x - y - 2z=-4&②\\\\ 0x + 3y + 2z = 8&③\\\\ \\end{cases}发现$x$消不了了，开始消$y$. $②\\times3+③:-4z = -4.$ 于是解得： z = 1.这时候就可以把$z$带回去解别的。 代入$②:0x-y-2=-4$解得y = 2. 然后带回$①:x=-1.$然后就解完了。 考虑把解题过程中的$x,y,z$项写成矩阵。所以一开始的矩阵就是$\\begin{bmatrix}x &amp; y &amp; z &amp; val\\\\ 2 &amp; 1 &amp; 1 &amp; 1\\\\ 6 &amp; 2 &amp; 1 &amp; -1\\\\ -2 &amp; 2 &amp; 1 &amp; 7\\end{bmatrix}$消完$x$之后： $\\begin{bmatrix}x &amp; y &amp; z &amp; val\\\\ 2 &amp; 1 &amp; 1 &amp; 1\\\\ 0 &amp; -1 &amp; -2 &amp; -4\\\\ 0 &amp; 3 &amp; 2 &amp; 8\\end{bmatrix}$消完$y$之后：$\\begin{bmatrix}x &amp; y &amp; z &amp; val\\\\ 2 &amp; 1 &amp; 1 &amp; 1\\\\ 0 &amp; -1 &amp; -2 &amp; -4\\\\ 0 &amp; 0 &amp; -4 &amp; -4\\end{bmatrix}$ 发现矩阵中的0元素构成了一个上三角，我们称这玩意为”上三角矩阵”。 显然，最理想情况一定是构成这玩意，直接一直回代就可以了。那么我们来分析一下多个解或无解的情况：无解：一行系数全0，但$val ≠ 0$.多个解：好几行系数和$val$全是0. 分析完了。如何实现？ 算法流程：一项一项消。消到第i项的时候，找系数绝对值最大的（好判断无解）来作为主式子。然后硬消就行了。 附$Luogu$模板题代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657/** * @Author: Mingyu Li * @Date: 2019-03-17T11:01:04+08:00 * @Email: class11limingyu@126.com * @Filename: Gauss消元.cpp * @Last modified by: Mingyu Li * @Last modified time: 2019-03-17T11:26:00+08:00 */#include &lt;bits/stdc++.h&gt;#define Go(i , x , y) for(register int i = x; i &lt;= y; i++)#define God(i , y , x) for(register int i = y; i &gt;= x; i--)typedef long long LL;template &lt; typename T &gt; void sc(T&amp; t) { char c = getchar(); T x = 1; t = 0; while(!isdigit(c)) {if(c == '-') x = -1; c = getchar();} while(isdigit(c)) t = t * 10 + c - '0' , c = getchar();t *= x;}template &lt; typename T , typename... Args &gt; void sc(T&amp; t , Args&amp;... args) {sc(t); sc(args...);}const int N = 100 + 5;int n;double g[N][N];int main() { sc(n); Go(i, 1, n) Go(j, 1, n+1) scanf(\"%lf\" , &amp;g[i][j]); Go(i, 1, n) { int now = i; Go(j , i+1, n) if(fabs(g[now][i]) &lt; fabs(g[j][i])) now = i; if(fabs(g[now][i]) &lt; 1e-9) { puts(\"No Solution\"); return 0; } Go(j , i, n+1) std::swap(g[now][j] , g[i][j]); Go(j , i+1 , n+1) g[i][j] /= g[i][i]; g[i][i] = 1; Go(j , i+1 , n) { Go(k , i+1 , n+1) { g[j][k] -= g[j][i] * g[i][k]; } g[j][i] = 0; } } God(i, n, 1) { Go(j , i+1 , n) g[i][n+1] -= g[i][j] * g[j][n+1]; g[i][n+1] /= g[i][i]; g[i][i] = 1; } Go(i , 1 , n) std::cout &lt;&lt; std::fixed &lt;&lt; std::setprecision(2) &lt;&lt; g[i][n+1] &lt;&lt; std::endl; return 0;}","link":"/2019/03/17/高斯消元-详解/"},{"title":"CodeForces Round 545(div 2) 题解","text":"跟个sb一样比赛链接今天来改题了。 A题意：找出最长的一段区间使得区间长度是偶数，且区间前一半只有一种数，后一半只有一种数。 $a[i] \\in [1,2], n \\leq 100000$. A solution解：考虑分段。 123举个例子：[1 2 2 1 2 2 2 1 1 2 1]按相同的值分为一段之后就会变成[1 | 2 2 | 1 | 2 2 2 | 1 1 | 2 | 1] 显然目标区间一定会在相邻的两个段里，正确性显然。于是直接计算即可。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546/** * @Author: Mingyu Li * @Date: 2019-03-08T17:07:17+08:00 * @Email: class11limingyu@126.com * @Filename: c1138A.cpp * @Last modified by: Mingyu Li * @Last modified time: 2019-03-09T09:16:10+08:00 */#include &lt;bits/stdc++.h&gt;#define tpname typename#define Go(i , x , y) for(register int i = x; i &lt;= y; i++)#define God(i , y , x) for(register int i = y; i &gt;= x; i--)typedef long long LL;typedef long double ld;typedef unsigned long long ULL;template &lt; tpname T &gt; void sc(T&amp; t) { char c = getchar(); T x = 1; t = 0; while(!isdigit(c)) {if(c == '-') x = -1; c = getchar();} while(isdigit(c)) t = t * 10 + c - '0' , c = getchar();t *= x;}template &lt; tpname T , tpname... Args &gt; void sc(T&amp; t , Args&amp;... args) {sc(t); sc(args...);}template &lt; tpname T &gt; T mul(T x , T y , T _) { x %= _,y %= _; return ((x * y - (T)(((ld)x * y + 0.5) / _) * _) % _ + _) % _;}const int N = 100000 + 10;int pref[3][N] , suf[3][N];int n , ans = 0 , t[N];int main() { sc(n); Go(i,1,n) sc(t[i]); std::vector &lt; int &gt; v; int cnt = 1; Go(i , 2 , n+1) { if(t[i] != t[i - 1]) { v.push_back(cnt); cnt = 0; } cnt++; } Go(i , 0 , (int)v.size() - 2) ans = std::max(ans , std::min(v[i] , v[i + 1]) * 2); std::cout &lt;&lt; ans &lt;&lt; \" \\n\"; return 0;} B题意：给定一张$2$行$n$列的表格$A$.$A[i][j]$代表第$j$个人擅不擅长项目$i$.要求将$n$个人分成2组，每组$n/2$个人。（保证$n$是偶数）并满足第一组擅长项目1的人数=第二组擅长项目2的人数。输出方案。$n \\leq 5000$. B solution解：下文中将默认$(i,j)$为是否擅长项目1与项目2。看起来好像很难下手，但是只需要枚举即可。枚举第一组中$(1,0)$的人数与$(1,1)$的人数。 接着，第一组擅长项目1的人数就确定了，第二组$(1,1)$的人数也确定了，那就可以确定第二组$(0,1)$的人数了。第二组确定了，第一组也能确定。于是第一组的$(0,0)$人数也确定了。第二组随之确定。如果所有人数都合法就输出。如果没有任何一组人数合法，输出$-1$. 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162/** * @Author: Mingyu Li * @Date: 2019-03-08T17:51:24+08:00 * @Email: class11limingyu@126.com * @Filename: c1138B.cpp * @Last modified by: Mingyu Li * @Last modified time: 2019-03-09T10:47:22+08:00 */#include &lt;bits/stdc++.h&gt;#define tpname typename#define Go(i , x , y) for(register int i = x; i &lt;= y; i++)#define God(i , y , x) for(register int i = y; i &gt;= x; i--)typedef long long LL;typedef long double ld;typedef unsigned long long ULL;template &lt; tpname T &gt; void sc(T&amp; t) { char c = getchar(); T x = 1; t = 0; while(!isdigit(c)) {if(c == '-') x = -1; c = getchar();} while(isdigit(c)) t = t * 10 + c - '0' , c = getchar();t *= x;}template &lt; tpname T , tpname... Args &gt; void sc(T&amp; t , Args&amp;... args) {sc(t); sc(args...);}template &lt; tpname T &gt; T mul(T x , T y , T _) { x %= _,y %= _; return ((x * y - (T)(((ld)x * y + 0.5) / _) * _) % _ + _) % _;}int n;std::string a , b;std::vector &lt; int &gt; v00 , v01 , v10 , v11;int main() { v00.clear(); v11.clear(); v01.clear(); v10.clear(); std::cin &gt;&gt; n; std::cin &gt;&gt; a &gt;&gt; b; a = \"%\" + a; b = \"%\" + b; Go(i , 1 , n) { if(a[i] == '1' &amp;&amp; b[i] == '1') v11.push_back(i); else if(a[i] == '0' &amp;&amp; b[i] == '0') v00.push_back(i); else if(a[i] == '0' &amp;&amp; b[i] == '1') v01.push_back(i); else if(a[i] == '1' &amp;&amp; b[i] == '0') v10.push_back(i); } Go(s10 , 0 , (int)(v10.size())) Go(s11 , 0 , (int)(v11.size())) { if(s10 + s11 &gt; n/2) continue; // 选完之后 剩下的s10和s11进入第二组 // 对答案有贡献的只有s11 int g2_s01 = s10 + 2 * s11 - (int)((int)(v11.size())); int g1_s01 = (int)(v01.size()) - g2_s01; if(g2_s01 &gt;= 0 &amp;&amp; g2_s01 &lt;= (int)(v01.size())) { int g1_s00 = n/2 - g1_s01 - s10 - s11; if(g1_s00 &gt;= 0 &amp;&amp; g1_s00 &lt;= (int)(v00.size())) { Go(i , 0 , s11 - 1) std::cout &lt;&lt; v11[i] &lt;&lt; \" \"; Go(i , 0 , s10 - 1) std::cout &lt;&lt; v10[i] &lt;&lt; \" \"; Go(i , 0 , g1_s01 - 1) std::cout &lt;&lt; v01[i] &lt;&lt; \" \"; Go(i , 0 , g1_s00 - 1) std::cout &lt;&lt; v00[i] &lt;&lt; \" \"; puts(\"\"); return 0; } } } puts(\"-1\"); return 0;} C给定一个$n\\times m$大小的表格。要求对于每一个位置$(i,j)$,求出$ans(i,j)$.其中$ans(i,j)$表示将第i行和第j列的某些数更改后使得在满足行内所有数相对大小关系不变，列内所有数相对大小关系不变的情况下，行列内最大值 的最小值。 $n,m \\leq 1000$. 时限2s. C solution解：发现除了$a[i][j]$一个交界点之外，行列之间是独立的。所以，只需要确定$a[i][j]$重新排列之后的排名即可。这玩意很好确定。因为行列之间是独立的，所以答案就是 max(行内比a[i][j]小的数的种数,列内比a[i][j]小的数的种数)+1同理，题目要求最小化最大值。由于行列独立，所以最大值的编号就是 a[i][j]排名+max(行内比a[i][j]大的数的种数,列内比a[i][j]大的数的种数)这个东西可以每行每列一起预处理，复杂度$\\Theta(n^2 log(n))$.12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364/** * @Author: Mingyu Li * @Date: 2019-03-09T10:47:43+08:00 * @Email: class11limingyu@126.com * @Filename: c1138C.cpp * @Last modified by: Mingyu Li * @Last modified time: 2019-03-09T11:57:03+08:00 */#include &lt;bits/stdc++.h&gt;#define tpname typename#define Go(i , x , y) for(register int i = x; i &lt;= y; i++)#define God(i , y , x) for(register int i = y; i &gt;= x; i--)typedef long long LL;typedef long double ld;typedef unsigned long long ULL;template &lt; tpname T &gt; void sc(T&amp; t) { char c = getchar(); T x = 1; t = 0; while(!isdigit(c)) {if(c == '-') x = -1; c = getchar();} while(isdigit(c)) t = t * 10 + c - '0' , c = getchar();t *= x;}template &lt; tpname T , tpname... Args &gt; void sc(T&amp; t , Args&amp;... args) {sc(t); sc(args...);}template &lt; tpname T &gt; T mul(T x , T y , T _) { x %= _,y %= _; return ((x * y - (T)(((ld)x * y + 0.5) / _) * _) % _ + _) % _;}const int N = 1000 + 10;int ans[N][N];int n , m , it;int a[N][N] , b[N];int ans1[N][N] , ans2[N][N] , big1[N][N] , big2[N][N];int p = 0;int main() { sc(n , m); Go(i , 1 , n) Go(j , 1 , m) sc(a[i][j]); Go(i , 1 , n) { p = 0; Go(j , 1 , m) b[++p] = a[i][j]; std::sort(b + 1 , b + p + 1); p = std::unique(b + 1 , b + p + 1) - (b + 1); Go(j , 1 , m) { ans1[i][j] = std::lower_bound(b+1 , b+p+1 , a[i][j]) - b; big1[i][j] = p - ans1[i][j]; } } Go(i , 1 , m) { p = 0; Go(j , 1 , n) b[++p] = a[j][i]; std::sort(b + 1 , b + p + 1); p = std::unique(b + 1 , b + p + 1) - (b + 1); Go(j , 1 , n) { ans2[j][i] = std::lower_bound(b+1 , b+p+1 , a[j][i]) - b; big2[j][i] = p - ans2[j][i]; } } Go(i , 1 , n) { Go(j , 1 , m) printf(\"%d \" , std::max(ans1[i][j] , ans2[i][j]) + std::max(big1[i][j] , big2[i][j])); puts(\"\"); } return 0;} D给定只包含01的字符串$s$和$t$，重排列$s$字符串使得$t$在其中作为子串出现的次数最多。 $|s|,|t| \\leq 500000$. D solution首先考虑最优解一定长成什么样子——一定是一个t串加很多个小节，每加一个小节就会多产生一个$t$子串。有了这部转化就很简单了。容易发现这个小节即为长度为$|t|-border(t)$的$t$串后缀。能输出多少份输出多少份。$border$用$KMP$或$Hash$维护都可以（注意$Hash$被卡） 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990/** * @Author: Mingyu Li * @Date: 2019-03-09T12:54:42+08:00 * @Email: class11limingyu@126.com * @Filename: c1138D.cpp * @Last modified by: Mingyu Li * @Last modified time: 2019-03-09T22:14:16+08:00 */#include &lt;bits/stdc++.h&gt;#define tpname typename#define Go(i , x , y) for(register int i = x; i &lt;= y; i++)#define God(i , y , x) for(register int i = y; i &gt;= x; i--)typedef long long LL;typedef long double ld;typedef unsigned long long ULL;template &lt; tpname T &gt; void sc(T&amp; t) { char c = getchar(); T x = 1; t = 0; while(!isdigit(c)) {if(c == '-') x = -1; c = getchar();} while(isdigit(c)) t = t * 10 + c - '0' , c = getchar();t *= x;}template &lt; tpname T , tpname... Args &gt; void sc(T&amp; t , Args&amp;... args) {sc(t); sc(args...);}template &lt; tpname T &gt; T mul(T x , T y , T _) { x %= _,y %= _; return ((x * y - (T)(((ld)x * y + 0.5) / _) * _) % _ + _) % _;}const int N = 500000 + 5;const ULL P1 = 13331;const ULL P2 = 19260817;const ULL MOD1 = 314159;const ULL MOD2 = (1000000007);ULL Hash1[N] , Hash2[N] , pw1[N] , pw2[N];int cnt[2] , cnt1[2] , n , m;char a[N + 5] , b[N + 5];void Prework() { pw1[0] = pw2[0] = 1; Go(i , 1 , n) pw1[i] = pw1[i - 1] * P1 % MOD1 , pw2[i] = pw2[i - 1] * P2 % MOD2; Go(i , 1 , n) { Hash1[i] = (Hash1[i - 1] * P1 % MOD1 + b[i]) % MOD1; Hash2[i] = (Hash2[i - 1] * P2 % MOD2 + b[i]) % MOD2; }}bool same(int l1, int r1, int l2, int r2) { return ((Hash2[r2] + MOD2 - Hash2[l2 - 1] * pw2[r2 - l2 + 1] % MOD2) % MOD2 == (Hash2[r1] + MOD2 - Hash2[l1 - 1] * pw2[r1 - l1 + 1] % MOD2) % MOD2 &amp;&amp; (Hash1[r2] + MOD1 - Hash1[l2 - 1] * pw1[r2 - l2 + 1] % MOD1) % MOD1 == (Hash1[r1] + MOD1 - Hash1[l1 - 1] * pw1[r1 - l1 + 1] % MOD1) % MOD1);}int LCP() { int ans = 0; Go(i , 1 , n-1) { if(same(1 , i , n-i+1 , n)) ans = i; } return ans;}int main() { scanf(\"%s\" , (a + 1)); scanf(\"%s\" , (b + 1)); m = strlen(a + 1) , n = strlen(b + 1); Prework(); Go(i , 1 , m) cnt[a[i] - '0']++; Go(i , 1 , n) cnt1[b[i] - '0']++; int fill = n - LCP(); if(cnt[0] &lt; cnt1[0] || cnt[1] &lt; cnt1[1]) { Go(i , 1 , m) putchar(a[i]); puts(\"\"); return 0; } cnt[0] -= cnt1[0] , cnt[1] -= cnt1[1]; cnt1[0] = cnt1[1] = 0; Go(i , n - fill + 1 , n) ++cnt1[b[i] - '0']; Go(i , 1 , n) putchar(b[i]); Go(i , 1 , 2147483647) { bool f = 1; Go(j , n - fill + 1 , n) { if(!cnt[b[j] - '0']) { f = 0; break; } putchar(b[j]); cnt[b[j] - '0']--; } if(!f) break; } if(cnt[1]) Go(i , 1 , cnt[1]) putchar('1'); if(cnt[0]) Go(i , 1 , cnt[0]) putchar('0'); return 0;}","link":"/2019/03/09/CF545-div-2-题解/"},{"title":"FFT详解","text":"用于计算一类朴素卷积问题。 笔者学习的是这份博客内容中可能有很多相同之处，敬请谅解。 现在要计算两个一元$n$次多项式$F(x)$与$G(x)$的乘积，如何计算？前置知识：多项式的表示方法一. 系数表示法对于一个$n$次多项式$F(x)$，它可以被表示成 F(x) = a_nx^n+a_{n-1}x^{n-1}+...+a_1x^1+a_0x^0.更加形式化的来说，它可以表示成 F(x) = \\sum_{i=0}^{n} a_ix^i.举个例子，2次多项式，其中$a_0=1,a_1=2,a_2=1$那么$F(x)=1x^2+2x+1.$这样即可通俗的表示出一个$n$次多项式。二. 点值表示法众所周知，两个点确定一个一次函数，三个点确定一个二次函数。所以，$n+1$个点确定一个一元$n$次多项式。所以我们可以通过$n+1$个点来表示它。那么相乘之后的点值如何计算？比如说两个2次多项式$F(x)=x^2+2x+1$（红色）与$G(x)=3x^2-4x-2$（蓝色），它们的图像如图所示：那么观察图中$x=1$时的情况。此时$F(1)=4,G(1)=-3.$所以，显然，$F(1)\\times G(1)=-12$.也就是说在$Z=FG$这一多项式内，带入$1$，得到的结果是$-12$.等等，好像有哪里不对。如果说$Z=FG$的话，那么Z的次数应该是$2n$.那$Z$需要$2n+1$个点来确定。但是原来只需要$n+1$个点，咋办？很简单，在原来的多项式里每个都多加$n$个点即可。反正多项式已知。这样就可以用点值来进行操作。也就是说先转成点值，再一乘，再转回来，就是计算流程。但是好像还是很慢。那么如何优化呢?复数部分复数，即形如$a+bi$的数，其中$i^2=-1.$ $a$称为实部，$bi$称为虚部。或者说：在一个数轴上（只有x轴），我们可以表示出任何实数。那么，多加一维（y轴），也就是类似于平面直角坐标系一样，我们就可以表示出任意一个复数。所以我们把这个坐标系叫做复平面，其中x轴称为实轴，y轴称为虚轴。复数运算复数相加：实部相加，虚部相加，例如 (a+bi)+(c+di)=(a+c)+(b+d)i.复数相减：同理。 (a+bi)-(c+di)=(a-c)+(b-d)i.复数相乘：像一次多项式一样相乘。 注意$i^2=-1$. (a+bi)(c+di)=ac+(ad+bc)i-bd=(ac-bd)+(ad+bc)i.复数相除：相信大家都学过共轭根式。同样的，复数也有共轭。即：$a+bi$的共轭为$a-bi$。这两个复数卡乘在一起一定是个实数。即 (a+bi)(a-bi)=a^2-(bi)^2=a^2+b^2.所以再除的时候，将分子分母同乘分母的共轭，就可以将分母有理化。即 \\frac{a+bi}{c+di}=\\frac{(a+bi)(c-di)}{c^2+d^2}=\\frac{ac+bd}{c^2+d^2}+\\frac{bc-ad}{c^2+d^2}i.复数逆元： \\frac{1}{a+bi}=\\frac{a}{a^2+b^2}-\\frac{b}{a^2+b^2}i.同样的，复数运算在复平面内也有一定规律可循。考虑在复平面内的两个复数：（借张图） 表示的是复数$(1+4i)$与复数$(3+2i)$相乘所得的结果：$(-5+14i)$。设其中$(5,0)$点为位置$P$，则$\\angle{POC}=\\angle{BOA}.$还有：$\\overline{OB}\\times\\overline{OC}=\\overline{OA}.$第二个证明：勾股定理。先把$i$消掉。$\\overline{OB}^2=a^2+b^2.$ $\\overline{OC}^2=c^2+d^2.$$\\overline{OB}^2\\times \\overline{OC}^2=(a^2+b^2)(c^2+d^2)=a^2c^2+a^2d^2+b^2c^2+b^2d^2.$$\\overline{OA}^2=(ac-bd)^2+(ad+bc)^2=a^2c^2+a^2d^2+b^2c^2+b^2d^2.$得证。我们将复数中，复数向量的长度称为模长，向量与x轴正方向的夹角称为幅角。根据上面的东西：复数相乘时，模长相乘，幅角相加。单位根一个n次的单位根即为方程$x^n=1$的复数解。考虑这样一个图：其中圆上的所有复数模长都是1，这个圆称为单位圆。考虑$|x|$的取值范围：如果$|x|","link":"/2019/03/08/FFT详解/"}],"tags":[{"name":"数学","slug":"数学","link":"/tags/数学/"},{"name":"FFT","slug":"FFT","link":"/tags/FFT/"},{"name":"树状数组","slug":"树状数组","link":"/tags/树状数组/"},{"name":"数据结构","slug":"数据结构","link":"/tags/数据结构/"},{"name":"线段树","slug":"线段树","link":"/tags/线段树/"},{"name":"高斯消元","slug":"高斯消元","link":"/tags/高斯消元/"},{"name":"概率期望dp","slug":"概率期望dp","link":"/tags/概率期望dp/"},{"name":"Hash","slug":"Hash","link":"/tags/Hash/"},{"name":"dp","slug":"dp","link":"/tags/dp/"},{"name":"数位dp","slug":"数位dp","link":"/tags/数位dp/"},{"name":"并查集","slug":"并查集","link":"/tags/并查集/"},{"name":"拓扑排序","slug":"拓扑排序","link":"/tags/拓扑排序/"},{"name":"KMP","slug":"KMP","link":"/tags/KMP/"},{"name":"exKMP","slug":"exKMP","link":"/tags/exKMP/"},{"name":"三分法","slug":"三分法","link":"/tags/三分法/"},{"name":"数论","slug":"数论","link":"/tags/数论/"},{"name":"AC自动机","slug":"AC自动机","link":"/tags/AC自动机/"},{"name":"manacher","slug":"manacher","link":"/tags/manacher/"},{"name":"trie","slug":"trie","link":"/tags/trie/"},{"name":"CodeForces","slug":"CodeForces","link":"/tags/CodeForces/"}],"categories":[{"name":"题解","slug":"题解","link":"/categories/题解/"},{"name":"算法笔记","slug":"算法笔记","link":"/categories/算法笔记/"},{"name":"省选复习","slug":"省选复习","link":"/categories/省选复习/"}]}