{"pages":[{"title":"友链","text":"LCJ神仙的博客Dilute神仙的博客欢迎交换友链~","link":"/Links/index.html"},{"title":"关于作者","text":"坐标$Beijing, China$，初二咸鱼$OIer$一枚。常常以$\\text{FST-OIer/LiM_817/LiM-817}$等id到处闲逛。下一步计划是把文化课加强以及去省选打个酱油。$QQ:1504094517$.","link":"/about/index.html"}],"posts":[{"title":"[BJOI2019] 游记","text":"记录第一次省选（雾 $\\huge\\text{Day 0}$ 清明节放假，xjb颓废。切掉了之前口胡过的动态逆序对，树套树，还有去年不会做的$\\text{[NOI2018]归程}$。都是码量大的题，于是写完这些，匆忙复习完$FFT$之后切掉了个$[ZJOI2014]力$就睡觉了。 $\\huge\\text{Day 1}$生物钟一直在搞鬼，让我5点半就起来了。翻来覆去睡不着，最后干脆起来又默写了几遍$linux$下的对拍脚本和多项式乘法。一直以为要带学生卡，找半天没找着，最后发现在夹层里…rp—本来9点练习题测试，我8点就走了，8点15就到了。好不容易等到个学长和学姐，于是就被带进去了。（雾楼上工作人员告诉我们要等会才能签到，于是就又在旁边的机房里默写了一发$FFT$.然后默写的时候负责老师进来了，说：“我们今天在Windows下考试。” wtm 复习那么半天linux对拍干嘛 延时了15分钟才开题。$T1$一时半会没看懂题，先跳。$T2$好像生成树枚举的暴力很好写？我来写写看！ 一个半小时过去了，刚刚写完，而且最多跑到$k=3$.濒临自闭。于是根据赛前的策略，直接跳到$T3$. 诶呀？白送30分？胡乱口胡了一下并且写掉了（假的）30分，此时还剩30分钟。刚刚看懂$T1$，花了15分钟打了个暴力。突然感觉$T3$挺好写的样子，加个哈希就行了。于是就压哨加完了哈希，交卷。 教工食堂好评 甜汤差评 讲题，发现自己好像是假做法但是正确率挺高的？（雾和msq，zjx疯狂斗地主，感觉msq一直在赢（总的来说，没有部分分，时间短，差评。 $\\huge\\text{Day 2}$昨晚cf上了紫，挺开心的，不过也反映出了一些问题，以后加强吧。由于昨天的疏忽考试提前了半个小时，延后了半个小时。早饭硬塞了仨肉包子，喝了碗粥，就滚去考场了。这次系统就成了$linux$，然而由于不知道解压密码而啥也干不了，只能在心里一遍一遍默写各种东西（其实我都不知道我在想什么）8:30,开题。 T1这题意…大模拟有点费时间，跳。T2简明扼要，白送了暴力20分。再加个无向完全图最小生成树个数的结论就能得到30分，好像很可做的样子。T3暴力也很好打…一个一个题写吧。 由于我自己比较sb，硬吃了一个小时T2，总算拼完了subtask，滚去T3.T3我打算按数据点 分治，先写了个20分暴力，剩下的用一种把边换成点，然后二分图匹配的方法玄学套了一下，写完已经11点了。我以为我会在T1上耗很多时间，不过貌似只有中途dfs部分有点懵逼，其他的想一想就fix掉了？于是就愉快的在12点10分写完了0~40分的暴力（复杂度错误）。拍了下T3瞎胡的解法，貌似我没有分连通块考虑？分了之后拍了50组都没事，然后就收卷了… 午饭吃的挺开心，蓝莓泡芙好评，炸酱面好评。 下午上课前又开始斗地主，又开始输…msq是真的欧皇然而为什么一上课就放榜…T3瞎搞做法竟然不对？得分$40+30+20$,rank14.竟然还行？（讲的题听懂了第一个题，后面的杂题选讲听懂了一个可持久化treap的神奇做法就没听了，专心补化学卷子（ 总的来说，好评。 $\\huge\\text{Day 3}$起的很早，发现自己网络最大流板子还没写，就去复习了一遍。之后胡乱吃了一点东西就上考场了？发现zjx这位神仙代打坐到了我的旁边…RP— 开题。T1这种题目见过很多，但是这个咋dp？不会，下一个。T2…没看懂题，不知道是不是必须沿着简单路径。T3好像20分很好写？ 那我先写会T3！匆忙设计了个dp，由于脑子转的慢花了20分钟才写完+过完样例，20分get。看这种只有$n,k$两个变量的题，是不是有规律啊？输出一下dp出来的方案观察观察！ 用了15分钟加了个back数组，观察了一番。诶…貌似是先分成一堆1，然后再从前往后一个一个合成2，再合成别的？突然发现$k=1$或$k=2$很好写，就随手加上了。$k=3$也很好写…观察了一番发现方案$(a,b,c)$中a一定是1，b是一个有规律的东西，c是n-a-b.具体规律好像出现次数是个等差数列？不管了…写了5分钟fix掉了这部分。滚回去写“合成”那部分的。发现合成2的时候是有规律的，好像是末尾有$(n/5)$左右的2，具体的记不清了…貌似我能看出来的规律只存在于$n-k$比$n/5$小？写就完事了…剩下的人就一锅端一开始删掉吧…不管了…写个rand测试了一波，我差不多搞出这些情况能多对1~2个点。分数大概有20+(0~30) 回去写T2.貌似$\\mathcal{O(n^2)}$的还是比较好写？dfs一遍记录个vis数组就可以了。硬上dfs. 诶vis数组只能是bool类型？那我加个bitset卡卡常！（flag1貌似也没快多少啊… （flag2一条链的部分分一会再想，先把T1搞掉。 T1这数据范围有点毒瘤啊…不太会做匆匆打完了暴力 还不一定对滚回去看T3 诶这个dp…决策是不是可以三分啊大胆猜了一下，硬改成了三分，竟然俩样例都过了？借助之前的rand写了个对拍，拍了几百组没问题，那就这样吧（把之前的20分改成了40分。 T2懒得想了。 颓了半个小时五子棋+俄罗斯方块。五子棋我就没赢过一次 午饭真香。为啥吃饭要放摔跤大赛的视频 下午日常斗地主，把msq搞成了一次负分，高兴的一批。竟然是COCI2019的题？妙啊第一个题勉强听懂，后面两个题…告辞…杂题选讲还是听懂不少的。除了最后俩题其他的都差不多？ 课间放榜。总分$0 + 35 + 54$。T1爆0意料之中。T2嘛…为啥我写了20分得到了35分？bitset nb！（破音T3果然能骗到分。排名$rank 26$，不尽如人意。明天加油吧。","link":"/2019/04/06/BJOI2019-游记/"},{"title":"CF Round #446 改题","text":"在机房vp了一番div1，就做了一个题， 于是这篇文章就用来改题了。链接：Here A题目：给定一个数列$a$，共$n$项，求最多修改一项的值（必须修改成整数）之后数列中最长严格上升子段的最大长度。 显然，修改比不修改要优，起码不会劣于原来的答案。那么枚举修改哪一项，向两边延申，这部分可以用前缀/后缀和来解决。注意细节，就做完了。 1234567891011121314151617181920212223242526272829303132/** * @Author: Mingyu Li * @Date: 2019-03-26T17:39:28+08:00 * @Last modified by: Mingyu Li * @Last modified time: 2019-03-26T17:42:17+08:00 */#include &lt;bits/stdc++.h&gt;#define Go(i , x , y) for(register int i = x; i &lt;= y; i++)#define God(i , y , x) for(register int i = y; i &gt;= x; i--)const int N = 100000 + 5;int n , a[N];int pre[N] , suf[N];int main() { scanf(\"%d\" , &amp;n); Go(i , 1 , n) scanf(\"%d\" , &amp;a[i]); Go(i , 1 , n) pre[i] = a[i] &gt; a[i - 1] ? pre[i-1] + 1 : 1; God(i , n , 1) suf[i] = (a[i] &lt; a[i + 1]) ? suf[i + 1] + 1 : 1; int max = std::min(2 , n); Go(i , 1 , n) { // for each ai max = std::max(max , pre[i - 1] + 1); max = std::max(max , suf[i + 1] + 1); if(a[i + 1] - a[i - 1] &lt;= 1 &amp;&amp; i != n &amp;&amp; i != 1) continue; if(i == n) max = std::max(max , pre[i - 1] + 1); else if(i == 1) max = std::max(max , suf[i + 1] + 1); else max = std::max(max , pre[i - 1] + suf[i + 1] + 1); } std::cout &lt;&lt; max &lt;&lt; std::endl; return 0;} B题目：给定$n\\times m$的矩阵，每次可以将一行或一列所有数$-p$，代价是没减之前一行/一列的和。要求做k次，求最大代价。 解法比较有意思。考虑只能每次消一行/一列怎么做$\\rightarrow$是可以愉快的优先队列贪心的。那本质上如果限制了消$i$次行，那一定消了$k-i$次列。答案就是$ansrow[i] + anscol[i] + ?$ $ansrow$和$anscol$都比较好算，重点在于$?$是什么。不难发现，这部分其实就是行列相交的部分，这部分$p$都没有被算上，所以$?=i(k-i)p$. 然后暴力枚举i,就做完了。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354/** * @Author: Mingyu Li * @Date: 2019-03-27T18:56:35+08:00 * @Last modified by: Mingyu Li * @Last modified time: 2019-03-27T20:03:55+08:00 */#include &lt;bits/stdc++.h&gt;#define int long long#define Go(i , x , y) for(register int i = x; i &lt;= y; i++)#define God(i , y , x) for(register int i = y; i &gt;= x; i--)const int N = 1000 + 10;int n , m , a[N][N] , k , p , ansrow[N*N] , anscol[N*N];std::priority_queue &lt;int&gt; q1;signed main() { scanf(\"%I64d%I64d%I64d%I64d\" , &amp;n , &amp;m , &amp;k , &amp;p); Go(i , 1 , n) Go(j , 1 , m) scanf(\"%I64d\" , &amp;a[i][j]); Go(i , 1 , n) { int sum = 0; Go(j , 1 , m) sum += a[i][j]; q1.push(sum); } Go(i , 1 , k) { int x = q1.top(); q1.pop(); ansrow[i] = ansrow[i - 1] + x; q1.push(x - m * p); } while(!q1.empty()) q1.pop(); Go(j , 1 , m) { int sum = 0; Go(i , 1 , n) sum += a[i][j]; q1.push(sum); } Go(i , 1 , k) { int x = q1.top(); q1.pop(); anscol[i] = anscol[i - 1] + x; q1.push(x - n * p); } int ans = LLONG_MIN; Go(i , 0 , k) { int a = i , b = k - i; int total = a * b * p; ans = std::max(ans , ansrow[i] + anscol[k - i] - total); } std::cout &lt;&lt; ans &lt;&lt; std::endl; return 0;}","link":"/2019/03/27/CF-Round-446-改题/"},{"title":"[BZOJ2194] 快速傅里叶之二 题解","text":"题意：求C_k=\\sum_{k}^{n-1}a_ib_{i-k}.$n \\leq 1e5$. 考虑反转数组$a$，生成新数组$a’$.那么C_k=\\sum_{i=k}^{n-1}a'_{n-1-i}b_{i-k},考虑把$i$改成从$0$开始。那么 C_k=\\sum_{i=0}^{n-k-1}a'_{n-k-1-i}b_i.考虑用$\\text{FFT}$计算卷积的标准形式： C'_x=\\sum_{i=0}^{x}A_{x-i}B_i.考虑$x=n-k-1$时的情况： C'_{n-k-1}=\\sum_{i=0}^{n-k-1}a'_{n-k-1-i}b_i.发现$C’$本质上就是将$C$的前$n$个反转了一下，而$C’$是可以直接计算的。于是，可以直接用$\\text{FFT}$计算出$a’$和$b$的卷积$C’$，再反转一下前$n$项，输出前$n$项即可。12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273#include &lt;bits/stdc++.h&gt;#define REP(i , x , y) for(__typeof(y) i = x; i &lt;= y; i++)#define PER(i , y , x) for(__typeof(x) i = y; i &gt;= x; i--)typedef long long LL;typedef long double ld;typedef unsigned long long ULL;/* do not give up ! try your best! Read the meaning clearly! */template &lt; typename T &gt; void Input(T&amp; t) { char c = getchar(); T x = 1; t = 0; while(!isdigit(c)) {if(c == '-') x = -1; c = getchar();} while(isdigit(c)) t = t * 10 + c - '0' , c = getchar();t *= x;}template &lt; typename T , typename... Args &gt; void Input(T&amp; t , Args&amp;... args) {Input(t); Input(args...);}template &lt; typename T &gt; T mul(T x , T y , T _) {x %= _,y %= _;return ((x * y - (T)(((ld)x * y + 0.5) / _) * _) % _ + _) % _;}using namespace std;const int MAXN = 2097152 + 10;const double Pi = acos(-1.0);int a[MAXN] , b[MAXN] , c[MAXN] , n;static complex &lt; double &gt; A[MAXN] , B[MAXN] , C[MAXN];struct FastFourierTransform { complex &lt; double &gt; omega[MAXN] , omegaInverse[MAXN]; void init(int n) { for(int i = 0; i &lt; n; i++) { omega[i] = complex &lt; double &gt; (cos(2 * Pi / n * i) , sin(2 * Pi / n * i)); omegaInverse[i] = conj(omega[i]); } } void Transform(complex &lt; double &gt; *a , const int n , const complex &lt; double &gt; *omega) { int k = 1; while((1 &lt;&lt; k) &lt; n) ++k; for(int i = 0; i &lt; n; i++) { int t = 0; for(int j = 0;j &lt; k; j++) if(i &amp; (1 &lt;&lt; j)) t |= (1 &lt;&lt; (k - 1 - j)); if(i &lt; t) swap(a[i] , a[t]); } for(int l = 2; l &lt;= n; l &lt;&lt;= 1) { int m = (l &gt;&gt; 1); for(complex &lt; double &gt; *p = a; p != a + n; p += l) { for(int i = 0; i &lt; m; i++) { complex &lt; double &gt; k = omega[n / l * i] * p[m + i]; p[m + i] = p[i] - k; p[i] += k; } } } } void DFT(complex &lt; double &gt; *a , int n) { Transform(a , n , omega); } void IDFT(complex &lt; double &gt; *a , int n) { Transform(a , n , omegaInverse); for(int i = 0; i &lt; n; i++) a[i] /= n; }}FFT;int main() { Input(n); for(int i = 0; i &lt; n; i++) Input(a[i] , b[i]); reverse(a , a + n); for(int i = 0; i &lt; n; i++) A[i].real(a[i]) , B[i].real(b[i]); int N = 1; while(N &lt; 2 * n) N &lt;&lt;= 1; FFT.init(N); FFT.DFT(A , N); FFT.DFT(B , N); for(int i = 0; i &lt; N; i++) C[i] = A[i] * B[i]; FFT.IDFT(C , N); for(int i = 0; i &lt; N; i++) c[i] = static_cast &lt; int &gt; (C[i].real() + 0.5); int cnt = 0; for(int i = 0; i &lt; n; i++) printf(\"%d\\n\" , c[n - 1 - i]); return 0;}","link":"/2019/03/09/BZOJ2194-快速傅里叶之二-题解/"},{"title":"[BJWC2018]第k大斜率 题解","text":"还依稀记得半年前的一次模拟赛，这个题我用暴力拿了50分。旧题重做，现在来谈谈我的做法。 这种问题有个很套路的转化方式——假定一个答案，然后二分答案。比如对于假定的答案$k$，如果$(i,j) (x_i&lt;x_j)$连线斜率$\\geq k$： \\frac{y_j-y_i}{x_j-x_i} \\geq ky_j-y_i\\geq k(x_j - x_i)y_j-y_i\\geq kx_j-kx_iy_j-kx_j-(y_i-kx_i)\\geq0y_j-kx_j\\geq (y_i-kx_i)设$f(i)=y_i-kx_i$，则可以变为$f(i)\\leq f(j)$.结合上面的$x_i&lt;x_j$，不难发现就是一个二维偏序：先按$f$排序，之后树状数组按$x$ query即可。 但是我刚开始竟然忘了二维偏序怎么写12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061/** * @Author: Mingyu Li * @Date: 2019-04-04T17:44:49+08:00 * @Last modified by: Mingyu Li * @Last modified time: 2019-04-04T20:25:23+08:00 */#include &lt;bits/stdc++.h&gt;#define go(i , x , y) for(register int i = x; i &lt;= y; i++)#define god(i , y , x) for(register int i = y; i &gt;= x; i--)using namespace std;#define ll long long#define fi first#define se secondconst int N = 100000 + 5;struct Node { ll x, y, rwx, ans;}a[N];int n,m; ll k;ll b[N] , c[N];bool cmp(const Node&amp; u, const Node&amp;v) { return u.ans == v.ans ? u.rwx &lt; v.rwx : u.ans &lt; v.ans;}int query(int x) { int ans = 0; for(;x; x -= (x &amp; -x)) ans += c[x]; return ans;}int upd(int x , int val) { for(; x&lt;= m; x += (x &amp; -x)) c[x] += val;}bool check(int mid) { go(i,1,n) a[i].ans = a[i].y - 1ll * mid * a[i].x; sort(a+1,a+n+1,cmp); memset(c,0,sizeof(c)); ll sum = 0; go(i,1,n) { sum += query(a[i].rwx - 1); upd(a[i].rwx , 1); } return sum &gt;= k;}int main() { scanf(\"%d%lld\", &amp;n, &amp;k); go(i,1,n) { scanf(\"%lld%lld\", &amp;a[i].x, &amp;a[i].y); b[i] = a[i].x; } sort(b+1, b+n+1); m = unique(b+1,b+n+1) - (b+1); go(i,1,n) a[i].rwx = lower_bound(b+1,b+m+1,a[i].x) - b; int l = -(int)(2e8), r = (int)(2e8) , ans = 0; while(l &lt;= r) { int mid = (l + r) &gt;&gt; 1; if(check(mid)) ans = mid , l = mid + 1; else r = mid - 1; } cout &lt;&lt; ans &lt;&lt; endl; return 0;}","link":"/2019/04/04/BJWC2018-第k大斜率-题解/"},{"title":"[BJOI2019省内集训]完美塔防 题解","text":"没学过2-SAT… 亏爆 考虑把每个炮台当做一个01变量，0横着放，1竖着放，再把图转成约束条件。具体来说：如果某一种摆放方式能打到炮台：强制其为false, 即$addedge(true(x), false(x))$某一个空地能被最多两个方向的炮台打到，就可以建立一个or关系。就做完了（雾输出方案就是2-SAT的经典问题了，不过代码中没写123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138#include &lt;bits/stdc++.h&gt;#define mp make_pair#define fi first#define se secondusing namespace std;const int lim = 10000 + 10;const int N = 100 + 5;int T, n, m;vector &lt;int&gt; G[lim];char c[N][N];int cov[2][N][N], fix[N][N], scc, instack[lim] , color[lim];vector &lt;int&gt; v[N][N];int low[lim], dfn[lim];pair &lt;int , int&gt; change(int x, int y) { swap(x, y); if(x != 0) x = -x; if(y != 0) y = -y; return make_pair(x, y);}bool dfs(int x, int y, int dx, int dy, int id) { //cout &lt;&lt; x &lt;&lt; \" \" &lt;&lt; y &lt;&lt; \" \" &lt;&lt; dx &lt;&lt; \" \" &lt;&lt; dy &lt;&lt; \" \" &lt;&lt; id &lt;&lt; endl; if(x &lt; 1 || x &gt; n || y &lt; 1 || y &gt; m || c[x][y] == '#') return 1; if(c[x][y] == '-' || c[x][y] == '|') return 0; cov[id][x][y] = 1; if(c[x][y] == '/') { pair &lt;int, int&gt; nxt = change(dx, dy); return dfs(x + nxt.fi, y + nxt.se, nxt.fi, nxt.se, id); } else if(c[x][y] == '\\\\') return dfs(x + dy, y + dx, dy, dx, id); else if(c[x][y] == '.') return dfs(x + dx, y + dy, dx, dy, id);}stack &lt;int&gt; s;int dfs_clock;void tarjan(int u) { low[u] = dfn[u] = ++dfs_clock; s.push(u); instack[u] = 1; for(int i = 0; i &lt; G[u].size(); i++) { int v = G[u][i]; if(!dfn[v]) tarjan(v), low[u] = min(low[u], low[v]); else if(instack[v]) low[u] = min(low[u], dfn[v]); } if(low[u] == dfn[u]) { ++scc; while(1) { int t = s.top(); s.pop(); instack[t] = 0; color[t] = scc; if(t == u) break; } }}void solve() { while(!s.empty()) s.pop(); scanf(\"%d%d\", &amp;n, &amp;m); for(int i = 1; i &lt;= 10000; i++) G[i].clear(); for(int i = 1; i &lt;= n; i++) scanf(\"%s\", (c[i] + 1)); int cnt = 0; for(int i = 1; i &lt;= n; i++) for(int j = 1; j &lt;= m; j++) fix[i][j] = 0, v[i][j].clear(); memset(low, 0, sizeof(low)); memset(dfn, 0, sizeof(dfn)); memset(color, 0, sizeof(color)); scc = 0; dfs_clock = 0; for(int i = 1; i &lt;= n; i++) for(int j = 1; j &lt;= m; j++) { if(c[i][j] == '-' || c[i][j] == '|') { cnt++; memset(cov, 0, sizeof(cov)); // number : cnt , cnt ^ 1 //cout &lt;&lt; \"now dfs:\" &lt;&lt; i &lt;&lt;\" \" &lt;&lt; j &lt;&lt;endl; int id1 = dfs(i, j-1, 0, -1, 0), id2 = dfs(i, j+1, 0, 1, 0); int id3 = dfs(i-1, j, -1, 0, 1) , id4 = dfs(i+1, j, 1, 0, 1); int num0 = (id1 &amp;&amp; id2); int num1 = (id3 &amp;&amp; id4); if(!num0 &amp;&amp; !num1) { // 都会攻击到别人 puts(\"IMPOSSIBLE\"); //cout &lt;&lt; i &lt;&lt; \" \" &lt;&lt; j &lt;&lt; endl; return ; } // 2 sat 中强制x为false: (~x | ~x) // x = true -&gt; x = false else if(!num0) { for(int k = 1; k &lt;= n; k++) for(int l = 1; l &lt;= m; l++) { if(cov[1][k][l] == 1 &amp;&amp; c[k][l] == '.') v[k][l].push_back(cnt&lt;&lt;1|1); } G[cnt&lt;&lt;1].push_back(cnt&lt;&lt;1|1); } else if(!num1) { for(int k = 1; k &lt;= n; k++) for(int l = 1; l &lt;= m; l++) if(cov[0][k][l] == 1 &amp;&amp; c[k][l] == '.') v[k][l].push_back(cnt&lt;&lt;1); G[cnt&lt;&lt;1|1].push_back(cnt&lt;&lt;1); } else { for(int k = 1; k &lt;= n; k++) { for(int l = 1; l &lt;= m; l++) if(c[k][l] == '.'){ if(cov[0][k][l] &amp;&amp; cov[1][k][l]) fix[k][l] = 1; else if(cov[0][k][l]) v[k][l].push_back(cnt&lt;&lt;1); else if(cov[1][k][l]) v[k][l].push_back(cnt&lt;&lt;1|1); } } } } } for(int i = 1; i &lt;= n; i++) { for(int j = 1; j &lt;= m; j++) if(c[i][j] == '.' &amp;&amp; fix[i][j] != 1){ if(v[i][j].size() == 0) { puts(\"IMPOSSIBLE\"); return ; } else if(v[i][j].size() == 1) { G[v[i][j][0]^1].push_back(v[i][j][0]); } else if(v[i][j].size() == 2) { // 经典的u or v int uu = v[i][j][0], vv = v[i][j][1]; G[uu^1].push_back(vv); G[vv^1].push_back(uu); } } } for(int i = 2; i &lt;= (cnt &lt;&lt; 1 | 1); i++) if(!dfn[i]) tarjan(i); for(int i = 1; i &lt;= (cnt); i++) if(color[i&lt;&lt;1] == color[i&lt;&lt;1|1]) { puts(\"IMPOSSIBLE\"); return ; } puts(\"POSSIBLE\");}int main() { scanf(\"%d\", &amp;T); while(T--) solve(); return 0;}","link":"/2019/04/13/BJOI2019省内集训-完美塔防-题解/"},{"title":"[CF1131D]Gourmet Choice 题解","text":"题意：有两组食物，分别有$n$个和$m$个。给定$n\\times m$的一个表格，其中$a[i][j]$表示第一组第$i$个食物和第二组第$j$个食物的美味度大小关系。请问是否能给出一组美味度方案。如果有，请给出美味度最大值最小的方案。如果没有，请输出No. 先膜LCJ本题如果数据出小一点就是差分约束系统的裸题。但是到了现在的数据大小，差分约束无法承受，所以考虑用并查集+拓扑排序解决。把=的食物用并查集并起来。然后对于&gt;和&lt;的情况，如果这俩元素在一个联通块里，显然不能构造。否则，如果$a[i][j]= ‘&lt;’$就从$i$的连通块向$j$连一条边，反之亦然。然后对联通块跑拓扑排序即可。注意有环也不能构造。正确性很显然：对于$v$，如果被删成了入度$=0$，那么上一次它只需要满足$u$的限制即可。故$value[v] = value[u] + 1$.123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109/** * @Author: Mingyu Li * @Date: 2019-03-09T22:42:11+08:00 * @Email: class11limingyu@126.com * @Filename: c1131D.cpp * @Last modified by: Mingyu Li * @Last modified time: 2019-03-10T06:53:10+08:00 */#include &lt;bits/stdc++.h&gt;#define tpname typename#define Go(i , x , y) for(register int i = x; i &lt;= y; i++)#define God(i , y , x) for(register int i = y; i &gt;= x; i--)typedef long long LL;typedef long double ld;typedef unsigned long long ULL;template &lt; tpname T &gt; void sc(T&amp; t) { char c = getchar(); T x = 1; t = 0; while(!isdigit(c)) {if(c == '-') x = -1; c = getchar();} while(isdigit(c)) t = t * 10 + c - '0' , c = getchar();t *= x;}template &lt; tpname T , tpname... Args &gt; void sc(T&amp; t , Args&amp;... args) {sc(t); sc(args...);}template &lt; tpname T &gt; T mul(T x , T y , T _) { x %= _,y %= _; return ((x * y - (T)(((ld)x * y + 0.5) / _) * _) % _ + _) % _;}const int N = 1000 + 5;int f[N + N];int find(int x) { return x == f[x] ? f[x] : f[x] = find(f[x]);}std::vector &lt;int&gt; v[N + N] , Graph[N + N];std::map &lt;std::pair&lt;int,int&gt;,int&gt; alr;char a[N][N];int n , m;int merge(int u , int v) { f[find(u)] = find(v);}int rf;int degree[N + N] , ans[N + N];void Link(int u , int v) { if(u == v) { rf = 1; return ; } if(alr[{u , v}]) return ; alr[{u , v}] = 1; Graph[u].push_back(v); ++degree[v];}int main() { sc(n , m); Go(i , 1 , n) scanf(\"%s\" , (a[i] + 1)); Go(i , 1 , n+m) f[i] = i; Go(i , 1 , n) Go(j , 1 , m) if(a[i][j] == '=') merge(i , n+j); std::vector &lt;int&gt; v1; Go(i , 1 , n+m) v[find(i)].push_back(i) , v1.push_back(find(i)); Go(i , 1 , n) Go(j , 1 , m) { if(a[i][j] == '&lt;') Link(find(i) , find(n+j)); else if(a[i][j] == '&gt;') Link(find(n+j) , find(i)); } if(rf) { puts(\"No\"); return 0; } std::queue &lt;std::pair &lt;int , int&gt; &gt; Q; sort(v1.begin() , v1.end()); int m1 = unique(v1.begin() , v1.end()) - v1.begin(); std::vector &lt;int&gt; v2; Go(i , 0 , m1-1) if(!degree[v1[i]]) { Q.push({v1[i] , 1}); v2.push_back(v1[i]); for(auto fix : v[v1[i]]) ans[fix] = 1; } while(!Q.empty()) { std::pair &lt; int , int &gt; x = Q.front(); Q.pop(); int u = x.first , va = x.second; for(auto vv : Graph[u]) { degree[vv]--; if(!degree[vv]) { degree[vv] = 0; Q.push({vv , va + 1}); v2.push_back(vv); } } } Go(i , 0 , v2.size() - 1) { for(auto fix : v[v2[i]]) ans[fix] = i + 1; } int ans1 = 0; Go(i , 1 , n+m) ans1 += (degree[find(i)] == 0); //std::cerr &lt;&lt; \"\\n\"; if(ans1 != n+m) { puts(\"No\"); return 0; } std::cout &lt;&lt; \"Yes\\n\"; Go(i , 1 , n) std::cout &lt;&lt; ans[i] &lt;&lt; \" \"; std::cout &lt;&lt; \"\\n\"; Go(i , 1 , m) std::cout &lt;&lt; ans[n + i] &lt;&lt; \" \"; std::cout &lt;&lt; \"\\n\"; return 0;}","link":"/2019/03/10/CF1131D-Gourmet-Choice-题解/"},{"title":"[CF1000F]One Occurrence 题解","text":"一句话题意：给定一个数列，每次询问一段区间内有没有只出现一次的数，如果有随便输出一个，否则输出0. 维护last[i]，就是前一个a[i]的位置. 如果是第一个出现，last[i] = 0.然后对于每一个数，类似于HH的项链一题的做法，将i位置改成last[i], last[i]位置改成inf。这样区间查询的最小值只要&lt;l就有。搞一颗单点修改区间查询的线段树就可以了。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374#include &lt;bits/stdc++.h&gt;#define ls(p) (p&lt;&lt;1)#define rs(p) (p&lt;&lt;1|1)#define fi first#define se secondusing namespace std;const int N = 500000 + 5;const int inf = 0x3f3f3f3f;int n, m;vector &lt;pair&lt;int , int&gt; &gt; q[N];int pre[N], tmp[N], a[N];int mn[N&lt;&lt;2], mnp[N&lt;&lt;2], ans[N&lt;&lt;2];void Pushup(int p) { if(mn[ls(p)] &lt; mn[rs(p)]) {mn[p] = mn[ls(p)]; mnp[p] = mnp[ls(p)];} else {mn[p] = mn[rs(p)]; mnp[p] = mnp[rs(p)];}}void Build(int p, int l, int r) { if(l == r) { mn[p] = inf; mnp[p] = a[l]; return ; } int mid = (l + r) &gt;&gt; 1; Build(ls(p), l, mid); Build(rs(p), mid + 1, r); Pushup(p);}void Update(int p, int x, int y, int l, int r) { if(l == r) { mn[p] = y; return; } if(x &lt; l || x &gt; r) return ; int mid = (l + r) &gt;&gt; 1; if(x &lt;= mid) Update(ls(p), x, y, l, mid); else Update(rs(p), x, y, mid + 1, r); Pushup(p);}pair&lt;int, int&gt; Query(int p, int ql, int qr, int l, int r) { if(ql &lt;= l &amp;&amp; r &lt;= qr) return {mn[p], mnp[p]}; int mid = (l + r) &gt;&gt; 1; pair &lt;int, int&gt; ret = {inf, 0}; if(ql &lt;= mid) ret = min(ret, Query(ls(p), ql, qr, l, mid)); if(qr &gt; mid) ret = min(ret, Query(rs(p), ql, qr, mid + 1, r)); return ret;}int main() { scanf(\"%d\", &amp;n); for(int i = 1; i &lt;= n; i++) scanf(\"%d\", &amp;a[i]), pre[i] = tmp[a[i]], tmp[a[i]] = i; //for(int i = 1; i &lt;= n; i++) cout &lt;&lt; pre[i] &lt;&lt; \" \"; //cout &lt;&lt;endl; scanf(\"%d\", &amp;m); for(int i = 1; i &lt;= m; i++) { int l, r; scanf(\"%d%d\", &amp;l, &amp;r); q[r].push_back({l, i}); } Build(1, 1, n); for(int i = 1; i &lt;= n; i++) { Update(1, i, pre[i], 1, n); if(pre[i]) Update(1, pre[i], inf, 1, n); for(int j = 0; j &lt; q[i].size(); j++) { int l = q[i][j].fi, id = q[i][j].se; //cout &lt;&lt; \"searching query \" &lt;&lt; l &lt;&lt; \" \" &lt;&lt; i &lt;&lt;\"\\n\"; pair &lt;int, int&gt; node = Query(1, l, i, 1, n); if(node.fi &lt; l) { ans[id] = node.se; } else ans[id] = 0; } } for(int i = 1; i &lt;= m; i++) printf(\"%d\\n\", ans[i]); return 0;}","link":"/2019/04/15/CF1000F-One-Occurrence-题解/"},{"title":"DP水题练习","text":"readmore… c189A:直接dp 注意要赋成极小值c698A:瞎dpc987C:跟dp没啥关系…直接强制j枚举i,k就行了c414B:很妙的一个题。需要转为“刷表”法来解决，这样复杂度就会由调和级数变成nklogn.c1005D:边dp边更新 利用前缀和%3来判断","link":"/2019/03/30/DP水题练习/"},{"title":"[Baltic2004]Friends 题解","text":"题意：对于一个字符串$s$,复制一遍之后得到$e$，在$e$的任何位置插入一个字符形成$u$。给定$u$，求字符串$s$. 字符串哈希。 考虑尝试每一个字符，尝试一下去除这个字符之后剩下的字符串是否能成功分成两部分。 用字符串哈希自带的“拼凑”功能即可。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168#pragma GCC optimize(\"2\")#include &lt;bits/stdc++.h&gt;#define PI 3.14159265#define PQ priority_queue#define lowbit(x) ((x) &amp; (-x))#define rep(i , x , y) for(int (i) = (x) ; (i) &lt;= (y) ; ++i)#define per(i , x , y) for(int (i) = (x) ; (i) &gt;= (y) ; --i)//#define lmy#ifdef lmy #define DEBUG printf(\"Passing [%s] in LINE %d...\\n\" , __FUNCTION__ , __LINE__)#endiftypedef long long ll;typedef unsigned long long ull;using namespace std;inline void read(int &amp;x) { int f = 1;x = 0;char ch = getchar(); while(ch &lt; '0' || ch &gt; '9') {if(ch == '-') f = -1; ch = getchar();} while(ch &gt;= '0' &amp;&amp; ch &lt;= '9') {x = x * 10 + ch - '0'; ch = getchar();} x *= f;}inline void readll(ll &amp;x) { ll f = 1;x = 0;char ch = getchar(); while(ch &lt; '0' || ch &gt; '9') {if(ch == '-') f = -1; ch = getchar();} while(ch &gt;= '0' &amp;&amp; ch &lt;= '9') {x = x * 10 + ch - '0'; ch = getchar();} x *= f;}inline void print(int x) { if (x &lt; 0) putchar('-'), x = -x;if (x &gt; 9) print(x / 10);putchar(x % 10 + 48);}inline void printll(ll x) { if (x &lt; 0) putchar('-'), x = -x;if (x &gt; 9) print(x / 10);putchar(x % 10 + 48);}const int MaxN = 2000000 + 5;const ull bse = 13331;char a[MaxN];int n;ull Pw[MaxN] , Hsh[MaxN];vector &lt;int&gt; p;void HshPre() { Pw[0] = 1; rep(i , 1 , n + 1) Pw[i] = Pw[i - 1] * bse; rep(i , 1 , n) { Hsh[i] = Hsh[i - 1] * bse + (ull)(a[i]); }}ull HshValue(int l , int r) { return Hsh[r] - Hsh[l - 1] * Pw[r - l + 1];}ull Merge(int l , int r , int ql , int qr) { // BaoZheng l , r &lt; ql , qr ull HshValue1 = HshValue(l , r) , HshValue2 = HshValue(ql , qr); return HshValue1 * Pw[qr - ql + 1] + HshValue2;}bool Chksame(int l , int r , int ql , int qr) { return HshValue(l , r) == HshValue(ql , qr);}set &lt;ull&gt; obtain;void solve() { cin &gt;&gt; n; scanf(\"%s\" , (a + 1)); //n = strlen(a + 1); if(!(n % 2)) { puts(\"NOT POSSIBLE\"); return ; } HshPre(); rep(i , 1 , n) { if(i == 1) { if(Chksame(2 , (n + 1) / 2 , (n + 1) / 2 + 1 , n) &amp;&amp; !obtain . count(HshValue(2 , (n + 1) / 2))) { // DEBUG; p . push_back(i); obtain . insert(HshValue(2 , (n + 1) / 2)); } } else if(i == n) { if(Chksame(1 , n / 2 , n / 2 + 1 , n - 1) &amp;&amp; !obtain . count(HshValue(1 , n / 2))) { //DEBUG; p . push_back(i); obtain . insert(HshValue(1 , n / 2)); } } else if(i == (n + 1) / 2) { if(Chksame(1 , n / 2 , n - (n / 2) + 1 , n) &amp;&amp; !obtain . count(HshValue(1 , n / 2))) { p . push_back(i) , obtain . insert(HshValue(1 , n / 2)); } } else if(i &gt; (n + 1) / 2) { int l = 1 , r = n / 2; int pl = r + 1 , pr = i - 1; int ppl = i + 1 , ppr = n; ull V = Merge(pl , pr , ppl , ppr); if(V == HshValue(l , r) &amp;&amp; !obtain . count(HshValue(l , r))) { p . push_back(i); obtain . insert(HshValue(l , r)); } } else if(i &lt; (n + 1) / 2) { int l = n - (n / 2) + 1 , r = n; int pl = 1 , pr = i - 1; int ppl = i + 1 , ppr = l - 1; ull V = Merge(pl , pr , ppl , ppr); //if(i == 3) cout &lt;&lt; V &lt;&lt; \"DBG , \" &lt;&lt; HshValue(l , r) &lt;&lt; \" Done\\n\"; if(V == HshValue(l , r) &amp;&amp; !obtain . count(HshValue(l , r))) { p . push_back(i); obtain . insert(HshValue(l , r)); } } } if(p . size() == 0) { puts(\"NOT POSSIBLE\"); return ; } else if(p . size() == 1) { int _ = p[0]; if(_ == 1) { rep(i , (n + 1) / 2 + 1 , n) putchar(a[i]); return ; } else if(_ == n) { rep(i , 1 , n / 2) putchar(a[i]); return ; } else if(_ == (n + 1) / 2) { rep(i , 1 , n / 2) putchar(a[i]); return ; } else if(_ &gt; (n + 1) / 2) { rep(i , 1 , n / 2) putchar(a[i]); return ; } else if(_ &lt; (n + 1) / 2) { rep(i , (n + 1) / 2 + 1 , n) putchar(a[i]); return ; } return ; } else if(p . size() &gt; 1) { puts(\"NOT UNIQUE\"); return ; }}int main(){ #ifdef lmy int nol_cl = clock(); #endif solve(); // did you forget to undefine Lmy ? #ifdef lmy printf(\"\\nTime: %dms\\n\", int((clock() - nol_cl) / (double)CLOCKS_PER_SEC * 1000)); #endif return 0;}","link":"/2019/03/10/Baltic2004-Friends-题解/"},{"title":"[CF55D]Beautiful Number 题解","text":"数位dp进阶题。 如果一个数能被它的所有数位整除，那么他一定可以被那些数位的$LCM$整除。发现$1-9$的$LCM$是$2520$，所以这些数位的$LCM$一定是$2520$的约数，正确性显然。于是就有：如果这个数$mod\\ 2520$能被数位的$LCM$整除，那么这个数同样也能。所以设计状态为：$dp[i][j][k]$为还剩i位没填，之前几位形成的数$mod\\ 2520 = j$，之前所有数位$LCM$为$k$的数的个数。 转移就直接转移就行了。同时发现空间会爆炸，压缩一下$k$就可以了。 计算请参照我的另一篇博客：SCOI2009 windy数。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130/** * @Author: Mingyu Li * @Date: 2019-03-10T10:20:16+08:00 * @Email: class11limingyu@126.com * @Filename: CF55D.cpp * @Last modified by: Mingyu Li * @Last modified time: 2019-03-10T13:12:06+08:00 */#include &lt;bits/stdc++.h&gt;#define tpname typename#pragma GCC optimize(\"O2\")#pragma GCC optimize(\"Ofast\")#pragma GCC optimize(\"inline\")#pragma GCC optimize(\"-fgcse\")#pragma GCC optimize(\"-fgcse-lm\")#pragma GCC optimize(\"-fipa-sra\")#pragma GCC optimize(\"-ftree-pre\")#pragma GCC optimize(\"-ftree-vrp\")#pragma GCC optimize(\"-fpeephole2\")#pragma GCC optimize(\"-ffast-math\")#pragma GCC optimize(\"-fsched-spec\")#pragma GCC optimize(\"unroll-loops\")#pragma GCC optimize(\"-falign-jumps\")#pragma GCC optimize(\"-falign-loops\")#pragma GCC optimize(\"-falign-labels\")#pragma GCC optimize(\"-fdevirtualize\")#pragma GCC optimize(\"-fcaller-saves\")#pragma GCC optimize(\"-fcrossjumping\")#pragma GCC optimize(\"-fthread-jumps\")#pragma GCC optimize(\"-funroll-loops\")#pragma GCC optimize(\"-fwhole-program\")#pragma GCC optimize(\"-freorder-blocks\")#pragma GCC optimize(\"-fschedule-insns\")#pragma GCC optimize(\"inline-functions\")#pragma GCC optimize(\"-ftree-tail-merge\")#pragma GCC optimize(\"-fschedule-insns2\")#pragma GCC optimize(\"-fstrict-aliasing\")#pragma GCC optimize(\"-fstrict-overflow\")#pragma GCC optimize(\"-falign-functions\")#pragma GCC optimize(\"-fcse-skip-blocks\")#pragma GCC optimize(\"-fcse-follow-jumps\")#pragma GCC optimize(\"-fsched-interblock\")#pragma GCC optimize(\"-fpartial-inlining\")#pragma GCC optimize(\"no-stack-protector\")#pragma GCC optimize(\"-freorder-functions\")#pragma GCC optimize(\"-findirect-inlining\")#pragma GCC optimize(\"-frerun-cse-after-loop\")#pragma GCC optimize(\"inline-small-functions\")#pragma GCC optimize(\"-finline-small-functions\")#pragma GCC optimize(\"-ftree-switch-conversion\")#pragma GCC optimize(\"-foptimize-sibling-calls\")#pragma GCC optimize(\"-fexpensive-optimizations\")#pragma GCC optimize(\"-funsafe-loop-optimizations\")#pragma GCC optimize(\"inline-functions-called-once\")#pragma GCC optimize(\"-fdelete-null-pointer-checks\")#define Go(i , x , y) for(register int i = x; i &lt;= y; i++)#define God(i , y , x) for(register int i = y; i &gt;= x; i--)typedef long long LL;typedef long double ld;typedef unsigned long long ULL;template &lt; tpname T &gt; void sc(T&amp; t) { char c = getchar(); T x = 1; t = 0; while(!isdigit(c)) {if(c == '-') x = -1; c = getchar();} while(isdigit(c)) t = t * 10 + c - '0' , c = getchar();t *= x;}template &lt; tpname T , tpname... Args &gt; void sc(T&amp; t , Args&amp;... args) {sc(t); sc(args...);}template &lt; tpname T &gt; T mul(T x , T y , T _) { x %= _,y %= _; return ((x * y - (T)(((ld)x * y + 0.5) / _) * _) % _ + _) % _;}LL t;LL l , r , m , d[25];LL dp[20][2525][55];LL num[2525];LL ca1l(LL x) { return x &lt; 2520 ? x : x - (x / 2520) * 2520;}// dp[x][y][z]: 还剩x位 前面数%2520 = y 前面所有数lcm=zLL lcm(LL x , LL y) { if(x &lt; y) std::swap(x,y); return !y ? x : x/std::__gcd(x,y)*y;}LL F(LL x , LL y , LL z) { if(dp[x][y][num[z]] != -1) return dp[x][y][num[z]]; if(x == 0) return dp[x][y][num[z]] = (z == 0 || (y / z) * z == y) ? 1 : 0; LL ans = 0; Go(q , 0 , 9) { ans += F(x-1 , ca1l((y * 10 + q)) , lcm(z , q)); } return dp[x][y][num[z]] = ans;}LL cal(LL x) { m = 0; while(x) { d[m++] = x%10; x /= 10; } LL ans = 0; Go(i , 1 , m-1) { Go(j , 1 , 9) ans += F(i-1 , j , j); } LL times=0 , lc=1; God(i , m-1 , 0) { Go(j , (i == m-1) ? 1 : 0 , d[i]-1) { ans += F(i ,ca1l(times * 10 + j) , lcm(lc , j)); } times = ca1l(times * 10 + d[i]); lc = lcm(lc , d[i]); } return ans;}int main() { memset(dp , -1 , sizeof(dp)); std::cin &gt;&gt; t; num[0] = 1; int cnt = 1; Go(i , 1 , 2520) if(2520 % i == 0) num[i] = ++cnt; while(t--) { std::cin &gt;&gt; l &gt;&gt; r; std::cout &lt;&lt; cal(r+1) - cal(l) &lt;&lt; std::endl; } return 0;}","link":"/2019/03/10/CF55D-Beautiful-Number-题解/"},{"title":"[CF628D]Magic Numbers 题解","text":"比较友好的数位$dp$练手题。 设$dp(i,j,k=0/1)$表示还剩$i$位，前几位表示的数$\\equiv\\text{ j (mod m)}$，此位是否为偶数位的数的个数。 如果$k=0$，那么这一位一定不能是$d$。否则一定得是$d$。大力转移即可。边界：$dp(0,0,0/1)=1$. 特别注意本题并不需要高精$+1$操作，只需要特判$b$一个数即可。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596/** * @Author: Mingyu Li * @Date: 2019-03-10T15:39:26+08:00 * @Email: class11limingyu@126.com * @Filename: cf628D.cpp * @Last modified by: Mingyu Li * @Last modified time: 2019-03-10T20:44:04+08:00 */#include &lt;bits/stdc++.h&gt;#define tpname typename#define Go(i , x , y) for(register int i = x; i &lt;= y; i++)#define God(i , y , x) for(register int i = y; i &gt;= x; i--)typedef long long LL;typedef long double ld;typedef unsigned long long ULL;template &lt; tpname T &gt; void sc(T&amp; t) { char c = getchar(); T x = 1; t = 0; while(!isdigit(c)) {if(c == '-') x = -1; c = getchar();} while(isdigit(c)) t = t * 10 + c - '0' , c = getchar();t *= x;}template &lt; tpname T , tpname... Args &gt; void sc(T&amp; t , Args&amp;... args) {sc(t); sc(args...);}template &lt; tpname T &gt; T mul(T x , T y , T _) { x %= _,y %= _; return ((x * y - (T)(((ld)x * y + 0.5) / _) * _) % _ + _) % _;}const int N = 2000 + 5;const int mod = (int)(1e9 + 7);int m , D , p;std::string a,b;int d[2000];// f[i][j][k]:// 还剩i位 前几位组成的数%m = j 是否是偶数位int dp[N][N][2];int f(int i , int j ,int k) { if(dp[i][j][k] != -1) return dp[i][j][k]; if(i == 0) return dp[i][j][k] = j%m == 0 ? 1 : 0; int ans = 0; Go(x , 0 , 9) { if(k == 1 &amp;&amp; x != D) continue; if(k == 0 &amp;&amp; x == D) continue; ans = (ans + f(i-1 , (j*10 + x)%m , k^1)) % mod; } return dp[i][j][k] = ans;}int cal(std::string x) { p = 0; while(!x.empty()) { d[p++] = x.back() - '0'; x.pop_back(); } int op=0 , ans=0; God(i , p-1 , 1) { Go(j , 1 , 9) { if(j == D) continue; ans = (ans + f(i-1 , j%m , 1)) % mod; } } op = 0; int lst = 0; God(i , p-1 , 0) { Go(j , (i == p-1) ? 1 : 0 , d[i] - 1) { if(op == 1 &amp;&amp; j != D) continue; if(op == 0 &amp;&amp; j == D) continue; ans = (ans + f(i , (lst * 10 + j) % m , op^1)) % mod; } if(op == 1 &amp;&amp; d[i] != D) break; if(op == 0 &amp;&amp; d[i] == D) break; op = 1 - op; lst = (lst * 10 + d[i]) % m; } return ans;}int main() { memset(dp , -1 , sizeof(dp)); sc(m , D); std::cin &gt;&gt; a &gt;&gt; b; int ans = (cal(b) - cal(a) + mod) % mod; bool f = 1 , op = 0; int m1 = 0; Go(i , 0 , (int)(b.size()) - 1) { if(op == 0 &amp;&amp; b[i]-'0'== D) f = 0; if(op == 1 &amp;&amp; b[i]-'0' != D) f = 0; op = op^1; } for(char x : b) m1 = (m1 * 10 + x - '0')%m; ans += (f &amp; (m1 == 0)); ans %= mod; std::cout &lt;&lt; ans &lt;&lt; std::endl; return 0;}","link":"/2019/03/11/CF628D-Magic-Numbers-题解/"},{"title":"[HDU2089]不要62 题解","text":"数位dp. 设$dp(i,j)$为还差$i$位，上一位为$j$的方案数。 限制不能填4或者不能填相邻的62就完事了。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263/** * @Author: Mingyu Li * @Date: 2019-03-14T13:44:58+08:00 * @Email: class11limingyu@126.com * @Filename: HDU2089.cpp * @Last modified by: Mingyu Li * @Last modified time: 2019-03-14T14:02:19+08:00 */#include &lt;bits/stdc++.h&gt;#define Go(i , x , y) for(register int i = x; i &lt;= y; i++)#define God(i , y , x) for(register int i = y; i &gt;= x; i--)typedef long long LL;template &lt; typename T &gt; void sc(T&amp; t) { char c = getchar(); T x = 1; t = 0; while(!isdigit(c)) {if(c == '-') x = -1; c = getchar();} while(isdigit(c)) t = t * 10 + c - '0' , c = getchar();t *= x;}template &lt; typename T , typename... Args &gt; void sc(T&amp; t , Args&amp;... args) {sc(t); sc(args...);}LL dp[20][11] , d[20];// dp(i,j) : 还差i位 上一位是x，接下来不同的数的个数LL f(LL i , LL j) { if(dp[i][j] != -1) return dp[i][j]; if(!i) return dp[i][j] = 1; else { LL ans = 0; Go(digit , 0 , 9) if(digit != 4 &amp;&amp; !(j == 6 &amp;&amp; digit == 2)) ans += f(i-1 , digit); return dp[i][j] = ans; }}LL calc(LL x) { int m = 0; while(x) { d[m++] = x%10; x/=10; } LL ans = 0; Go(i , 1 , m-1) { Go(j , 1 , 9) if(j != 4) ans += f(i-1 , j); }// std::cerr &lt;&lt;\"%% \" &lt;&lt; ans &lt;&lt; std::endl; int last = 0; God(i , m-1 , 0) { Go(j , (i == m-1) ? 1 : 0 , d[i]-1) if(j != 4 &amp;&amp; !(last == 6 &amp;&amp; j == 2)) ans += f(i , j); if(d[i] == 4) break; if(last == 6 &amp;&amp; d[i] == 2) break; last = d[i]; } return ans;}int main() { memset(dp , -1 , sizeof(dp)); LL l , r; while(1) { sc(l , r); if(!l &amp;&amp; !r) return 0; //std::cout &lt;&lt; calc(l) &lt;&lt; std::endl; std::cout &lt;&lt; calc(r+1) - calc(l) &lt;&lt; std::endl; } return 0;}","link":"/2019/03/14/HDU2089-不要62-题解/"},{"title":"[PKUPC2019E]Coprime 题解","text":"把$\\Theta(nlog^2n)$的复杂度算成$\\Theta(n^2)$的后果…我要向全队人民谢罪 先推一步式子： \\begin{aligned} ans&=\\sum_{i = l} ^ {r}[(a_i,x)==1]\\\\ &=\\sum_{i = l} ^ {r} \\epsilon(a_i,x)\\\\ &=\\sum_{i = l} ^ {r} \\sum_{d | a_i, d | x} \\mu(d)\\\\ &=\\sum _ {d|x} \\mu(d) \\red{\\sum_{i = l} ^ {r}[(ai,d)==d]}\\\\ \\end{aligned}然后我一看：这玩意复杂度比暴力还高…不会做了事实上对于$1~100000$中的任意一个数，它的因子个数大概是log级别的。所以，后面那个东西可以通过vector+二分得到。所以这玩意复杂度实际上是双log的，暴力模拟即可。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899#include &lt;bits/stdc++.h&gt;#define dbg(x) std::cerr &lt;&lt; #x &lt;&lt; \" = \" &lt;&lt; x &lt;&lt; \"\\n\"using namespace std;typedef long long ll;const int N = 100000 + 10;int t, n, m, a[N];int mu[N], prime[N], np[N], cnt, smallest[N];void pre() { np[1] = mu[1] = 1; for(int i = 2; i &lt;= 100000; i++) { if(!np[i]) prime[++cnt] = i, mu[i] = -1, smallest[i] = i; for(int j = 1; j &lt;= cnt &amp;&amp; i * prime[j] &lt;= 100000; j++) { np[i * prime[j]] = 1; smallest[i * prime[j]] = prime[j]; if(i % prime[j] == 0) {mu[i * prime[j]] = 0;break;} else mu[i * prime[j]] = -mu[i]; } }}vector &lt;int&gt; divisior, v;vector &lt;int&gt; pool[N];int cont[N];int sz, ans;int bs(int id, int x) { if(pool[id].size() == 0) return 0; if(pool[id][(int)pool[id].size() - 1] &lt; x) return pool[id].size(); if(pool[id][0] &gt;= x) return 0; int l = 0, r = (int)(pool[id].size()) - 1, ans = 0; while(l &lt;= r) { int mid = (l + r) &gt;&gt; 1; if(pool[id][mid] &lt; x) ans = mid, l = mid + 1; else r = mid - 1; } return ans + 1;}int query(int id, int l, int r) { int ans = min(bs(id, r + 1) - bs(id, l), (int)pool[id].size()); return ans;}void dfs(int cur, int d) { if(cur == sz) { if(!cont[d]) cont[d] = true, v.push_back(d); return ; } dfs(cur + 1, d * divisior[cur]); dfs(cur + 1, d);}void dfs2(int cur, int d, int l, int r) { if(cur == sz) { if(!cont[d]) cont[d] = 1, v.push_back(d), ans += mu[d] * query(d, l, r); return ; } dfs2(cur + 1, d * divisior[cur], l, r); dfs2(cur + 1, d , l, r);}void solve() { scanf(\"%d%d\", &amp;n, &amp;m); for(int i = 1; i &lt;= n; i++) scanf(\"%d\", &amp;a[i]); for(int i = 1; i &lt;= 100000; i++) pool[i].clear(); for(int i = 1; i &lt;= n; i++) { v.clear(); divisior.clear(); int cp = a[i]; while(cp != 1) { divisior.push_back(smallest[cp]); cp /= smallest[cp]; } sz = divisior.size(); dfs(0, 1); for(int j = 0; j &lt; v.size(); j++) { pool[v[j]].push_back(i); cont[v[j]] = 0; } } int d = 0; while(m--) { int l, r, x; scanf(\"%d%d%d\", &amp;l, &amp;r, &amp;x); l ^= d, r ^= d, x ^= d; int curx = x; ans = 0; divisior.clear(); v.clear(); while(curx != 1) { divisior.push_back(smallest[curx]); curx /= smallest[curx]; } sz = divisior.size(); dfs2(0, 1, l, r); d = ans; printf(\"%d\\n\", d); for(int j = 0; j &lt; v.size(); j++) cont[v[j]] = 0; } for(int i = 0; i &lt; v.size(); i++) cont[v[i]] = 0;}int main() { scanf(\"%d\", &amp;t); pre(); while(t--) solve(); return 0;}","link":"/2019/05/16/PKUPC2019E-Coprime-题解/"},{"title":"[HNOI2011]XOR和路径 题解","text":"运用高斯消元来$dp$. XOR的期望比较难算。我们可以针对每一位算出期望，再加起来。于是，我们只需要算出第i位是1的概率，在$\\times 2^i$，加起来即可。怎么$dp$？设$dp[u]$表示从$u$到$n$点时第$i$位为1的概率。那么考虑所有u连向的节点v，即可转移： dp[u]=\\sum_{(u\\rightarrow v)\\in E\\ and\\ w\\ bitand \\ bit ==1}\\frac{(1-dp[v])}{dg[u]}+\\sum_{(u\\rightarrow v)\\in E\\ and\\ w\\ bitand \\ bit ==0}\\frac{(dp[v])}{dg[u]}含义是，$u$到$v$概率乘上对应$v$的概率，再加起来即可。同样的，使用高斯消元解$dp$数组。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081/** * @Author: Mingyu Li * @Date: 2019-03-19T20:22:18+08:00 * @Last modified by: Mingyu Li * @Last modified time: 2019-03-19T21:23:07+08:00 */#include &lt;bits/stdc++.h&gt;#define Go(i , x , y) for(register int i = x; i &lt;= y; i++)#define God(i , y , x) for(register int i = y; i &gt;= x; i--)const int N = 100 + 5;// dp[u] : u点 第i位为1的概率// dp[u] = \\sum_{(u , v) &amp; bit} (1 - dp[v]) * (1 / deg[u]) + \\sum_{u , v &amp; bit == 0} dp[v] * (1 / deg[u])// dp[u] = (1 / deg[u]) ...// \\sum_{u , v &amp; bit} -1 = -deg[u]dp[u] + \\sum_{(u , v) &amp; bit} -dp[v] + \\sum_{u , v &amp; bit == 0} dp[v]// deg[u]dp[u] = \\sum_{(u , v) &amp; bit} (1 - dp[v]) + \\sum_{u , v &amp; bit == 0} dp[v]void chkmax(int&amp; a , int b) {a = std::max(a, b);}// dp[n] = 0int n, m, mx , dg[N];std::vector &lt;std::pair &lt;int,int&gt; &gt; G[N];double g[N][N];void Build(int bit) { memset(g , 0 , sizeof(g)); g[n][n] = 1; Go(i , 1 , n-1) { g[i][i] = -dg[i]; for(int j = 0; j &lt; (int)(G[i].size()); j++) { int v = G[i][j].first , w = G[i][j].second; if(w&amp;bit) { g[i][n+1]--, g[i][v]--; } else g[i][v]++; } }}void Gauss() { Go(i , 1 , n) { int now = i; Go(j , i+1 , n) if(fabs(g[now][i]) &lt; fabs(g[j][i])) now = j; Go(j , 1 , n+1) std::swap(g[now][j] , g[i][j]); Go(j , i+1 , n+1) g[i][j] /= g[i][i]; g[i][i] = 1; Go(j , i+1 , n) { Go(k , i+1 , n+1) { g[j][k] -= g[j][i] * g[i][k]; } g[j][i] = 0; } } God(i , n , 1) { Go(j , i+1 , n) g[i][n+1] -= g[i][j] * g[j][n+1]; g[i][n+1] /= g[i][i]; g[i][i] = 1; }}int main() { scanf(\"%d%d\" , &amp;n , &amp;m); Go(i , 1 , m) { int u , v , w; scanf(\"%d%d%d\" , &amp;u , &amp;v , &amp;w); G[u].push_back({v, w}); ++dg[u]; if(u == v) continue; G[v].push_back({u , w}); ++dg[v]; chkmax(mx , w); // 自环 } double ans = 0; for(int bit = 1; bit &lt;= mx; bit &lt;&lt;= 1) { Build(bit); Gauss(); ans += g[1][n+1] * bit; } std::cout &lt;&lt; std::fixed &lt;&lt; std::setprecision(3) &lt;&lt; ans &lt;&lt; std::endl; return 0;}","link":"/2019/03/20/HNOI2011-XOR和路径-题解/"},{"title":"[JSOI2008]球形空间产生器 题解","text":"第一道应用高斯消元的题目。题目本质上就是对于$n$个给定点$a$和圆心$x$，有如下关系： \\sum_{i=1}^{n}(a_i - x_i)^2 = R^2让你求$x$. 使用高斯消元解决。考虑相邻给出的两个点$a_i$和$b_i$，有： \\begin{cases} \\sum\\limits_{i=1}^{n}(a_i - x_i)^2 = R^2&①\\\\ \\\\ \\sum\\limits_{i=1}^{n}(b_i - x_i)^2 = R^2&②\\\\ \\end{cases}①-②:\\sum_{i=1}^{n}(a_i^2-2a_ix_i-b_i^2+2b_ix_i)=0.移项+提取公因式： \\sum_{i=1}^{n}[2x_i(a_i-b_i)]=\\sum_{i=1}^{n}(a_i^2-b_i^2).右边已知（可以当作常数），左边是一个关于$x$的$n$元方程组。于是就可以愉快套板子了。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364/** * @Author: Mingyu Li * @Date: 2019-03-17T11:46:23+08:00 * @Email: class11limingyu@126.com * @Filename: P4035.cpp * @Last modified by: Mingyu Li * @Last modified time: 2019-03-17T14:30:02+08:00 */#include &lt;bits/stdc++.h&gt;#define Go(i , x , y) for(register int i = x; i &lt;= y; i++)#define God(i , y , x) for(register int i = y; i &gt;= x; i--)typedef long long LL;template &lt; typename T &gt; void sc(T&amp; t) { char c = getchar(); T x = 1; t = 0; while(!isdigit(c)) {if(c == '-') x = -1; c = getchar();} while(isdigit(c)) t = t * 10 + c - '0' , c = getchar();t *= x;}template &lt; typename T , typename... Args &gt; void sc(T&amp; t , Args&amp;... args) {sc(t); sc(args...);}const int N = 105;int n;double g[N][N] , p[N][N];void Gauss() { Go(i , 1 , n) { int now = i; Go(j , i+1 , n) if(fabs(g[now][i]) &lt; fabs(g[j][i])) now = j; Go(j , 1 , n+1) std::swap(g[i][j] , g[now][j]); Go(j , i+1 , n+1) g[i][j] /= g[i][i]; g[i][i] = 1; Go(j , i+1 , n) { Go(k , i+1 , n+1) g[j][k] -= g[j][i] * g[i][k]; g[j][i] = 0; } } God(i , n , 1) { Go(j , i+1 , n) g[i][n+1] -= g[i][j] * g[j][n+1]; g[i][n+1] /= g[i][i]; g[i][i] = 1; }}int main() { sc(n); Go(i , 1 , n+1) Go(j , 1 , n) scanf(\"%lf\" , &amp;p[i][j]); Go(i , 1 , n) { Go(j , 1 , n) { double times = 2 * (p[i][j] - p[i+1][j]); g[i][j] = times; g[i][n+1] += (p[i][j] * p[i][j] - p[i+1][j] * p[i+1][j]); } } Gauss(); Go(i , 1 , n) std::cout &lt;&lt; std::fixed &lt;&lt; std::setprecision(3) &lt;&lt; g[i][n+1] &lt;&lt; \" \"; std::cout &lt;&lt; \"\\n\"; return 0;}","link":"/2019/03/17/JSOI2008-球形空间产生器-题解/"},{"title":"KMP&exKMP详解","text":"终于补掉了KMP经久不衰的坑（雾来写一下吧w KMP可以用来解决一类字符串匹配问题。例如b串在a串中出现的次数。那么具体是怎么实现的呢？通过“大跳”——next数组来实现。这里先说一下next的定义：$next[i]$表示$b[1…i]$中最长的相同前后缀（border）的长度。特别的，$next[1]=0$.举个例子！ $b : “ABA”$ 那么拿$next[3]$举例：$b[1…3]$中最长相同的前后缀为$A$，长度为$1$，故$next[3]=1$. 怎么求出$next$数组呢？我会哈希！显然，哈希也可以直接解决字符串匹配问题。那么既然是个算法，就一定有比$hash$巧妙的办法。 考虑把$next$数组按照类似于$dp$的方式递推转移（见下图）。 我们发现，计算$next[i]$本质上就是找到最长的两段红色序列，使得红色序列相等且下一个黄色也相等。 通俗的说，就是找一段$b[1…x]$，使得$b[1…x] = b[(x-1)-x+1 … (x-1)]$的同时还满足$b[x+1] = b[i]$. 然后有个很显然的东西：一个串的border的border一定是原串的border. 所以就往回一直跳就完事了。 1234567fail[1] = 0;for(int i = 2;i &lt;= lb;i++){ int j = fail[i - 1]; while(j &amp;&amp; b[j + 1] != b[i]) j = fail[j]; if(b[j + 1] == b[i]) fail[i] = j + 1; else fail[i] = 0;} 那么如何用next数组优化找字符串呢？ 考虑用一个指针$j$，指向目前匹配完了$b[j]$.再次画图： 然后我发现我们通过固定i挪动j的位置，就可以合理匹配！ 具体的，就是保证b串不回滚。由于我们已经匹配完了j个，那么跳个border一定还能匹配，就像这样： 不停的跳，直到匹配或者确定不能匹配为止。 上代码：12345678910for(int i = 1 , j = 0;i &lt;= la;i++){ while(j &amp;&amp; b[j + 1] != a[i]) j = fail[j]; if(b[j + 1] == a[i]){ j++; } if(j == lb){ ++res; j = fail[j]; // mark1 }} 特别注意，有些题里找子串可以重复，有些题不能。如果不能的话，就把$mark1$处改成$j=0$. （重新开始） 那么KMP板子就写完了。附上luogu模板题代码：1234567891011121314151617181920212223242526272829303132333435363738394041#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstdlib&gt;//#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;set&gt;#include &lt;map&gt;#include &lt;vector&gt;#define pb push_backusing namespace std;const int MAXN = 1000000 + 10;char a[MAXN] , b[MAXN];static int fail[MAXN];int main(){ scanf(\"%s%s\" , (a + 1) , (b + 1)); int la = strlen(a + 1); int lb = strlen(b + 1); fail[1] = 0; for(int i = 2;i &lt;= lb;i++){ int j = fail[i - 1]; while(j &amp;&amp; b[j + 1] != b[i]) j = fail[j]; if(b[j + 1] == b[i]) fail[i] = j + 1; else fail[i] = 0; } for(int i = 1 , j = 0;i &lt;= la;i++){ while(j &amp;&amp; b[j + 1] != a[i]) j = fail[j]; if(b[j + 1] == a[i]){ j++; } if(j == lb){ cout &lt;&lt; i - lb + 1 &lt;&lt; \"\\n\"; j = fail[j]; } } for(int i = 1;i &lt;= lb;i++) cout &lt;&lt; fail[i] &lt;&lt; \" \"; return 0;} exkmp好像可以直接用哈希+二分水过去…不学了（雾","link":"/2019/03/15/KMP-exKMP详解/"},{"title":"[NOI2014]动物园 题解","text":"妙啊 考虑一个简化的问题：如果没有前后缀不能相交的限制怎么办？这个问题可以轻易的用$KMP+DP$解决。具体的，就是$dp[i]=dp[next[i]]+1$. 特别注意$dp[1]=1$. 那么解决了这个简化版的问题之后，原问题就可以转化为求一个最长的$a[1…i]$的border的dp值，同时前后缀border不相交。（也就是说$|border|\\leq i/2$） 显然暴力往回跳$next$不太现实。那咋办？很简单，你咋维护$next$的就咋维护这个。保证$j$的总操作次数不超过一个特定的极限即可。（具体看代码吧） 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152/** * @Author: Mingyu Li * @Date: 2019-03-16T16:11:25+08:00 * @Email: class11limingyu@126.com * @Filename: P2375.cpp * @Last modified by: Mingyu Li * @Last modified time: 2019-03-16T20:44:23+08:00 */#include &lt;bits/stdc++.h&gt;#define Go(i , x , y) for(register int i = x; i &lt;= y; i++)#define God(i , y , x) for(register int i = y; i &gt;= x; i--)typedef long long LL;template &lt; typename T &gt; void sc(T&amp; t) { char c = getchar(); T x = 1; t = 0; while(!isdigit(c)) {if(c == '-') x = -1; c = getchar();} while(isdigit(c)) t = t * 10 + c - '0' , c = getchar();t *= x;}template &lt; typename T , typename... Args &gt; void sc(T&amp; t , Args&amp;... args) {sc(t); sc(args...);}const int N = 1000000 + 5;char a[N];int t , next[N] , cnt[N] , ans[N];int main() { sc(t); while(t--) { memset(next , 0 , sizeof(next)); memset(cnt , 0 , sizeof(cnt)); memset(ans , 0 , sizeof(ans)); scanf(\"%s\" , (a+1)); int n = strlen(a+1); LL mult = 1; next[1] = 0 , ans[1] = 1; Go(i , 2 , n) { int j = next[i-1]; while(j &amp;&amp; a[j+1] != a[i]) j = next[j]; if(a[j+1] == a[i]) next[i] = j+1 , j++; else next[i] = 0; ans[i] = ans[j] + 1; } //Go(i , 1 , n) std::cerr &lt;&lt; ans[i] &lt;&lt; \" \"; //std::cerr &lt;&lt; \"\\n\"; for(int i=2 , j=0; i &lt;= n; i++) { while(j &amp;&amp; a[j+1] != a[i]) j = next[j]; if(a[j+1] == a[i]) ++j; while((j &lt;&lt; 1) &gt; i) j = next[j]; mult = mult * (ans[j] + 1) % (LL)(1e9 + 7); } printf(\"%lld\\n\" , mult); } return 0;}","link":"/2019/03/16/NOI2014-动物园-题解/"},{"title":"[POI2006]OKR-Periods of Words 题解","text":"妙啊+1. 一般题目会让你求最小周期，这个让你求最大周期，咋办？就是不停的跳$next$，直到不能跳了为止。红色部分为不能继续跳的$next$部分。不难通过一一对应及$border$的性质证明。 加个记忆化，这个题就做完了。 123456789101112131415161718192021222324252627282930313233343536373839404142/** * @Author: Mingyu Li * @Date: 2019-03-16T23:00:02+08:00 * @Email: class11limingyu@126.com * @Filename: P3435.cpp * @Last modified by: Mingyu Li * @Last modified time: 2019-03-16T23:10:37+08:00 */#include &lt;bits/stdc++.h&gt;#define Go(i , x , y) for(register int i = x; i &lt;= y; i++)#define God(i , y , x) for(register int i = y; i &gt;= x; i--)typedef long long LL;template &lt; typename T &gt; void sc(T&amp; t) { char c = getchar(); T x = 1; t = 0; while(!isdigit(c)) {if(c == '-') x = -1; c = getchar();} while(isdigit(c)) t = t * 10 + c - '0' , c = getchar();t *= x;}template &lt; typename T , typename... Args &gt; void sc(T&amp; t , Args&amp;... args) {sc(t); sc(args...);}const int N = 1000000 + 10;int next[N] , n;char c[N];int main() { sc(n);scanf(\"%s\" , (c + 1)); next[1] = 0; Go(i , 2 , n) { int j = next[i-1]; while(j &amp;&amp; c[i] != c[j + 1]) j = next[j]; if(c[i] == c[j+1]) next[i] = j+1; else next[i] = 0; } LL ans = 0; Go(i , 2 , n) { int j = i; while(next[j]) j = next[j]; if(next[i]) next[i] = j; ans += 1ll * (i - j); } std::cout &lt;&lt; ans &lt;&lt; \"\\n\"; return 0;}","link":"/2019/03/17/POI2006-OKR-Periods-of-Words-题解/"},{"title":"[POI2009]Radio Transmission 题解","text":"虽然是个hash裸题但是KMP的做法也很妙~ 答案就是$n-next[n]$.为啥？考虑画图。 考虑根据$n-next[n]$的长度分段。 不难通过一一对应以及$border$的定义证明。 然后就完事了。12345678910111213141516171819202122232425262728293031323334/** * @Author: Mingyu Li * @Date: 2019-03-16T09:53:21+08:00 * @Email: class11limingyu@126.com * @Filename: P4391.cpp * @Last modified by: Mingyu Li * @Last modified time: 2019-03-16T09:55:56+08:00 */#include &lt;bits/stdc++.h&gt;#define Go(i , x , y) for(register int i = x; i &lt;= y; i++)#define God(i , y , x) for(register int i = y; i &gt;= x; i--)typedef long long LL;template &lt; typename T &gt; void sc(T&amp; t) { char c = getchar(); T x = 1; t = 0; while(!isdigit(c)) {if(c == '-') x = -1; c = getchar();} while(isdigit(c)) t = t * 10 + c - '0' , c = getchar();t *= x;}template &lt; typename T , typename... Args &gt; void sc(T&amp; t , Args&amp;... args) {sc(t); sc(args...);}const int N = 1000000 + 5;char a[N];int n , Next[N];int main() { sc(n); scanf(\"%s\" , (a+1)); Next[1] = 0; Go(i,2,n) { int j = Next[i-1]; while(j &amp;&amp; a[j+1] != a[i]) j = Next[j]; if(a[j+1] == a[i]) Next[i] = j+1; else Next[i] = 0; } std::cout &lt;&lt; n - Next[n] &lt;&lt; \"\\n\"; return 0;}","link":"/2019/03/16/POI2009-Radio-Transmission-题解/"},{"title":"[SCOI2009]windy数 题解","text":"数位dp模板题。 $dp[t][p]$表示还剩$t$位，上一位填的是$p$的方案数。那么转移就是$dp[t][p] = \\sum dp[t-1][q], abs(p-q) \\geq 2$.这里采用dls的可读性极高的写法。举个例子，如果我们要计算$[1,3323]$的答案，那么先把$[1,999]$的答案整段算完。然后剩下的一位一位卡着算就行了。具体见代码，如果实在不懂可以画图理解。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869/** * @Author: Mingyu Li * @Date: 2019-03-10T09:32:31+08:00 * @Email: class11limingyu@126.com * @Filename: [SCOI2009]windy数.cpp * @Last modified by: Mingyu Li * @Last modified time: 2019-03-10T10:19:58+08:00 */#include &lt;bits/stdc++.h&gt;#define tpname typename#define Go(i , x , y) for(register int i = x; i &lt;= y; i++)#define God(i , y , x) for(register int i = y; i &gt;= x; i--)typedef long long LL;typedef long double ld;typedef unsigned long long ULL;template &lt; tpname T &gt; void sc(T&amp; t) { char c = getchar(); T x = 1; t = 0; while(!isdigit(c)) {if(c == '-') x = -1; c = getchar();} while(isdigit(c)) t = t * 10 + c - '0' , c = getchar();t *= x;}template &lt; tpname T , tpname... Args &gt; void sc(T&amp; t , Args&amp;... args) {sc(t); sc(args...);}template &lt; tpname T &gt; T mul(T x , T y , T _) { x %= _,y %= _; return ((x * y - (T)(((ld)x * y + 0.5) / _) * _) % _ + _) % _;}int d[20] , l , r;int dp[20][20];int F(int k , int p) { if(dp[k][p] != -1) return dp[k][p]; if(k == 0) return dp[k][p] = 1; int ans = 0; Go(q , 0 , 9) { if(abs(p - q) &gt;= 2) ans += F(k-1 , q); } return dp[k][p] = ans;}int cal(int x) { int m = 0; while(x) { d[m] = x%10; x /= 10; m++; } int ans = 0; God(i , m-1 , 1) { Go(j , 1 , 9) ans += F(i-1 , j); // 整段 } int pre = -100; God(i , m-1 , 0) { Go(j , (i == m-1) ? 1 : 0 , d[i] - 1) { // 卡着边界 if(abs(pre - j) &gt;= 2) ans += F(i , j); } if(abs(pre - d[i]) &lt; 2) break; pre = d[i]; // 钦定一位之后继续 } return ans;}int main() { memset(dp , -1 , sizeof(dp)); std::cin &gt;&gt; l &gt;&gt; r; // cal 计算的是开区间 std::cout &lt;&lt; cal(r+1) - cal(l) &lt;&lt; std::endl; return 0;}","link":"/2019/03/10/SCOI2009-windy数-题解/"},{"title":"[USACO10HOL]DOtP 题解","text":"第一道应用高斯消元来解$dp$数组的题，感觉很妙。这玩意没法$dp$…考虑套路的转化$dp$类型。也就是$dp$出每个点期望经过次数，然后$\\times (p/q)$就是概率。咋$dp$？设$dp[u]$为$u$点的期望经过次数。有： dp[u]=[\\sum_{(v,u) \\in E}(1-p/q)\\times(1/deg[v])\\times dp[v]] + [u == 1]含义是，从$v$转移到$u$.由于$dp[v]$为$v$的期望经过次数，那么每次经过它都有$(1-p/q)\\times(1/deg[v])$的概率成功到达$u$，那么单方面$v$对$dp[u]$的贡献就如上面公式所示了。 由于期望的线性性，可以直接加起来。 由于无向图上的$dp$顺序十分混乱，可以把$dp[1…n]$当作$n$个未知数，把转移方程当作方程，$gauss$消元$solve$一下即可。 （特别注意：由于$1$点一开始就经过了一次，真正$dp$出来之后$dp[1]$要比原始数值多$1$，需要在高斯消元方程组中体现一下） 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465/** * @Author: Mingyu Li * @Date: 2019-03-18T21:37:38+08:00 * @Last modified by: Mingyu Li * @Last modified time: 2019-03-18T21:40:36+08:00 */#include &lt;bits/stdc++.h&gt;#define Go(i , x , y) for(register int i = x; i &lt;= y; i++)#define God(i , y , x) for(register int i = y; i &gt;= x; i--)// 设f[u] : 访问节点u的期望次数// f[u] = \\sum(1 - p / q) * f[v]// 则显然有ans[u] = f[u] * (p/q)// 特判1位置// 列出来n个方程 高斯消元求f// 最后乘个(p/q)const int N = 300 + 10;int n , m , p , q , u , v , deg[N];double g[N][N];bool w[N][N];void Gauss() { Go(i , 1 , n) { int now = i; Go(j , i+1 , n) if(fabs(g[now][i]) &lt; fabs(g[j][i])) now = j; Go(j , 1 , n+1) std::swap(g[i][j] , g[now][j]); Go(j , i+1 , n+1) g[i][j] /= g[i][i]; g[i][i] = 1; Go(j , i+1 , n) { Go(k , i+1 , n+1) { g[j][k] -= g[j][i] * g[i][k]; } g[j][i] = 0; } }// 构建上三角矩阵 God(i , n , 1) { Go(j , i+1 , n) g[i][n+1] -= g[i][j] * g[j][n+1]; g[i][n+1] /= g[i][i]; g[i][i] = 1; }}int main() { scanf(\"%d%d%d%d\", &amp;n, &amp;m, &amp;p, &amp;q); double weight = (1.0 * p) / (1.0 * q); Go(i, 1, m) { scanf(\"%d%d\", &amp;u, &amp;v); w[u][v] = 1; w[v][u] = 1; ++deg[u]; ++deg[v]; } // 构建高斯消元方程组 Go(i, 1, n) { g[i][i] = -1; // ..... - f[u] + ...... = 0 Go(j, 1, n) if(w[i][j] == 1) g[i][j] += (1.0 - weight) * (1.0 / (double)(deg[j])); } g[1][n + 1] = -1; Gauss(); Go(i , 1 , n) std::cout &lt;&lt; std::fixed &lt;&lt; std::setprecision(9) &lt;&lt; g[i][n+1] * weight &lt;&lt; \"\\n\"; return 0;}","link":"/2019/03/18/USACO10HOL-DOtP-题解/"},{"title":"[ZJOI2010]数字计数 题解","text":"wr硬着头皮写了一发竟然过了？ 谈一谈我的做法。 思路：数位dp+分类讨论。 考虑分成一个一个位考虑。加上前缀和思想，本题就转化成了“$1-x$中$y$出现的个数”。 再分个类，考虑限定数位在每一个数中必须出现的个数，那么本题就又转化成了“$1-x$中$y$出现$z$次的数的个数”。 这玩意是个简单到不能再简单的数位dp模型了。可以直接套模型求解。 那么本题就完美解决了。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172/** * @Author: Mingyu Li * @Date: 2019-03-11T12:13:29+08:00 * @Email: class11limingyu@126.com * @Filename: [ZJOI2010]数字计数.cpp * @Last modified by: Mingyu Li * @Last modified time: 2019-03-13T19:36:56+08:00 */#include &lt;bits/stdc++.h&gt;#define tpname typename#define int long long#define Go(i , x , y) for(register int i = x; i &lt;= y; i++)#define God(i , y , x) for(register int i = y; i &gt;= x; i--)typedef long long LL;typedef long double ld;typedef unsigned long long ULL;template &lt; tpname T &gt; void sc(T&amp; t) { char c = getchar(); T x = 1; t = 0; while(!isdigit(c)) {if(c == '-') x = -1; c = getchar();} while(isdigit(c)) t = t * 10 + c - '0' , c = getchar();t *= x;}template &lt; tpname T , tpname... Args &gt; void sc(T&amp; t , Args&amp;... args) {sc(t); sc(args...);}template &lt; tpname T &gt; T mul(T x , T y , T _) { x %= _,y %= _; return ((x * y - (T)(((ld)x * y + 0.5) / _) * _) % _ + _) % _;}const int N = 20;LL dp[N][N] , d[N];// 啥意思?// dp[i][j] : 填了i位 共填了j个有效数字 接下来\"能动\"的数个数int l , r , sup;LL f(LL x, LL y) { if(dp[x][y] != -1) return dp[x][y]; if(x == 0) return dp[x][y] = y == sup ? 1 : 0; else return dp[x][y] = 9 * f(x-1 , y) + f(x-1 , y+1);}LL cal(LL D , LL digit) { memset(dp , -1 , sizeof(dp)); int m=0; while(D) { d[m++] = D%10; D /= 10; } int ans = 0; Go(occur , 0 , 13) { sup = occur; memset(dp , -1 , sizeof(dp)); Go(i , 1 , m-1) { Go(j , 1 , 9) { ans += occur * f(i-1 , (j == digit)); } } } Go(occur , 0 , 13) { sup = occur; memset(dp , -1 , sizeof(dp)); int pref = 0; God(i , m-1 , 0) { Go(j , (i == m-1) ? 1 : 0 , d[i] - 1) { ans += occur * f(i , pref + (j == digit)); } pref += (d[i] == digit); if(pref &gt; occur) break; } } return ans;}signed main() { std::cin &gt;&gt; l &gt;&gt; r; for(int i = 0; i &lt;= 9; i++) std::cout &lt;&lt; cal(r+1 , i) - cal(l , i) &lt;&lt; \" \"; return 0;}","link":"/2019/03/13/ZJOI2010-数字计数-题解/"},{"title":"[SCOI2010]传送带 题解","text":"比较神的一道题，以前没有接触过三分套三分… 介绍一下我的做法。 首先，碰见这种题，第一眼一般都不知道从何下手。这时候观察题目的性质，发现所走的路径一定是$A\\Rightarrow X\\Rightarrow Y\\Rightarrow D$，其中$X\\in [A,B],Y\\in[C,D].$所以很容易想到一个暴力算法：把每一对$[x,y]$都枚举一遍即可。但是这样的时间复杂度太高了，所以需要考虑别的办法。 在手算模拟之后，可以发现$[x,y]$的枚举都是有规律性的，是一个类似函数的变化。所以考虑三分。 那么怎么三分呢？ 考虑问题的简化版。给你一个点，一条线段，求到哪个点最快，各种定义依据原问题的定义。 这时候很简单，很明显就是一个函数，可以三分。 那么会发现，如果这个函数有单调性，那么问题的简化版也一定具有单调性。也就是说解也是有单调性的。 所以我们可以先三分$X$,再三分$Y$，最后选择一个最优解即可。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788#pragma GCC optimize(\"O2\")#include &lt;bits/stdc++.h&gt;#define PI 3.14159265#define DO_NOT_USE_SCANF ios::sync_with_stdio(0)#define PQ priority_queue#define lowbit(x) ((x) &amp; (-x))#define lmy#ifdef lmy #define DEBUG printf(\"Passing [%s] in LINE %d...\\n\" , __FUNCTION__ , __LINE__)#endiftypedef long long ll;typedef unsigned long long ull;using namespace std;inline void read(int &amp;x) { int f = 1;x = 0;char ch = getchar(); while(ch &lt; '0' || ch &gt; '9') {if(ch == '-') f = -1; ch = getchar();} while(ch &gt;= '0' &amp;&amp; ch &lt;= '9') {x = x * 10 + ch - '0'; ch = getchar();} x *= f;}inline void readll(ll &amp;x) { ll f = 1;x = 0;char ch = getchar(); while(ch &lt; '0' || ch &gt; '9') {if(ch == '-') f = -1; ch = getchar();} while(ch &gt;= '0' &amp;&amp; ch &lt;= '9') {x = x * 10 + ch - '0'; ch = getchar();} x *= f;}struct Point { double x , y;};Point a , b , c , d;double p , q , r;const double eps = 1e-6;double dist(Point a , Point b) { return sqrt((a . x - b . x) * (a . x - b . x) + (a . y - b . y) * (a . y - b . y));}double f(Point x , Point y) { return dist(a , x) / p + dist(x , y) / r + dist(y , d) / q;}double task(Point x) { Point l = c , r = d; while(dist(l , r) &gt; eps) { Point delta = (Point){(r . x - l . x) / 3 , (r . y - l . y) / 3}; Point lmid = (Point){l . x + delta . x , l . y + delta . y}; Point rmid = (Point){r . x - delta . x , r . y - delta . y}; if(f(x , rmid) - f(x , lmid) &gt; eps) r = rmid; else l = lmid; } return f(x , l);}void solve() { scanf(\"%lf%lf%lf%lf\" , &amp;a . x , &amp;a . y , &amp;b . x , &amp;b . y); scanf(\"%lf%lf%lf%lf\" , &amp;c . x , &amp;c . y , &amp;d . x , &amp;d . y); scanf(\"%lf%lf%lf\" , &amp;p , &amp;q , &amp;r); Point l = a , r = b; while(dist(l , r) &gt; eps) { Point delta = (Point){(r . x - l . x) / 3 , (r . y - l . y) / 3}; Point lmid = (Point){l . x + delta . x , l . y + delta . y}; Point rmid = (Point){r . x - delta . x , r . y - delta . y}; if(task(rmid) - task(lmid) &gt; eps) r = rmid; else l = lmid; } cout &lt;&lt; fixed &lt;&lt; setprecision(2) &lt;&lt; task(l) &lt;&lt; endl; return;}int main(){ #ifdef lmy int nol_cl = clock(); #endif solve(); // did you forget to undefine Lmy ? #ifdef lmy printf(\"\\nTime: %dms\\n\", int((clock() - nol_cl) / (double)CLOCKS_PER_SEC * 1000)); #endif return 0;}","link":"/2019/03/10/SCOI2010-传送带-题解/"},{"title":"[nowcoder14113]Squared Permutation 题解","text":"智商持续掉线。 考虑题目其实是让维护$a[a[i]]$的和，那就直接用BIT维护。发现当我们swap的时候（以$a[l]$）为例：只有两种情况的点权值（设点编号为$x$）会发生改变：$1. a[x] = a[l], 即x = l$$2. a[x] = l, 即a[a[x]] = a[l]$维护一个pos即可。1234567891011121314151617181920212223242526272829303132333435363738394041424344#include &lt;bits/stdc++.h&gt;using namespace std;const int N = 100000 + 10;typedef long long Int;int n, m;int a[N] , pool[N];Int pre[N], c[N];void pu(int u, Int w) {for(; u &lt;= n; u += (u &amp; -u)) c[u] += w;}Int query(int u) {Int ans = 0;for(; u; u -= (u &amp; -u)) ans += c[u]; return ans;}void solve() { memset(c, 0, sizeof(c)); scanf(\"%d\", &amp;n); for(int i = 1; i &lt;= n; i++) scanf(\"%d\", &amp;a[i]); for(int i = 1; i &lt;= n; i++) pu(i, a[a[i]]), pool[a[i]] = i; scanf(\"%d\", &amp;m); while(m--) { int op, l, r; scanf(\"%d%d%d\", &amp;op, &amp;l, &amp;r); if(l &gt; r) swap(l, r); if(op == 1) { // #1 : 修改l,r // l -&gt; a[a[l]] a[l] -&gt; a[r] if(pool[l] != l &amp;&amp; pool[l] != r) pu(pool[l], -a[l]),pu(pool[l], a[r]); if(pool[r] != l &amp;&amp; pool[r] != r)pu(pool[r], -a[r]), pu(pool[r], a[l]); pu(l, -a[a[l]]); pu(r, -a[a[r]]); swap(a[l], a[r]); pu(l, a[a[l]]); pu(r, a[a[r]]); pool[a[l]] = l; pool[a[r]] = r; } else if(op == 2) { printf(\"%lld\\n\", query(r) - query(l - 1)); } }}int main(){ int t; scanf(\"%d\", &amp;t); while(t--) solve(); return 0;}","link":"/2019/05/01/nowcoder14113-Squared-Permutation-题解/"},{"title":"[ZJOI2014]力 题解","text":"题意： 发现Ei如果给出了Fi就很好算，所以目标其实是算Fi.首先我们令$F_j=A_j-B_j$.其中A_j=\\sum_{ij}\\frac{q_iq_j}{(i-j)^2}.考虑将第一个式子变形为 A_j=\\sum_{i=0}^{j-1}\\frac{q_iq_j}{(i-j)^2}.由乘法分配律，可以将$q_j$单拎出来，得： A_j=q_j\\times \\sum_{i=0}^{j-1}\\frac{q_i}{(i-j)^2}.由于$(i-j)^2=(j-i)^2$，所以考虑这样一个函数： g(x)=\\frac{1}{x^2}.然后就会发现可以把 \\frac{q_i}{(i-j)^2}变形为 q_ig(j-i).带回原式，得到：A_j=q_j\\times \\sum_{i=0}^{j-1}q_ig(j-i).不难发现后面的那坨东西类似于多项式乘法，但是少了一项，可以手动将$g(0)=0$.然后…这就是个多项式乘法的典型形式！可以用$\\text{FFT}$解决！同理也可以化简$B_j$. B_j=\\sum_{i=j+1}^{n-1} \\frac{q_iq_j}{(i-j)^2}B_j=q_j\\sum_{i=j+1}^{n} \\frac{q_i}{(i-j)^2}然后突然发现…这东西和$A_j$的计算方法不大一样!咋整？瞬间考虑-&gt;反转q序列！变成 \\sum_{i=0}^{j-1}\\frac{q'_i}{(i-j)^2}.然后把这个式子搞一下，变成 \\sum_{i=0}^{j-1}q'_ig(j-i)发现这个式子本质上就是$A_j$，就能做了。","link":"/2019/03/09/ZJOI2014-力-题解/"},{"title":"[nowcoder 17385]Beautiful Number 题解","text":"一句话：卡常无所不能。 套路比较sb…强制总和是多少，于是就转化成了总和为此数且这个数能被总和整除的数的个数。搞个三维dp爆算了一波，答案是对的，但是一组数据跑了0.4s. 看了一眼——100组数据，岂不是凉凉？开始卡常数。先把不用开long long的都换掉，再改register int，再改取模运算，然而这些都没有特别明显的效果。 灵机一动了一下：可以在记忆化搜索里面剪枝！大概就是总和不可能等于假定值的要被剪掉。然后速度飞快，快到了0.11s左右。估算了一波，跑完100组需要11s.于是又加了一个当前dp数组的memset优化，快到了0.083s左右。换成scanf, printf, 卡了一下就过了。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;int d[20], m = 0;ll ans, l, r;int now;ll dp[14][109][109];int xxx[169400], yyy[169400], zzz[169400], cnt;ll DP(int i, int mod, int sum) { if(dp[i][mod][sum] != -1) return dp[i][mod][sum]; if(sum&gt;now) return xxx[++cnt] = i, yyy[cnt] = mod, zzz[cnt] = sum, dp[i][mod][sum]=0; if(sum+(9*i)&lt;now) return xxx[++cnt] = i, yyy[cnt] = mod, zzz[cnt] = sum, dp[i][mod][sum]=0; if(!i) { xxx[++cnt] = i, yyy[cnt] = mod, zzz[cnt] = sum; if(sum == now &amp;&amp; mod == 0) return dp[i][mod][sum] = 1; else return dp[i][mod][sum] = 0; } dp[i][mod][sum] = 0; for(register int dg = 0; dg &lt;= 9; dg++) dp[i][mod][sum] += DP(i-1,(mod * 10 + dg) % now, sum + dg); xxx[++cnt] = i, yyy[cnt] = mod, zzz[cnt] = sum; return dp[i][mod][sum];}ll calc(ll x) { m = 0; while(x) { d[m++] = x%10; x /= 10; } memset(dp, -1, sizeof(dp)); // m - 1 : ll ret = 0; for(register int xx = 1; xx &lt;= 9*m; xx++) { now = xx; cnt = 0; ll ans = 0; for(register int i = m-1; i &gt;= 1; i--) for(register int j = 1; j &lt;= 9; j++) ans += DP(i-1, j-j/now*now, j); int pre1 = 0, pre2 = 0; for(register int i = m-1; i &gt;= 0; i--) { for(register int j = (i == m - 1) ? 1 : 0; j &lt;= d[i] - 1; j++) ans += DP(i, (pre1 * 10 + j) - (pre1 * 10 + j)/now*now, (pre2 + j)); pre1 = (pre1 * 10 + d[i]); pre1 -= pre1 / now * now; pre2 += d[i]; } for(int i = 1; i &lt;= cnt; i++) dp[xxx[i]][yyy[i]][zzz[i]] = -1; ret += ans; } return ret;}int main() { int t; scanf(\"%d\", &amp;t); int cas = 0; while(t--) { scanf(\"%lld\", &amp;r); printf(\"Case %d: %lld\\n\", ++cas, calc(r+1)); } return 0;}","link":"/2019/04/28/nowcoder-17385-Beautiful-Number-题解/"},{"title":"Hello World","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","link":"/2019/03/07/hello-world/"},{"title":"你好.","text":"Hello.Hello.markdon$a+b=c$ $c_k=\\sum _{i=0}^{n-1}(\\omega_{n}^{-k})^i\\times y_i.$ lim_{1\\to+\\infty}P(|\\frac{1}{n}\\sum_i^nX_i-\\mu|","link":"/2019/03/07/你好/"},{"title":"[十二省联考2019]异或粽子 题解","text":"貌似是个签到题？ 白送的60分就不讲了，就是前缀和一下。加上的40分可以用“序列合并”一题的套路，搞一个可持久化01trie维护xor第k大即可。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586#include &lt;bits/stdc++.h&gt;#define int long longusing namespace std;const int N = 500000 + 5;int n, k, pre[N], a[N], root[N];struct Node { int r, xorans, nownum; bool operator &lt; (const Node &amp;rhs) const { return xorans &lt; rhs.xorans; }};struct Trie { int trie[N*35][2], sz[N*35], pos = 0; void pushup(int now) { sz[now] = sz[trie[now][0]] + sz[trie[now][1]]; } void Build(int&amp; now, int x, int k) { now = ++pos; if(k == -1) { sz[now]++; return ; } if(!(x &amp; (1ll &lt;&lt; k))) Build(trie[now][0], x, k-1); else Build(trie[now][1], x, k-1); pushup(now); } void Update(int&amp; now, int old, int x, int k) { now = ++pos; trie[now][0] = trie[old][0], trie[now][1] = trie[old][1], sz[now] = sz[old]; if(k == -1) { sz[now]++; return ; } if(!(x &amp; (1ll &lt;&lt; k))) Update(trie[now][0], trie[old][0], x, k-1); else Update(trie[now][1], trie[old][1], x, k-1); pushup(now); } int XorKth(int now, int ans, int x, int k, int kth) { if(k == -1) return ans; if(!(x &amp; (1ll &lt;&lt; k))) { int ls = sz[trie[now][0]], rs = sz[trie[now][1]]; if(kth &lt;= ls) return XorKth(trie[now][0], ans * 2, x, k-1, kth); else return XorKth(trie[now][1], ans * 2 + 1, x, k-1, kth - ls); } else { int ls = sz[trie[now][1]], rs = sz[trie[now][0]]; if(kth &lt;= ls) return XorKth(trie[now][1], ans * 2 + 1, x, k-1, kth); else return XorKth(trie[now][0], ans * 2, x, k-1, kth - ls); } }}t;signed main() { scanf(\"%lld%lld\", &amp;n, &amp;k); for(int i = 1; i &lt;= n; i++) scanf(\"%lld\", &amp;a[i]), pre[i] = (pre[i-1] ^ a[i]); t.Build(root[1], pre[0], 32); for(int i = 2; i &lt;= n; i++) t.Update(root[i], root[i-1], pre[i-1], 32); priority_queue &lt;Node&gt; q; for(int i = 1; i &lt;= n; i++) { int xo = t.XorKth(root[i], 0, pre[i], 32, i); q.push((Node){i, (xo ^ pre[i]), i}); } int ans= 0; for(int i = 1; i &lt;= k; i++) { Node x = q.top(); q.pop(); //cout &lt;&lt; x.xorans &lt;&lt; endl; ans += x.xorans; if(i == k) { cout&lt;&lt;ans &lt;&lt; endl; return 0; } else { int id = x.nownum; --id; if(id &lt;= 0) continue; int xo = t.XorKth(root[x.r], 0, pre[x.r], 32, id); q.push((Node){x.r, (xo ^ pre[x.r]), id}); } } cout &lt;&lt;ans &lt;&lt; endl; return 0;}","link":"/2019/04/12/十二省联考2019-异或粽子-题解/"},{"title":"后缀数组(SA) 详解","text":"一类解决字符串问题的有力工具。首先是搞出一个sa数组。其中$sa[i]$表示所有非空后缀中，字典序第$i$大的后缀从哪里开始。同时也可以处理出来一个rk数组，其中$rk[i]$表示这个后缀排第几。显然最后有$rk[sa[i]] = sa[rk[i]] = i$. $\\mathcal{O(n^2 log n)}$直接string + sort. $\\mathcal{O(n log^2 n)}$考虑倍增维护。对于每个位置$i$，如果我们知道了$s[i…i+w-1]$的排名，那就可以倍增一下，搞个二元组排序即可。倍增是log的，排序nlogn，共$\\mathcal{O(n log^2 n)}$. $\\mathcal{O(n log n)}$优化排序，用基数排序即可。注意细节的优化，不然会挂。 123456789101112131415161718192021222324252627282930313233#include &lt;bits/stdc++.h&gt;#define dbg(x) std::cerr &lt;&lt; #x &lt;&lt; \" = \" &lt;&lt; x &lt;&lt; \"\\n\"using namespace std;typedef long long ll;const int N = 1000000 + 5;int n, w, m;int rk[N&lt;&lt;1], num[N], cnt[N], id[N&lt;&lt;1];char s[N];bool cmp(int x, int y, int w) { return id[x] == id[y] &amp;&amp; id[x + w] == id[y + w];}int main() { scanf(\"%s\", (s + 1)); n = strlen(s + 1); m = max(n, 300); for(int i = 1; i &lt;= n; i++) rk[i] = s[i], ++cnt[rk[i]]; for(int i = 1; i &lt;= m; i++) cnt[i] += cnt[i - 1]; for(int i = n; i &gt;= 1; i--) num[cnt[rk[i]]--] = i; for(w = 1; w &lt; n; w &lt;&lt;= 1) { memset(cnt, 0, sizeof(cnt)); int p = 0; for(int i = n; i &gt;= n - w + 1; i--) id[++p] = i; for(int i = 1; i &lt;= n; i++) if(num[i] &gt; w) id[++p] = num[i] - w; for(int i = 1; i &lt;= n; i++) ++cnt[rk[id[i]]]; for(int i = 1; i &lt;= m; i++) cnt[i] += cnt[i - 1]; for(int i = n; i &gt;= 1; i--) num[cnt[rk[id[i]]]--] = id[i], id[i] = rk[i]; m = 0; for(int i = 1; i &lt;= n; i++) rk[num[i]] = cmp(num[i], num[i - 1], w) ? m : ++m; } for(w = 1; w &lt;= n; w++) printf(\"%d \", num[w]); return 0;}","link":"/2019/05/11/后缀数组-SA-详解/"},{"title":"[清华集训2015]Light Bulb 题解","text":"可以观察题目中隐含的单调性来解决本题。 观察到可以把图中的$L$分成两部分：一部分是投影到地上的，而另一部分是投影到墙上的。 位置离墙越近，地上的投影就会变短，同时墙上的投影也会变长。 但是本题的答案并不是一个一次函数，因为一开始墙上的投影一段时间内都为$0$（影子太短），所以并不能直接一次函数求解。 所以可以直接正常三分，函数直接快速维护一下即可。 复杂度约等于$\\Theta(Tlogd)$ ? （不会证，算了…） 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172#pragma GCC optimize(\"O2\")#include &lt;bits/stdc++.h&gt;#define PI 3.14159265#define DO_NOT_USE_SCANF ios::sync_with_stdio(0)#define PQ priority_queue#define lowbit(x) ((x) &amp; (-x))//#define lmy#ifdef lmy #define DEBUG printf(\"Passing [%s] in LINE %d...\\n\" , __FUNCTION__ , __LINE__)#endiftypedef long long ll;typedef unsigned long long ull;using namespace std;inline void read(int &amp;x) { int f = 1;x = 0;char ch = getchar(); while(ch &lt; '0' || ch &gt; '9') {if(ch == '-') f = -1; ch = getchar();} while(ch &gt;= '0' &amp;&amp; ch &lt;= '9') {x = x * 10 + ch - '0'; ch = getchar();} x *= f;}inline void readll(ll &amp;x) { ll f = 1;x = 0;char ch = getchar(); while(ch &lt; '0' || ch &gt; '9') {if(ch == '-') f = -1; ch = getchar();} while(ch &gt;= '0' &amp;&amp; ch &lt;= '9') {x = x * 10 + ch - '0'; ch = getchar();} x *= f;}double H , h , D;const double eps = 1e-7;double f(double mid) { double straight = mid / (H - h) * h; if(straight + mid - D &gt; eps) { straight = D - mid; } // h - delta * (straight / mid) // delta : H - h double delta = H - h; double up = h - delta * (straight / mid); if(0 - up &gt; eps) up = 0; return straight + up;}void solve() { scanf(\"%lf%lf%lf\" , &amp;H , &amp;h , &amp;D); double l = 0 , r = D; while(r - l &gt; eps) { double lmid = l + (r - l) / 3 , rmid = r - (r - l) / 3; if(f(rmid) - f(lmid) &gt; eps) l = lmid; else r = rmid; } cout &lt;&lt; fixed &lt;&lt; setprecision(3) &lt;&lt; f(l) &lt;&lt; endl; return;}int main(){ #ifdef lmy int nol_cl = clock(); #endif int T; read(T); while(T--) { solve(); } // did you forget to undefine Lmy ? #ifdef lmy printf(\"\\nTime: %dms\\n\", int((clock() - nol_cl) / (double)CLOCKS_PER_SEC * 1000)); #endif return 0;}","link":"/2019/03/10/清华集训2015-Light-Bulb-题解/"},{"title":"高斯消元 详解","text":"高斯消元是解决一类线性多元方程组的利器。 举个例子，如果让你求解如下的方程，你该怎么办？ \\begin{cases} 2x+y+z=1&①\\\\ 6x+2y+z=-1&②\\\\ -2x+2y+z=7&③\\\\ \\end{cases}正常人的思路差不多就是加减消元/代入消元，最后解出来所有答案。下面我们来模拟一下正常人的解题过程： $(-3)\\times①+②:0x - y - 2z = -4$$①+③:0x + 3y + 2z = 8$ 所以有 \\begin{cases} 2x + y + z=1&①\\\\ 0x - y - 2z=-4&②\\\\ 0x + 3y + 2z = 8&③\\\\ \\end{cases}发现$x$消不了了，开始消$y$. $②\\times3+③:-4z = -4.$ 于是解得： z = 1.这时候就可以把$z$带回去解别的。 代入$②:0x-y-2=-4$解得y = 2. 然后带回$①:x=-1.$然后就解完了。 考虑把解题过程中的$x,y,z$项写成矩阵。所以一开始的矩阵就是$\\begin{bmatrix}x &amp; y &amp; z &amp; val\\\\ 2 &amp; 1 &amp; 1 &amp; 1\\\\ 6 &amp; 2 &amp; 1 &amp; -1\\\\ -2 &amp; 2 &amp; 1 &amp; 7\\end{bmatrix}$消完$x$之后： $\\begin{bmatrix}x &amp; y &amp; z &amp; val\\\\ 2 &amp; 1 &amp; 1 &amp; 1\\\\ 0 &amp; -1 &amp; -2 &amp; -4\\\\ 0 &amp; 3 &amp; 2 &amp; 8\\end{bmatrix}$消完$y$之后：$\\begin{bmatrix}x &amp; y &amp; z &amp; val\\\\ 2 &amp; 1 &amp; 1 &amp; 1\\\\ 0 &amp; -1 &amp; -2 &amp; -4\\\\ 0 &amp; 0 &amp; -4 &amp; -4\\end{bmatrix}$ 发现矩阵中的0元素构成了一个上三角，我们称这玩意为”上三角矩阵”。 显然，最理想情况一定是构成这玩意，直接一直回代就可以了。那么我们来分析一下多个解或无解的情况：无解：一行系数全0，但$val ≠ 0$.多个解：好几行系数和$val$全是0. 分析完了。如何实现？ 算法流程：一项一项消。消到第i项的时候，找系数绝对值最大的（好判断无解）来作为主式子。然后硬消就行了。 附$Luogu$模板题代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657/** * @Author: Mingyu Li * @Date: 2019-03-17T11:01:04+08:00 * @Email: class11limingyu@126.com * @Filename: Gauss消元.cpp * @Last modified by: Mingyu Li * @Last modified time: 2019-03-17T11:26:00+08:00 */#include &lt;bits/stdc++.h&gt;#define Go(i , x , y) for(register int i = x; i &lt;= y; i++)#define God(i , y , x) for(register int i = y; i &gt;= x; i--)typedef long long LL;template &lt; typename T &gt; void sc(T&amp; t) { char c = getchar(); T x = 1; t = 0; while(!isdigit(c)) {if(c == '-') x = -1; c = getchar();} while(isdigit(c)) t = t * 10 + c - '0' , c = getchar();t *= x;}template &lt; typename T , typename... Args &gt; void sc(T&amp; t , Args&amp;... args) {sc(t); sc(args...);}const int N = 100 + 5;int n;double g[N][N];int main() { sc(n); Go(i, 1, n) Go(j, 1, n+1) scanf(\"%lf\" , &amp;g[i][j]); Go(i, 1, n) { int now = i; Go(j , i+1, n) if(fabs(g[now][i]) &lt; fabs(g[j][i])) now = i; if(fabs(g[now][i]) &lt; 1e-9) { puts(\"No Solution\"); return 0; } Go(j , i, n+1) std::swap(g[now][j] , g[i][j]); Go(j , i+1 , n+1) g[i][j] /= g[i][i]; g[i][i] = 1; Go(j , i+1 , n) { Go(k , i+1 , n+1) { g[j][k] -= g[j][i] * g[i][k]; } g[j][i] = 0; } } God(i, n, 1) { Go(j , i+1 , n) g[i][n+1] -= g[i][j] * g[j][n+1]; g[i][n+1] /= g[i][i]; g[i][i] = 1; } Go(i , 1 , n) std::cout &lt;&lt; std::fixed &lt;&lt; std::setprecision(2) &lt;&lt; g[i][n+1] &lt;&lt; std::endl; return 0;}","link":"/2019/03/17/高斯消元-详解/"},{"title":"常见积性函数线性筛","text":"$\\mu$函数貌似根据定义做就可以。12345678910111213141516void calmu(int n) { np[1] = true; mu[1] = 1; for(int i = 2; i &lt;= n; i++) { if(!np[i]) prime[++pos] = i , mu[i] = -1; for(int j = 1; j &lt;= pos &amp;&amp; i * prime[j] &lt;= n; j++) { np[i * prime[j]] = 1; if(i % prime[j]) { mu[i * prime[j]] = -mu[i]; } else { mu[i * prime[j]] = 0; break; } } }} $\\varphi$函数考虑硬拆式子。重温$\\text{Euler Sieve}$的过程，就是找$n$的最小质因子$p_1$将其用$p_1 \\times (n / p_1)$筛掉。先设$n’ = n / p_1$，再分两种情况讨论：$①:n’$有$p_1$这一因子。意味着唯一分解中$k_1 &gt; 1$那么显然，$n’$有着$n$的所有质因子。所以 \\begin{aligned} \\varphi(n)&= n \\prod\\limits_{i = 1} ^ {k} \\frac{p_i - 1}{p_i} \\\\ &= p_1 \\times n' \\prod\\limits_{i = 1} ^ {k} \\frac{p_i - 1}{p_i} \\\\ &= p_1 \\times \\varphi(n') \\\\ \\end{aligned}$②:n’$没有$p_1$这一因子。意味着唯一分解中$k_1 = 1$ \\begin{aligned} \\varphi(n)&= n \\prod_{i = 1} ^ {k} \\frac{p_i - 1}{p_i} \\\\ &= p_1 \\times n' \\times \\frac{p_1-1}{p_1} \\prod\\limits_{i = 2} ^ {k} \\frac{p_i - 1}{p_i} \\\\ &= (p_1-1) \\times \\varphi(n') \\\\ \\end{aligned}（其实也证明了欧拉函数是积性函数）愉快的筛就好了。注意任何积性函数都有$f(1) = 1$.123456789101112131415void Euler_Sieve(int x) { np[1] = 1; phi[1] = 1; Go(i , 2 , x) { if(!np[i]) prime[++cnt] = i , phi[i] = i - 1; for(int j = 1; j &lt;= cnt &amp;&amp; i * prime[j] &lt;= x; j++) { np[i * prime[j]] = 1; if(i % prime[j]) phi[i * prime[j]] = phi[i] * (prime[j] - 1); else { phi[i * prime[j]] = prime[j] * phi[i]; break; } } }}","link":"/2019/04/14/常见积性函数线性筛/"},{"title":"省选字符串算法总结","text":"众做周知，$\\text{LiM}$字符串没学好。所以这里会用来整理一些知名字符串算法。 $\\mathcal{KMP}$$\\text{Old Link}$这里不写了…还有一堆$fail$数组的妙用。 $\\mathcal{AC自动机}$在$\\text{Trie}$上跑$\\text{KMP}$.建立$trie$图然后暴跳（123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263/** * @Author: Mingyu Li * @Date: 2019-03-31T13:59:13+08:00 * @Last modified by: Mingyu Li * @Last modified time: 2019-03-31T14:07:19+08:00 */#include &lt;bits/stdc++.h&gt;#define Go(i , x , y) for(register int i = x; i &lt;= y; i++)#define God(i , y , x) for(register int i = y; i &gt;= x; i--)using namespace std;const int N = 500000 + 5;struct AC_automaton { int trie[N][26] , val[N] , fail[N] , cnt; void insert(char *s) { int l = strlen(s); int now = 0; for(int i = 0; i &lt; l; i++) { if(trie[now][s[i] - 'a'] == 0) trie[now][s[i] - 'a'] = ++cnt; now = trie[now][s[i] - 'a']; } ++val[now]; } void Build() { queue&lt;int&gt; q; Go(i, 0, 25) if(trie[0][i]) q.push(trie[0][i]), fail[trie[0][i]] = 0; while(!q.empty()) { int u = q.front(); q.pop(); Go(i, 0, 25) { if(trie[u][i]) fail[trie[u][i]] = trie[fail[u]][i], q.push(trie[u][i]); else trie[u][i] = trie[fail[u]][i]; } } } int Query(char* t) { int ans = 0; int l = strlen(t); int now = 0; for(int i = 0; i &lt; l; i++) { now = trie[now][t[i] - 'a']; for(int t = now; t &amp;&amp; ~val[t]; t = fail[t]) ans += val[t] , val[t] = -1; } return ans; }}AC;int n;char s[N&lt;&lt;1];int main() { scanf(\"%d\" , &amp;n); Go(i, 1, n) { scanf(\"%s\" , s); AC.insert(s); } AC.Build(); scanf(\"%s\" , s); cout &lt;&lt; AC.Query(s) &lt;&lt; endl; return 0;}","link":"/2019/03/31/省选字符串算法总结/"},{"title":"省选基础数论整理","text":"众所周知，$\\text{LiM}$数学不好。这篇文章用于总结一堆数论算法。 $\\text{Primality Test}$单个$\\mathcal{O(\\sqrt{n}):}$由于因数成对出现，找有没有$\\leq \\sqrt{n}$的因子即可判断。 12345bool isprime(int n) { for(int i = 2; i * i &lt;= n; i++) if(n % i == 0) return 0; return 1;} $\\mathcal{O(nlogn):}\\text{Normal Sieve}$123456void sieve() { notprime[1] = 1; for(int i = 2; i &lt;= n; i++) { for(int j = i + i; j &lt;= n; j++) notprime[j] = 1; }} 复杂度由调和级数证明。$\\mathcal{O(nloglogn):}\\text{Eratothene Sieve}$只筛素数。反正根据素数分布来看大概是$\\mathcal{O(nloglogn)}$的，具体不会证（雾 1234567void sieve() { notprime[1] = 1; for(int i = 2; i &lt;= n; i++) { if(!notprime[i]) for(int j = 2; i*j &lt;= n; j++) notprime[i*j] = 1; }} $\\mathcal{O(n):}\\text{Euler Sieve}$保证每个数都只能被最小的质因子筛到一次，所以复杂度是对的。还可以用于筛一些积性函数。123456789void sieve() { for(int i = 2; i &lt;= n; i++) { if(!!np[i]) prime[++tot] = i; for(int j = 1; j &lt;= tot &amp;&amp; i * prime[j] &lt;= n; j++) { np[i * prime[j]] = 1; if(i % prime[j] == 0) break; } }} 只筛一次的证明：观察这一行：1if(i % prime[j] == 0) break; 考虑这样做代表着什么。显然， $i$ 可以表示成$k\\times prime[j].$ 如果不$break$，那么筛下一个 $prime$ 的时候：就有 $i\\times prime[j+1] = k\\times prime[j]\\times prime[j+1]$ 违背了只被最小质因子筛的规定。 $\\mathcal{O(klogn):}\\text{Miller Rabin}$ 理论背景：费马小定理。$设p \\in prime，a$是整数，且$(a,p)=1$，就有$a^{p-1}\\equiv 1\\mod p$证明：还是举个例子吧。比如说$p=13,a=3$.那么对于$[1,p-1]$之间的整数（也就是$1,2,3…p-1$），我们同乘一个$a$，变成$a,2a,…(p-1)a$。我们发现乘完之后，整数中没有一个$\\mod p=0$（$(a,p)=1$），也没有两个$\\mod p$相等（基本性质）。所以模完之后一定是$[1…p-1]$的一个排列。也就是 a\\times 2a\\times...\\times (p-1)a\\equiv (p-1)!\\pmod p提出来$a$：$a^{p-1}\\times(p-1)!\\equiv (p-1)!\\pmod p$提出来$(p-1)!$：$a^{p-1}\\equiv 1\\pmod p)$.得证。 那么发现上面那个式子同乘$a$就是$a^p\\equiv a\\pmod p$。这个式子在$p$是素数时一定有，但是有这个式子不代表$p$一定是素数。 因此引入二次探测。首先证明一个东西：$x^2\\equiv 1\\pmod p$，且$x ≠ (p-1)\\pmod p$，$x ≠ 1\\mod p$，那么这个$p$一定是合数。 证明：$x^2\\equiv 1\\pmod p$$x^2 - 1\\equiv 0\\pmod p$$(x+1)(x-1)\\equiv 0\\pmod p$ 由于$p$是质数，那么如果他俩乘起来模$p$等于$0$，那么要么$(x+1)\\equiv 0\\pmod p \\rightarrow x=p-1\\pmod p$要么$(x-1)\\equiv 0\\pmod p \\rightarrow x=1\\pmod p$然后，我们发现，费马小定理里头给出的有关$p$的式子是$a^{p-1}\\equiv 1\\pmod p$。于是可以将$p-1$分解为$2^k\\times t$，然后先计算出来$a^t\\mod p$，再不断地将$t$翻倍。其中，如果有一次满足$a^{(2t)}\\equiv 1\\pmod p$且$a^t ≠ \\pm 1\\pmod p$，那就一定是合数。 不难发现每次翻倍最多翻log次，所以复杂度是对的。123456789101112131415161718192021222324252627282930313233343536373839404142434445/** * @Author: Mingyu Li * @Date: 2019-03-24T22:33:04+08:00 * @Last modified by: Mingyu Li * @Last modified time: 2019-03-29T21:02:44+08:00 */#include &lt;bits/stdc++.h&gt;#define Go(i , x , y) for(register int i = x; i &lt;= y; i++)#define God(i , y , x) for(register int i = y; i &gt;= x; i--)#define ll long longll n , m;ll primelist[8] = {2 , 3 , 7 , 13 , 41 , 59 , 97};ll quickt(ll u , ll p , ll t) { if(!p) return 1%t; ll half = quickt(u , p/2 , t); if(p % 2) return half * half % t * u % t; else return half * half % t;}bool Miller_Rabin(ll x) { if(x == 1) return 0; ll div = x-1 , cnt = 0; while(!(div % 2)) div &gt;&gt;= 1 , ++cnt; Go(i , 0 , 6) { if(x == primelist[i]) return 1; ll fst = quickt(primelist[i] , div , x); Go(i , 1 , cnt){ ll scd = fst * fst % x; if(scd == 1 &amp;&amp; !(fst == 1%x || fst == (x-1)%x)) return 0; fst = scd; } if(fst != 1) return 0; } return 1;}int main() { ll n , m; scanf(\"%lld%lld\" , &amp;n , &amp;m); while(m--) { ll x; scanf(\"%lld\" , &amp;x); puts(Miller_Rabin(x) ? \"Yes\":\"No\"); } return 0;} $\\text{GCD}$下面有关于GCD的东西都会提一下。 $\\text{GCD}$求法如果$k|a,k|b$，那一定有$k|max(a,b)\\bmod min(a,b)$，正确性可以画图来证。这就是辗转相除法的原理：$gcd(a,b) = gcd(b , a\\bmod b)$，边界为$gcd(x , 0) = x$每次模一下数量级减少至少一倍，所以复杂度是$\\mathcal{O(logn)}$.1int gcd(int a , int b) {return !b ? a : gcd(b , a%b);} 当然，$C++$中自带的$\\text{std::__gcd(a,b)}$也可以做到这一点，不过$NOIp$好像用不了。 $\\text{ExGCD}$ $\\text{Multiplicative Function}$注意：接下来仅仅谈论数论函数，即定义域仅在正整数域的函数。对于函数$f$：如果对于任何的$(x,y) = 1,f(x)\\times f(y) = f(xy)$，则称$f$函数为积性函数。如果没有$(x,y)=1$的限制，即对于所有正整数对都满足如上条件，则称$f$函数为完全积性函数。 $\\text{Phi’s Function}$$\\varphi(n)$表示$\\leq n$且与$n$互质的数的个数。公式化的描述，$\\varphi(n)=\\sum_{i=1}^{n}[(i,n)==1]$怎么计算？$\\mathcal{O(\\sqrt n)}:\\text{Brute Force}$考虑容斥。我们发现一个数的$\\varphi$一定只跟其质因子有关。于是就可以写出一个式子： \\varphi(n) = n - (n / p_1) - (n / p_2) - ...+ (n / (p1 \\times p2)) + ...\\varphi(n) = n(1 - p_1)(1 - p_2)...(1 - p_n)（其实就是硬拆上面那个式子得到的）然后就可以枚举质因子硬乘就可以了。 1234567891011ll phi(ll n) { ll ans = n; for(ll i = 2; i * i &lt;= n; i++) { if(n % i == 0) { while(n % i == 0) n /= i; ans = ans / i * (i - 1); } } if(n &gt; 1) ans = ans / n * (n - 1); return ans;} $\\text{Linear Sieve}$考虑硬拆式子。重温$\\text{Euler Sieve}$的过程，就是找$n$的最小质因子$p_1$将其用$p_1 \\times (n / p_1)$筛掉。先设$n’ = n / p_1$，再分两种情况讨论：$①:n’$有$p_1$这一因子。意味着唯一分解中$k_1 &gt; 1$那么显然，$n’$有着$n$的所有质因子。所以 \\begin{aligned} \\varphi(n)&= n \\prod\\limits_{i = 1} ^ {n} \\frac{p_i - 1}{p_i} \\\\ &= p_1 \\times n' \\prod\\limits_{i = 1} ^ {n} \\frac{p_i - 1}{p_i} \\\\ &= p_1 \\times \\varphi(n') \\\\ \\end{aligned}$②:n’$没有$p_1$这一因子。意味着唯一分解中$k_1 = 1$ \\begin{aligned} \\varphi(n)&= n \\prod_{i = 1} ^ {n} \\frac{p_i - 1}{p_i} \\\\ &= p_1 \\times n' \\times \\frac{p_1-1}{p_1} \\prod\\limits_{i = 2} ^ {n} \\frac{p_i - 1}{p_i} \\\\ &= (p_1-1) \\times \\varphi(n') \\\\ \\end{aligned}（其实也证明了欧拉函数是积性函数）愉快的筛就好了。注意任何积性函数都有$f(1) = 1$.123456789101112131415void Euler_Sieve(int x) { np[1] = 1; phi[1] = 1; Go(i , 2 , x) { if(!np[i]) prime[++cnt] = i , phi[i] = i - 1; for(int j = 1; j &lt;= cnt &amp;&amp; i * prime[j] &lt;= x; j++) { np[i * prime[j]] = 1; if(i % prime[j]) phi[i * prime[j]] = phi[i] * (prime[j] - 1); else { phi[i * prime[j]] = prime[j] * phi[i]; break; } } }}","link":"/2019/03/23/省选基础数论整理/"},{"title":"CodeForces Round 545(div 2) 题解","text":"跟个sb一样比赛链接今天来改题了。 A题意：找出最长的一段区间使得区间长度是偶数，且区间前一半只有一种数，后一半只有一种数。 $a[i] \\in [1,2], n \\leq 100000$. A solution解：考虑分段。 123举个例子：[1 2 2 1 2 2 2 1 1 2 1]按相同的值分为一段之后就会变成[1 | 2 2 | 1 | 2 2 2 | 1 1 | 2 | 1] 显然目标区间一定会在相邻的两个段里，正确性显然。于是直接计算即可。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546/** * @Author: Mingyu Li * @Date: 2019-03-08T17:07:17+08:00 * @Email: class11limingyu@126.com * @Filename: c1138A.cpp * @Last modified by: Mingyu Li * @Last modified time: 2019-03-09T09:16:10+08:00 */#include &lt;bits/stdc++.h&gt;#define tpname typename#define Go(i , x , y) for(register int i = x; i &lt;= y; i++)#define God(i , y , x) for(register int i = y; i &gt;= x; i--)typedef long long LL;typedef long double ld;typedef unsigned long long ULL;template &lt; tpname T &gt; void sc(T&amp; t) { char c = getchar(); T x = 1; t = 0; while(!isdigit(c)) {if(c == '-') x = -1; c = getchar();} while(isdigit(c)) t = t * 10 + c - '0' , c = getchar();t *= x;}template &lt; tpname T , tpname... Args &gt; void sc(T&amp; t , Args&amp;... args) {sc(t); sc(args...);}template &lt; tpname T &gt; T mul(T x , T y , T _) { x %= _,y %= _; return ((x * y - (T)(((ld)x * y + 0.5) / _) * _) % _ + _) % _;}const int N = 100000 + 10;int pref[3][N] , suf[3][N];int n , ans = 0 , t[N];int main() { sc(n); Go(i,1,n) sc(t[i]); std::vector &lt; int &gt; v; int cnt = 1; Go(i , 2 , n+1) { if(t[i] != t[i - 1]) { v.push_back(cnt); cnt = 0; } cnt++; } Go(i , 0 , (int)v.size() - 2) ans = std::max(ans , std::min(v[i] , v[i + 1]) * 2); std::cout &lt;&lt; ans &lt;&lt; \" \\n\"; return 0;} B题意：给定一张$2$行$n$列的表格$A$.$A[i][j]$代表第$j$个人擅不擅长项目$i$.要求将$n$个人分成2组，每组$n/2$个人。（保证$n$是偶数）并满足第一组擅长项目1的人数=第二组擅长项目2的人数。输出方案。$n \\leq 5000$. B solution解：下文中将默认$(i,j)$为是否擅长项目1与项目2。看起来好像很难下手，但是只需要枚举即可。枚举第一组中$(1,0)$的人数与$(1,1)$的人数。 接着，第一组擅长项目1的人数就确定了，第二组$(1,1)$的人数也确定了，那就可以确定第二组$(0,1)$的人数了。第二组确定了，第一组也能确定。于是第一组的$(0,0)$人数也确定了。第二组随之确定。如果所有人数都合法就输出。如果没有任何一组人数合法，输出$-1$. 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162/** * @Author: Mingyu Li * @Date: 2019-03-08T17:51:24+08:00 * @Email: class11limingyu@126.com * @Filename: c1138B.cpp * @Last modified by: Mingyu Li * @Last modified time: 2019-03-09T10:47:22+08:00 */#include &lt;bits/stdc++.h&gt;#define tpname typename#define Go(i , x , y) for(register int i = x; i &lt;= y; i++)#define God(i , y , x) for(register int i = y; i &gt;= x; i--)typedef long long LL;typedef long double ld;typedef unsigned long long ULL;template &lt; tpname T &gt; void sc(T&amp; t) { char c = getchar(); T x = 1; t = 0; while(!isdigit(c)) {if(c == '-') x = -1; c = getchar();} while(isdigit(c)) t = t * 10 + c - '0' , c = getchar();t *= x;}template &lt; tpname T , tpname... Args &gt; void sc(T&amp; t , Args&amp;... args) {sc(t); sc(args...);}template &lt; tpname T &gt; T mul(T x , T y , T _) { x %= _,y %= _; return ((x * y - (T)(((ld)x * y + 0.5) / _) * _) % _ + _) % _;}int n;std::string a , b;std::vector &lt; int &gt; v00 , v01 , v10 , v11;int main() { v00.clear(); v11.clear(); v01.clear(); v10.clear(); std::cin &gt;&gt; n; std::cin &gt;&gt; a &gt;&gt; b; a = \"%\" + a; b = \"%\" + b; Go(i , 1 , n) { if(a[i] == '1' &amp;&amp; b[i] == '1') v11.push_back(i); else if(a[i] == '0' &amp;&amp; b[i] == '0') v00.push_back(i); else if(a[i] == '0' &amp;&amp; b[i] == '1') v01.push_back(i); else if(a[i] == '1' &amp;&amp; b[i] == '0') v10.push_back(i); } Go(s10 , 0 , (int)(v10.size())) Go(s11 , 0 , (int)(v11.size())) { if(s10 + s11 &gt; n/2) continue; // 选完之后 剩下的s10和s11进入第二组 // 对答案有贡献的只有s11 int g2_s01 = s10 + 2 * s11 - (int)((int)(v11.size())); int g1_s01 = (int)(v01.size()) - g2_s01; if(g2_s01 &gt;= 0 &amp;&amp; g2_s01 &lt;= (int)(v01.size())) { int g1_s00 = n/2 - g1_s01 - s10 - s11; if(g1_s00 &gt;= 0 &amp;&amp; g1_s00 &lt;= (int)(v00.size())) { Go(i , 0 , s11 - 1) std::cout &lt;&lt; v11[i] &lt;&lt; \" \"; Go(i , 0 , s10 - 1) std::cout &lt;&lt; v10[i] &lt;&lt; \" \"; Go(i , 0 , g1_s01 - 1) std::cout &lt;&lt; v01[i] &lt;&lt; \" \"; Go(i , 0 , g1_s00 - 1) std::cout &lt;&lt; v00[i] &lt;&lt; \" \"; puts(\"\"); return 0; } } } puts(\"-1\"); return 0;} C给定一个$n\\times m$大小的表格。要求对于每一个位置$(i,j)$,求出$ans(i,j)$.其中$ans(i,j)$表示将第i行和第j列的某些数更改后使得在满足行内所有数相对大小关系不变，列内所有数相对大小关系不变的情况下，行列内最大值 的最小值。 $n,m \\leq 1000$. 时限2s. C solution解：发现除了$a[i][j]$一个交界点之外，行列之间是独立的。所以，只需要确定$a[i][j]$重新排列之后的排名即可。这玩意很好确定。因为行列之间是独立的，所以答案就是 max(行内比a[i][j]小的数的种数,列内比a[i][j]小的数的种数)+1同理，题目要求最小化最大值。由于行列独立，所以最大值的编号就是 a[i][j]排名+max(行内比a[i][j]大的数的种数,列内比a[i][j]大的数的种数)这个东西可以每行每列一起预处理，复杂度$\\Theta(n^2 log(n))$.12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364/** * @Author: Mingyu Li * @Date: 2019-03-09T10:47:43+08:00 * @Email: class11limingyu@126.com * @Filename: c1138C.cpp * @Last modified by: Mingyu Li * @Last modified time: 2019-03-09T11:57:03+08:00 */#include &lt;bits/stdc++.h&gt;#define tpname typename#define Go(i , x , y) for(register int i = x; i &lt;= y; i++)#define God(i , y , x) for(register int i = y; i &gt;= x; i--)typedef long long LL;typedef long double ld;typedef unsigned long long ULL;template &lt; tpname T &gt; void sc(T&amp; t) { char c = getchar(); T x = 1; t = 0; while(!isdigit(c)) {if(c == '-') x = -1; c = getchar();} while(isdigit(c)) t = t * 10 + c - '0' , c = getchar();t *= x;}template &lt; tpname T , tpname... Args &gt; void sc(T&amp; t , Args&amp;... args) {sc(t); sc(args...);}template &lt; tpname T &gt; T mul(T x , T y , T _) { x %= _,y %= _; return ((x * y - (T)(((ld)x * y + 0.5) / _) * _) % _ + _) % _;}const int N = 1000 + 10;int ans[N][N];int n , m , it;int a[N][N] , b[N];int ans1[N][N] , ans2[N][N] , big1[N][N] , big2[N][N];int p = 0;int main() { sc(n , m); Go(i , 1 , n) Go(j , 1 , m) sc(a[i][j]); Go(i , 1 , n) { p = 0; Go(j , 1 , m) b[++p] = a[i][j]; std::sort(b + 1 , b + p + 1); p = std::unique(b + 1 , b + p + 1) - (b + 1); Go(j , 1 , m) { ans1[i][j] = std::lower_bound(b+1 , b+p+1 , a[i][j]) - b; big1[i][j] = p - ans1[i][j]; } } Go(i , 1 , m) { p = 0; Go(j , 1 , n) b[++p] = a[j][i]; std::sort(b + 1 , b + p + 1); p = std::unique(b + 1 , b + p + 1) - (b + 1); Go(j , 1 , n) { ans2[j][i] = std::lower_bound(b+1 , b+p+1 , a[j][i]) - b; big2[j][i] = p - ans2[j][i]; } } Go(i , 1 , n) { Go(j , 1 , m) printf(\"%d \" , std::max(ans1[i][j] , ans2[i][j]) + std::max(big1[i][j] , big2[i][j])); puts(\"\"); } return 0;} D给定只包含01的字符串$s$和$t$，重排列$s$字符串使得$t$在其中作为子串出现的次数最多。 $|s|,|t| \\leq 500000$. D solution首先考虑最优解一定长成什么样子——一定是一个t串加很多个小节，每加一个小节就会多产生一个$t$子串。有了这部转化就很简单了。容易发现这个小节即为长度为$|t|-border(t)$的$t$串后缀。能输出多少份输出多少份。$border$用$KMP$或$Hash$维护都可以（注意$Hash$被卡） 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990/** * @Author: Mingyu Li * @Date: 2019-03-09T12:54:42+08:00 * @Email: class11limingyu@126.com * @Filename: c1138D.cpp * @Last modified by: Mingyu Li * @Last modified time: 2019-03-09T22:14:16+08:00 */#include &lt;bits/stdc++.h&gt;#define tpname typename#define Go(i , x , y) for(register int i = x; i &lt;= y; i++)#define God(i , y , x) for(register int i = y; i &gt;= x; i--)typedef long long LL;typedef long double ld;typedef unsigned long long ULL;template &lt; tpname T &gt; void sc(T&amp; t) { char c = getchar(); T x = 1; t = 0; while(!isdigit(c)) {if(c == '-') x = -1; c = getchar();} while(isdigit(c)) t = t * 10 + c - '0' , c = getchar();t *= x;}template &lt; tpname T , tpname... Args &gt; void sc(T&amp; t , Args&amp;... args) {sc(t); sc(args...);}template &lt; tpname T &gt; T mul(T x , T y , T _) { x %= _,y %= _; return ((x * y - (T)(((ld)x * y + 0.5) / _) * _) % _ + _) % _;}const int N = 500000 + 5;const ULL P1 = 13331;const ULL P2 = 19260817;const ULL MOD1 = 314159;const ULL MOD2 = (1000000007);ULL Hash1[N] , Hash2[N] , pw1[N] , pw2[N];int cnt[2] , cnt1[2] , n , m;char a[N + 5] , b[N + 5];void Prework() { pw1[0] = pw2[0] = 1; Go(i , 1 , n) pw1[i] = pw1[i - 1] * P1 % MOD1 , pw2[i] = pw2[i - 1] * P2 % MOD2; Go(i , 1 , n) { Hash1[i] = (Hash1[i - 1] * P1 % MOD1 + b[i]) % MOD1; Hash2[i] = (Hash2[i - 1] * P2 % MOD2 + b[i]) % MOD2; }}bool same(int l1, int r1, int l2, int r2) { return ((Hash2[r2] + MOD2 - Hash2[l2 - 1] * pw2[r2 - l2 + 1] % MOD2) % MOD2 == (Hash2[r1] + MOD2 - Hash2[l1 - 1] * pw2[r1 - l1 + 1] % MOD2) % MOD2 &amp;&amp; (Hash1[r2] + MOD1 - Hash1[l2 - 1] * pw1[r2 - l2 + 1] % MOD1) % MOD1 == (Hash1[r1] + MOD1 - Hash1[l1 - 1] * pw1[r1 - l1 + 1] % MOD1) % MOD1);}int LCP() { int ans = 0; Go(i , 1 , n-1) { if(same(1 , i , n-i+1 , n)) ans = i; } return ans;}int main() { scanf(\"%s\" , (a + 1)); scanf(\"%s\" , (b + 1)); m = strlen(a + 1) , n = strlen(b + 1); Prework(); Go(i , 1 , m) cnt[a[i] - '0']++; Go(i , 1 , n) cnt1[b[i] - '0']++; int fill = n - LCP(); if(cnt[0] &lt; cnt1[0] || cnt[1] &lt; cnt1[1]) { Go(i , 1 , m) putchar(a[i]); puts(\"\"); return 0; } cnt[0] -= cnt1[0] , cnt[1] -= cnt1[1]; cnt1[0] = cnt1[1] = 0; Go(i , n - fill + 1 , n) ++cnt1[b[i] - '0']; Go(i , 1 , n) putchar(b[i]); Go(i , 1 , 2147483647) { bool f = 1; Go(j , n - fill + 1 , n) { if(!cnt[b[j] - '0']) { f = 0; break; } putchar(b[j]); cnt[b[j] - '0']--; } if(!f) break; } if(cnt[1]) Go(i , 1 , cnt[1]) putchar('1'); if(cnt[0]) Go(i , 1 , cnt[0]) putchar('0'); return 0;}","link":"/2019/03/09/CF545-div-2-题解/"},{"title":"FFT详解","text":"用于计算一类朴素卷积问题。 笔者学习的是这份博客内容中可能有很多相同之处，敬请谅解。 现在要计算两个一元$n$次多项式$F(x)$与$G(x)$的乘积，如何计算？前置知识：多项式的表示方法一. 系数表示法对于一个$n$次多项式$F(x)$，它可以被表示成 F(x) = a_nx^n+a_{n-1}x^{n-1}+...+a_1x^1+a_0x^0.更加形式化的来说，它可以表示成 F(x) = \\sum_{i=0}^{n} a_ix^i.举个例子，2次多项式，其中$a_0=1,a_1=2,a_2=1$那么$F(x)=1x^2+2x+1.$这样即可通俗的表示出一个$n$次多项式。二. 点值表示法众所周知，两个点确定一个一次函数，三个点确定一个二次函数。所以，$n+1$个点确定一个一元$n$次多项式。所以我们可以通过$n+1$个点来表示它。那么相乘之后的点值如何计算？比如说两个2次多项式$F(x)=x^2+2x+1$（红色）与$G(x)=3x^2-4x-2$（蓝色），它们的图像如图所示：那么观察图中$x=1$时的情况。此时$F(1)=4,G(1)=-3.$所以，显然，$F(1)\\times G(1)=-12$.也就是说在$Z=FG$这一多项式内，带入$1$，得到的结果是$-12$.等等，好像有哪里不对。如果说$Z=FG$的话，那么Z的次数应该是$2n$.那$Z$需要$2n+1$个点来确定。但是原来只需要$n+1$个点，咋办？很简单，在原来的多项式里每个都多加$n$个点即可。反正多项式已知。这样就可以用点值来进行操作。也就是说先转成点值，再一乘，再转回来，就是计算流程。但是好像还是很慢。那么如何优化呢?复数部分复数，即形如$a+bi$的数，其中$i^2=-1.$ $a$称为实部，$bi$称为虚部。或者说：在一个数轴上（只有x轴），我们可以表示出任何实数。那么，多加一维（y轴），也就是类似于平面直角坐标系一样，我们就可以表示出任意一个复数。所以我们把这个坐标系叫做复平面，其中x轴称为实轴，y轴称为虚轴。复数运算复数相加：实部相加，虚部相加，例如 (a+bi)+(c+di)=(a+c)+(b+d)i.复数相减：同理。 (a+bi)-(c+di)=(a-c)+(b-d)i.复数相乘：像一次多项式一样相乘。 注意$i^2=-1$. (a+bi)(c+di)=ac+(ad+bc)i-bd=(ac-bd)+(ad+bc)i.复数相除：相信大家都学过共轭根式。同样的，复数也有共轭。即：$a+bi$的共轭为$a-bi$。这两个复数卡乘在一起一定是个实数。即 (a+bi)(a-bi)=a^2-(bi)^2=a^2+b^2.所以再除的时候，将分子分母同乘分母的共轭，就可以将分母有理化。即 \\frac{a+bi}{c+di}=\\frac{(a+bi)(c-di)}{c^2+d^2}=\\frac{ac+bd}{c^2+d^2}+\\frac{bc-ad}{c^2+d^2}i.复数逆元： \\frac{1}{a+bi}=\\frac{a}{a^2+b^2}-\\frac{b}{a^2+b^2}i.同样的，复数运算在复平面内也有一定规律可循。考虑在复平面内的两个复数：（借张图） 表示的是复数$(1+4i)$与复数$(3+2i)$相乘所得的结果：$(-5+14i)$。设其中$(5,0)$点为位置$P$，则$\\angle{POC}=\\angle{BOA}.$还有：$\\overline{OB}\\times\\overline{OC}=\\overline{OA}.$第二个证明：勾股定理。先把$i$消掉。$\\overline{OB}^2=a^2+b^2.$ $\\overline{OC}^2=c^2+d^2.$$\\overline{OB}^2\\times \\overline{OC}^2=(a^2+b^2)(c^2+d^2)=a^2c^2+a^2d^2+b^2c^2+b^2d^2.$$\\overline{OA}^2=(ac-bd)^2+(ad+bc)^2=a^2c^2+a^2d^2+b^2c^2+b^2d^2.$得证。我们将复数中，复数向量的长度称为模长，向量与x轴正方向的夹角称为幅角。根据上面的东西：复数相乘时，模长相乘，幅角相加。单位根一个n次的单位根即为方程$x^n=1$的复数解。考虑这样一个图：其中圆上的所有复数模长都是1，这个圆称为单位圆。考虑$|x|$的取值范围：如果$|x|","link":"/2019/03/08/FFT详解/"}],"tags":[{"name":"Orz","slug":"Orz","link":"/tags/Orz/"},{"name":"线段树","slug":"线段树","link":"/tags/线段树/"},{"name":"高斯消元","slug":"高斯消元","link":"/tags/高斯消元/"},{"name":"概率期望dp","slug":"概率期望dp","link":"/tags/概率期望dp/"},{"name":"数学","slug":"数学","link":"/tags/数学/"},{"name":"FFT","slug":"FFT","link":"/tags/FFT/"},{"name":"树状数组","slug":"树状数组","link":"/tags/树状数组/"},{"name":"数据结构","slug":"数据结构","link":"/tags/数据结构/"},{"name":"2-SAT","slug":"2-SAT","link":"/tags/2-SAT/"},{"name":"Tarjan","slug":"Tarjan","link":"/tags/Tarjan/"},{"name":"并查集","slug":"并查集","link":"/tags/并查集/"},{"name":"拓扑排序","slug":"拓扑排序","link":"/tags/拓扑排序/"},{"name":"dp","slug":"dp","link":"/tags/dp/"},{"name":"Hash","slug":"Hash","link":"/tags/Hash/"},{"name":"数位dp","slug":"数位dp","link":"/tags/数位dp/"},{"name":"数论","slug":"数论","link":"/tags/数论/"},{"name":"KMP","slug":"KMP","link":"/tags/KMP/"},{"name":"exKMP","slug":"exKMP","link":"/tags/exKMP/"},{"name":"三分法","slug":"三分法","link":"/tags/三分法/"},{"name":"卡常数","slug":"卡常数","link":"/tags/卡常数/"},{"name":"trie","slug":"trie","link":"/tags/trie/"},{"name":"可持久化","slug":"可持久化","link":"/tags/可持久化/"},{"name":"后缀数组, 字符串","slug":"后缀数组-字符串","link":"/tags/后缀数组-字符串/"},{"name":"AC自动机","slug":"AC自动机","link":"/tags/AC自动机/"},{"name":"manacher","slug":"manacher","link":"/tags/manacher/"},{"name":"CodeForces","slug":"CodeForces","link":"/tags/CodeForces/"}],"categories":[{"name":"游记","slug":"游记","link":"/categories/游记/"},{"name":"题解","slug":"题解","link":"/categories/题解/"},{"name":"算法笔记","slug":"算法笔记","link":"/categories/算法笔记/"},{"name":"省选复习","slug":"省选复习","link":"/categories/省选复习/"}]}